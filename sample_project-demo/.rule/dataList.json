[
	{
		"name": "A project should not include undefined data types",
		"code": "MSR_2_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "2.3",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}包含未使用的数据类型的定义。",
			"code": "MSR_2_3",
			"override": "T",
			"master_id": "2001",
			"name": "A project should not include undefined data types",
			"name_cn": "不应该包含未使用的数据类型的定义",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A project should not include undefined data types",
			"desc_cn": "不应该包含未使用的数据类型的定义",
			"abstract": "A project should not include undefined data types",
			"explanation": "An undefined data type will cause a waste of resources. When reviewing the code, it will also be difficult to determine whether the data type is not used due to an error in the programming process or if it is just extra code. ",
			"abstract_cn": "不应该包含未使用的数据类型的定义",
			"explanation_cn": "未定义的数据类型，不单止会导致会浪费资源，还会在审查该代码时难以确定是由于编程过程中的错误导致没有使用该数据类型，还是其只是代码的多余部分。",
			"example_good": "///c:\n#include <stdio.h>\n\ntypedef int used; // type is declared here\n\nint main()\n{\n    used a = 1; // type is used here\n    printf(\"%d\",a);\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\ntypedef int used; // type is declared but not used\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}",
			"details_en": "#### Abstract\nA project should not include undefined data types\n\n#### Explanation\nAn undefined data type will cause a waste of resources. When reviewing the code, it will also be difficult to determine whether the data type is not used due to an error in the programming process or if it is just extra code. ",
			"details_cn": "#### 概要\n不应该包含未使用的数据类型的定义\n\n#### 解释\n未定义的数据类型，不单止会导致会浪费资源，还会在审查该代码时难以确定是由于编程过程中的错误导致没有使用该数据类型，还是其只是代码的多余部分。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\ntypedef int used; // type is declared here\n\nint main()\n{\n    used a = 1; // type is used here\n    printf(\"%d\",a);\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\ntypedef int used; // type is declared but not used\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629110330360"
	},
	{
		"name": "Unused label in function not allowed",
		"code": "MSR_2_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "2.6",
			"misra_cpp": "0-1-5",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, unused tags are declared in ${so.func}.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用了未使用的标签。",
			"code": "MSR_2_6",
			"override": "T",
			"master_id": "2002",
			"name": "Unused label in function not allowed",
			"name_cn": "函数中不允许使用未使用的标签",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Unused tags cannot be declared in the function",
			"desc_cn": "函数中不能声明未使用的标签",
			"abstract": "Unused tags cannot be declared in the function",
			"explanation": "The reviewer of the code cannot judge whether the unused tag is redundant or is not used due to negligence, so the unused label cannot be declared. ",
			"abstract_cn": "函数中不能声明未使用的标签",
			"explanation_cn": "代码的审查者无法判断未使用的标签是多余的还是因疏漏而未使用，因此不能声明未使用的标签。",
			"example_good": "///c:\n#include <stdio.h>\n\nint func( void )\n{\n    int i = 5;\n    goto lab1; // label used\n    if (i != 5) i = 5;\nlab1: // label declared\n    return i;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint func( void )\n{\n    int i = 5;\n    if (i != 5) i = 5;\nlab1: // unused label declared\n    return i;\n}",
			"details_en": "#### Abstract\nUnused tags cannot be declared in the function\n\n#### Explanation\nThe reviewer of the code cannot judge whether the unused tag is redundant or is not used due to negligence, so the unused label cannot be declared. ",
			"details_cn": "#### 概要\n函数中不能声明未使用的标签\n\n#### 解释\n代码的审查者无法判断未使用的标签是多余的还是因疏漏而未使用，因此不能声明未使用的标签。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func( void )\n{\n    int i = 5;\n    goto lab1; // label used\n    if (i != 5) i = 5;\nlab1: // label declared\n    return i;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func( void )\n{\n    int i = 5;\n    if (i != 5) i = 5;\nlab1: // unused label declared\n    return i;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629163530011"
	},
	{
		"name": "All declared parameters must be used",
		"code": "MSR_2_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M0-1-11",
			"misra_c": "2.7",
			"misra_cpp": "0-1-11",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, unused parameters appear in ${so.func}.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现未使用的参数。",
			"code": "MSR_2_7",
			"override": "T",
			"master_id": "2003",
			"name": "All declared parameters must be used",
			"name_cn": "必须使用所有声明过的参数",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Unused parameters should not appear in the function",
			"desc_cn": "函数中不应出现未使用的参数",
			"abstract": "Unused parameters should not appear in the function",
			"explanation": "The function should use all its parameters. If the function does not use all its parameters, the implementation will not match the declaration of the function. ",
			"abstract_cn": "函数中不应出现未使用的参数",
			"explanation_cn": "函数应该使用其所有的参数。若函数未使用其所有的参数则其功能的实现很可能与在设计该函数时所希望达到的目的不相匹配。",
			"example_good": "///c:\n#include <stdio.h>\n\nint Addtion(int a,int b,int c);\n\nint main()\n{\n    printf(\"%d\",Addtion(1,2,3));\n    return 0;\n}\nint Addtion(int a,int b,int c)\n{\n    return a+b+c; // every parameter is used\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint Addtion(int a,int b,int c);\n\nint main()\n{\n    printf(\"%d\",Addtion(1,2,3));\n    return 0;\n}\n // three parameters are defined\nint Addtion(int a,int b,int c)\n{\n    return a+b; // only two of them are used\n}",
			"details_en": "#### Abstract\nUnused parameters should not appear in the function\n\n#### Explanation\nThe function should use all its parameters. If the function does not use all its parameters, the implementation will not match the declaration of the function. ",
			"details_cn": "#### 概要\n函数中不应出现未使用的参数\n\n#### 解释\n函数应该使用其所有的参数。若函数未使用其所有的参数则其功能的实现很可能与在设计该函数时所希望达到的目的不相匹配。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint Addtion(int a,int b,int c);\n\nint main()\n{\n    printf(\"%d\",Addtion(1,2,3));\n    return 0;\n}\nint Addtion(int a,int b,int c)\n{\n    return a+b+c; // every parameter is used\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint Addtion(int a,int b,int c);\n\nint main()\n{\n    printf(\"%d\",Addtion(1,2,3));\n    return 0;\n}\n // three parameters are defined\nint Addtion(int a,int b,int c)\n{\n    return a+b; // only two of them are used\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629163682547"
	},
	{
		"name": "All external identifiers must be unique up to 31 characters",
		"code": "MSR_5_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "5.1",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, external identifiers are not unique.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现不唯一的外部标识符。",
			"code": "MSR_5_1",
			"override": "T",
			"master_id": "2004",
			"name": "All external identifiers must be unique up to 31 characters",
			"name_cn": "所有外部标识符必须是唯一的，最多31个字符",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The external identifier must be distinguishable",
			"desc_cn": "外部标识符要求可区别",
			"abstract": "The external identifier must be distinguishable",
			"explanation": "In the C99 standard, external identifiers should be distinguished by at least the first 31 characters. The external identifiers must be distinct with respect to the first 31 characters, so they are deemed unique by the compiler. ",
			"abstract_cn": "外部标识符要求可区别",
			"explanation_cn": "在C99标准中，外部标识符应至少满足前31个字符有区别，以确保所有外部标识符可通过前31个字符得以区分。",
			"example_good": "///c:\n#include <stdio.h>\n\nint main()\n{\n    // the first 31 characters are distinct\n    int a_non_compliant_example_a = 1;\n    int a_non_compliant_example_b = 2; \n    int a;\n    a = a_non_compliant_example_a + a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} ",
			"example_bad": "///c:\n#include <stdio.h>\n\nint main()\n{\n    // the first 31 characters are not distinct\n    int this_is_a_non_compliant_example_a = 1;\n    int this_is_a_non_compliant_example_b = 2; \n    int a;\n    a = this_is_a_non_compliant_example_a + this_is_a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} ",
			"details_en": "#### Abstract\nThe external identifier must be distinguishable\n\n#### Explanation\nIn the C99 standard, external identifiers should be distinguished by at least the first 31 characters. The external identifiers must be distinct with respect to the first 31 characters, so they are deemed unique by the compiler. ",
			"details_cn": "#### 概要\n外部标识符要求可区别\n\n#### 解释\n在C99标准中，外部标识符应至少满足前31个字符有区别，以确保所有外部标识符可通过前31个字符得以区分。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint main()\n{\n    // the first 31 characters are distinct\n    int a_non_compliant_example_a = 1;\n    int a_non_compliant_example_b = 2; \n    int a;\n    a = a_non_compliant_example_a + a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint main()\n{\n    // the first 31 characters are not distinct\n    int this_is_a_non_compliant_example_a = 1;\n    int this_is_a_non_compliant_example_b = 2; \n    int a;\n    a = this_is_a_non_compliant_example_a + this_is_a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629163762989"
	},
	{
		"name": "Identifiers declared should be distinguishable if they are in the same scope and namespace",
		"code": "MSR_5_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "A2-11-1",
			"misra_c": "5.2",
			"misra_cpp": "2-10-2",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, identifiers are not distinguishable.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现不可被区分的标识符。",
			"code": "MSR_5_2",
			"override": "T",
			"master_id": "2005",
			"name": "Identifiers declared should be distinguishable if they are in the same scope and namespace",
			"name_cn": "相同范围和名称空间的标识符必须是唯一的",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Identifiers declared should be distinguishable if they are in the same scope and namespace",
			"desc_cn": "在同一作用域和命名空间中被声明的标识符应该可以被区分",
			"abstract": "Identifiers declared should be distinguishable if they are in the same scope and namespace",
			"explanation": "In the same scope, the first 31 characters of different identifiers should not be exactly the same to ensure they are distinguishable.",
			"abstract_cn": "在同一作用域和命名空间中被声明的标识符应该可以被区分",
			"explanation_cn": "在同一作用域内应该满足不同标识符的前31个字符不完全相同以进行区别。",
			"example_good": "///c:\n#include <stdio.h>\n\n// this example have two identifiers, first 31 characters are the same\nextern int this_is_a_non_compliant_example_a = 1; // first identifier, global scope\n\nint main()\n{\n    int a;\n    int this_is_a_non_compliant_example_b = 2; // two identifiers are defined in local scope\n    a = 1 + this_is_a_non_compliant_example_b;\n    printf (\"%d\\n\",a);\n    return 0;\n} ",
			"example_bad": "///c:\n#include <stdio.h>\n\n// this example have two identifiers, first 31 characters are the same\nextern int a_non_compliant_example_a = 1;\nextern int a_non_compliant_example_b = 2; // two indistinct identifiers are defined in the same scope\n\nint main()\n{\n    int a;\n    a = 1 + a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} ",
			"details_en": "#### Abstract\nIdentifiers declared should be distinguishable if they are in the same scope and namespace\n\n#### Explanation\nIn the same scope, the first 31 characters of different identifiers should not be exactly the same to ensure they are distinguishable.",
			"details_cn": "#### 概要\n在同一作用域和命名空间中被声明的标识符应该可以被区分\n\n#### 解释\n在同一作用域内应该满足不同标识符的前31个字符不完全相同以进行区别。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// this example have two identifiers, first 31 characters are the same\nextern int this_is_a_non_compliant_example_a = 1; // first identifier, global scope\n\nint main()\n{\n    int a;\n    int this_is_a_non_compliant_example_b = 2; // two identifiers are defined in local scope\n    a = 1 + this_is_a_non_compliant_example_b;\n    printf (\"%d\\n\",a);\n    return 0;\n} "
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// this example have two identifiers, first 31 characters are the same\nextern int a_non_compliant_example_a = 1;\nextern int a_non_compliant_example_b = 2; // two indistinct identifiers are defined in the same scope\n\nint main()\n{\n    int a;\n    a = 1 + a_non_compliant_example_b;\n    printf(\"%d\\n\",a);\n    return 0;\n} "
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629163825507"
	},
	{
		"name": "Identifiers in inner and outer scope must be distinct",
		"code": "MSR_5_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "5.3",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, identifiers are not distinct.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现相同标识符，",
			"code": "MSR_5_3",
			"override": "T",
			"master_id": "2006",
			"name": "Identifiers in inner and outer scope must be distinct",
			"name_cn": "内部和外部作用域中的标识符必须不同",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The identifier of the internal scope should be different from the identifier of the external scope",
			"desc_cn": "内部作用域的标识符应与外部作用域的不同",
			"abstract": "The identifier of the internal scope should be different from the identifier of the external scope",
			"explanation": "When defining variables in the internal scope, you should avoid having the same name as the external scope to prevent creating ambiguity.",
			"abstract_cn": "内部作用域的标识符应与外部作用域的不同",
			"explanation_cn": "在内部作用域定义变量时应该避免与外部作用域同名，以防止产生歧义。",
			"example_good": "///c:\n#include <stdio.h>\n\nint a = 3; // identifier defined, outer scope\n\nint main()\n{\n    int b; // identifier defined, inner scope, different form the outer one\n    b = 4;\n    printf(\"%d\",b);\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint a = 3; // identifier defined, outer scope\n\nint main()\n{\n    int a; // identifier defined, inner scope, covering the outer one\n    a = 4;\n    printf(\"%d\",a);\n    return 0;\n}",
			"details_en": "#### Abstract\nThe identifier of the internal scope should be different from the identifier of the external scope\n\n#### Explanation\nWhen defining variables in the internal scope, you should avoid having the same name as the external scope to prevent creating ambiguity.",
			"details_cn": "#### 概要\n内部作用域的标识符应与外部作用域的不同\n\n#### 解释\n在内部作用域定义变量时应该避免与外部作用域同名，以防止产生歧义。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint a = 3; // identifier defined, outer scope\n\nint main()\n{\n    int b; // identifier defined, inner scope, different form the outer one\n    b = 4;\n    printf(\"%d\",b);\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint a = 3; // identifier defined, outer scope\n\nint main()\n{\n    int a; // identifier defined, inner scope, covering the outer one\n    a = 4;\n    printf(\"%d\",a);\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629164007361"
	},
	{
		"name": "typedef name should be a unique identifier",
		"code": "MSR_5_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M2-10-3",
			"misra_c": "5.6",
			"misra_cpp": "2-10-3",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the typedef identifier is not unique.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，typedef标识符不唯一。",
			"code": "MSR_5_6",
			"override": "T",
			"master_id": "2007",
			"name": "typedef name should be a unique identifier",
			"name_cn": "typedef 名称应为唯一标识符",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A typedef identifier must be unique",
			"desc_cn": "typedef标识符必须唯一",
			"abstract": "A typedef identifier must be unique",
			"explanation": "Unless the alias is defined in the header file, and the header file is included, the alias defined by the typedef used must be unique in all namespaces.",
			"abstract_cn": "typedef标识符必须唯一",
			"explanation_cn": "除非该别名在头文件中被定义且该头文件被包含，否则所用typedef定义的别名在所有命名空间中必须唯一。",
			"example_good": "///c:\n#include <stdio.h>\n\ntypedef int my_name; // unique typedef declared\n\nint main()\n{\n    int my_name_2 = 1; // unique variable declared \n    printf(\"%d\",my_name_2);\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\ntypedef int my_name; // typedef declared\n\nint main()\n{\n    int my_name = 1; // variable declared, same identifier\n    printf(\"%d\",my_name);\n    return 0;\n}",
			"details_en": "#### Abstract\nA typedef identifier must be unique\n\n#### Explanation\nUnless the alias is defined in the header file, and the header file is included, the alias defined by the typedef used must be unique in all namespaces.",
			"details_cn": "#### 概要\ntypedef标识符必须唯一\n\n#### 解释\n除非该别名在头文件中被定义且该头文件被包含，否则所用typedef定义的别名在所有命名空间中必须唯一。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\ntypedef int my_name; // unique typedef declared\n\nint main()\n{\n    int my_name_2 = 1; // unique variable declared \n    printf(\"%d\",my_name_2);\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\ntypedef int my_name; // typedef declared\n\nint main()\n{\n    int my_name = 1; // variable declared, same identifier\n    printf(\"%d\",my_name);\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629164078739"
	},
	{
		"name": "Tag names should be a unique identifier",
		"code": "MSR_5_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "5.7",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, tag names are not unique identifiers.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，标签名称不是唯一标识符。",
			"code": "MSR_5_7",
			"override": "T",
			"master_id": "2008",
			"name": "Tag names should be a unique identifier",
			"name_cn": "标签名称应是唯一标识符",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A tag must be unique",
			"desc_cn": "结构体标签必须唯一",
			"abstract": "A tag must be unique",
			"explanation": "Unless the tag is defined in the header file, and the header file is included, the tag used must be unique in all namespaces.",
			"abstract_cn": "结构体标签必须唯一",
			"explanation_cn": "除非该结构体标签在头文件中被定义且该头文件被包含，否则所用标签在所有命名空间中必须唯一。",
			"example_good": "///c:\n#include <stdio.h>\n\nstruct my_name // unique tag declared\n{\n    int a;\n    int b;\n};\n\nint main()\n{\n    int my_name_2 = 1; // unique variable declared\n    printf(\"%d\",my_name_2);\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nstruct my_name // tag declared\n{\n    int a;\n    int b;\n};\n\nint main()\n{\n    int my_name = 1; // variable declared, same identifier\n    printf(\"%d\",my_name);\n    return 0;\n}",
			"details_en": "#### Abstract\nA tag must be unique\n\n#### Explanation\nUnless the tag is defined in the header file, and the header file is included, the tag used must be unique in all namespaces.",
			"details_cn": "#### 概要\n结构体标签必须唯一\n\n#### 解释\n除非该结构体标签在头文件中被定义且该头文件被包含，否则所用标签在所有命名空间中必须唯一。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstruct my_name // unique tag declared\n{\n    int a;\n    int b;\n};\n\nint main()\n{\n    int my_name_2 = 1; // unique variable declared\n    printf(\"%d\",my_name_2);\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstruct my_name // tag declared\n{\n    int a;\n    int b;\n};\n\nint main()\n{\n    int my_name = 1; // variable declared, same identifier\n    printf(\"%d\",my_name);\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629164146207"
	},
	{
		"name": "Bit field types must not be builtin types",
		"code": "MSR_6_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, bit fields are not appropriate data types.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，位域未被声明为合适的数据类型。",
			"code": "MSR_6_1",
			"override": "T",
			"master_id": "2009",
			"name": "Bit field types must not be builtin types",
			"name_cn": "位域类型不能是内置类型",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Bit fields must be declared as appropriate data types",
			"desc_cn": "位域必须被声明为合适的数据类型",
			"abstract": "Bit fields must be declared as appropriate data types",
			"explanation": "When declaring a bit field, it must be declared as one of the specified data types either signed or unsigned. It cannot be omitted in the declaration.",
			"abstract_cn": "位域必须被声明为合适的数据类型",
			"explanation_cn": "在声明位域时，必须将其声明为规定的几种数据类型中的一种且在声明中signed与unsigned不可省略。",
			"example_good": "///c:\n#include <stdio.h>\n\nstruct str\n{\n    signed int a:2;   // signed int permitted\n    unsigned int b:2; // unsigned int permitted\n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}",
			"example_bad": "///c:\nstruct str {\n  int a:2;\n  unsigned int b1:2;\n};\n\n\nstruct str1 {\n  unsigned int b1:2;\n  short b:2;\n};\n\nint foo()\n{\n  printf(\"finished\\n\");\n  return 0;\n}",
			"details_en": "#### Abstract\nBit fields must be declared as appropriate data types\n\n#### Explanation\nWhen declaring a bit field, it must be declared as one of the specified data types either signed or unsigned. It cannot be omitted in the declaration.",
			"details_cn": "#### 概要\n位域必须被声明为合适的数据类型\n\n#### 解释\n在声明位域时，必须将其声明为规定的几种数据类型中的一种且在声明中signed与unsigned不可省略。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstruct str\n{\n    signed int a:2;   // signed int permitted\n    unsigned int b:2; // unsigned int permitted\n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nstruct str {\n  int a:2;\n  unsigned int b1:2;\n};\n\n\nstruct str1 {\n  unsigned int b1:2;\n  short b:2;\n};\n\nint foo()\n{\n  printf(\"finished\\n\");\n  return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629164209713"
	},
	{
		"name": "Single-bit named field must be unsigned",
		"code": "MSR_6_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the single-bit named field is signed data.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现有符号的单位命名字段。",
			"code": "MSR_6_2",
			"override": "T",
			"master_id": "2010",
			"name": "Single-bit named field must be unsigned",
			"name_cn": "单位命名字段必须是无符号的",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A bit field that only occupies one bit cannot be signed data",
			"desc_cn": "只占一个位的位域不能为有符号型数据",
			"abstract": "A bit field that only occupies one bit cannot be signed data",
			"explanation": "Since signed data requires the first sign bit, a bit field that only occupies one bit is not allowed to be defined as a signed data type.",
			"abstract_cn": "只占一个位的位域不能为有符号型数据",
			"explanation_cn": "由于有符号型数据要求有第一位符号位，只占一个位的位域的位域不允许定义为有符号型的数据类型。",
			"example_good": "///c:\n#include <stdio.h>\n\nstruct str\n{\n    unsigned int a:1;   // single-bit bit field declared unsigned\n};\n\nint main()\n{\n    printf (\"finished\") ;\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nstruct str\n{\n    signed int a:1;   // single-bit bit field declared signed\n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}",
			"details_en": "#### Abstract\nA bit field that only occupies one bit cannot be signed data\n\n#### Explanation\nSince signed data requires the first sign bit, a bit field that only occupies one bit is not allowed to be defined as a signed data type.",
			"details_cn": "#### 概要\n只占一个位的位域不能为有符号型数据\n\n#### 解释\n由于有符号型数据要求有第一位符号位，只占一个位的位域的位域不允许定义为有符号型的数据类型。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstruct str\n{\n    unsigned int a:1;   // single-bit bit field declared unsigned\n};\n\nint main()\n{\n    printf (\"finished\") ;\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstruct str\n{\n    signed int a:1;   // single-bit bit field declared signed\n};\n\nint main()\n{\n    printf(\"finished\");\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629164302024"
	},
	{
		"name": "String literal must only be assigned to a const char pointer",
		"code": "MSR_7_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a string literal is not assigned to char type.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的字符串文字未分配给常量指针。",
			"code": "MSR_7_4",
			"override": "T",
			"master_id": "2011",
			"name": "String literal must only be assigned to a const char pointer",
			"name_cn": "字符串文字只能分配给常量指针",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Always assign a string literal through a const qualified pointer to char type",
			"desc_cn": "将字符串字面量通过指向常量的指针赋值给字符型",
			"abstract": "Always assign a string literal through a const qualified pointer to char type",
			"explanation": "Since the constant string is stored in the static storage area, the modification operation will cause an error. Only the constant string can be copied to the pointer to the constant string to prevent its modification operation.",
			"abstract_cn": "将字符串字面量通过指向常量的指针赋值给字符型",
			"explanation_cn": "由于常量字符串存储在静态存储区，对其的修改操作会出错，仅能将常量字符串复制给指向常量字符串的指针以防止其修改操作。",
			"example_good": "///c:\n#include <stdio.h>\n\nextern int foo (const char *a);\nextern int foo2 (const char *b);\n\nint func()\n{\n    const char *str = \"string\"; // str is not const-qualified\n    foo ( \"string\" );\n    foo2 ( \"string\" ); // string can not be modified\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nextern int foo (char *a);\nextern int foo2 (char *b);\n\nint func()\n{\n    char *str = \"string\"; // str is not const-qualified\n    foo ( \"string\" );\n    foo2 ( \"string\" ); // may be modified by foo\n    return 0;\n}",
			"details_en": "#### Abstract\nAlways assign a string literal through a const qualified pointer to char type\n\n#### Explanation\nSince the constant string is stored in the static storage area, the modification operation will cause an error. Only the constant string can be copied to the pointer to the constant string to prevent its modification operation.",
			"details_cn": "#### 概要\n将字符串字面量通过指向常量的指针赋值给字符型\n\n#### 解释\n由于常量字符串存储在静态存储区，对其的修改操作会出错，仅能将常量字符串复制给指向常量字符串的指针以防止其修改操作。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int foo (const char *a);\nextern int foo2 (const char *b);\n\nint func()\n{\n    const char *str = \"string\"; // str is not const-qualified\n    foo ( \"string\" );\n    foo2 ( \"string\" ); // string can not be modified\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int foo (char *a);\nextern int foo2 (char *b);\n\nint func()\n{\n    char *str = \"string\"; // str is not const-qualified\n    foo ( \"string\" );\n    foo2 ( \"string\" ); // may be modified by foo\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629164990574"
	},
	{
		"name": "Definition of objects with external linkage should be compatible with their declarations",
		"code": "MSR_8_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the external object is not compatible with its declaration.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的外部对象与其声明不兼容。",
			"code": "MSR_8_4",
			"override": "T",
			"master_id": "2012",
			"name": "Definition of objects with external linkage should be compatible with their declarations",
			"name_cn": "具有外部链接的对象的定义应与其声明兼容",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Definition of objects with external linkage should be compatible with their declarations",
			"desc_cn": "具有外部链接的对象的定义应与其声明兼容",
			"abstract": "Definition of objects with external linkage should be compatible with their declarations",
			"explanation": "When defining an object or function with external linkage, the data type, number of parameters, etc. of the object or function must be compatible with the external declaration.",
			"abstract_cn": "具有外部链接的对象的定义应与其声明兼容",
			"explanation_cn": "在定义具有外部链接的对象或者函数时，必须保持该对象或者函数的数据类型，参数数量等与外部的声明兼容。",
			"example_good": "///c:\n#include <stdio.h>\n\nextern int x;\nint x = 0; // compliant\n\nextern int func1(int a); // extern function declared\n\nint func1(int a) // extern compatible funtion defined\n{\n    return 0;\n}\n\n// compliant for functions with internal linkage\nstatic int func2 ( void )\n{\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n#include <stdint.h>\n\nextern int16_t x = 0; // x not declared before\n\nextern void func1( int16_t a, int16_t b); // extern function declared\n\nvoid func1( int16_t a, uint16_t b )\n{\n    // parameters different\n    // This example would raise compile error\n}\n\nvoid func2( void )\n{\n    // func2 not declared before\n}",
			"details_en": "#### Abstract\nDefinition of objects with external linkage should be compatible with their declarations\n\n#### Explanation\nWhen defining an object or function with external linkage, the data type, number of parameters, etc. of the object or function must be compatible with the external declaration.",
			"details_cn": "#### 概要\n具有外部链接的对象的定义应与其声明兼容\n\n#### 解释\n在定义具有外部链接的对象或者函数时，必须保持该对象或者函数的数据类型，参数数量等与外部的声明兼容。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int x;\nint x = 0; // compliant\n\nextern int func1(int a); // extern function declared\n\nint func1(int a) // extern compatible funtion defined\n{\n    return 0;\n}\n\n// compliant for functions with internal linkage\nstatic int func2 ( void )\n{\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdint.h>\n\nextern int16_t x = 0; // x not declared before\n\nextern void func1( int16_t a, int16_t b); // extern function declared\n\nvoid func1( int16_t a, uint16_t b )\n{\n    // parameters different\n    // This example would raise compile error\n}\n\nvoid func2( void )\n{\n    // func2 not declared before\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629165398928"
	},
	{
		"name": "Objects with internal linkage should be declared static ",
		"code": "MSR_8_8",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M3-3-2",
			"misra_c": "8.8",
			"misra_cpp": "3-3-2",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the object with internal linkage is not declared static.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，具有内部链接的对象未被声明为静态。",
			"code": "MSR_8_8",
			"override": "T",
			"master_id": "2013",
			"name": "Objects with internal linkage should be declared static ",
			"name_cn": "具有内部链接的对象应声明为静态",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The static specifier should be added to the object that has internal linkage",
			"desc_cn": "有内部链接的对象要加上static说明符",
			"abstract": "The static specifier should be added to the object that has internal linkage",
			"explanation": "When declaring an object or function with internal linkage, a static specifier must be added to ensure the declaration is correct. ",
			"abstract_cn": "有内部链接的对象要加上static说明符",
			"explanation_cn": "在声明具有内部链接的对象或者函数时，必须加上static的说明符以保持声明的正确性。",
			"example_good": "///c:\nstatic int func (int a) // function defined with \"static\"\n{\n    return a;\n}",
			"example_bad": "///c:\n// this example will cause compilation error\nextern int func (int a); // declare external scope\n\nstatic int func (int a) // function with internal linkage declared\n{\n    return a;\n}",
			"details_en": "#### Abstract\nThe static specifier should be added to the object that has internal linkage\n\n#### Explanation\nWhen declaring an object or function with internal linkage, a static specifier must be added to ensure the declaration is correct. ",
			"details_cn": "#### 概要\n有内部链接的对象要加上static说明符\n\n#### 解释\n在声明具有内部链接的对象或者函数时，必须加上static的说明符以保持声明的正确性。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nstatic int func (int a) // function defined with \"static\"\n{\n    return a;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n// this example will cause compilation error\nextern int func (int a); // declare external scope\n\nstatic int func (int a) // function with internal linkage declared\n{\n    return a;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629169804829"
	},
	{
		"name": "For local identifiers, defined them at block scope",
		"code": "MSR_8_9",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M3-4-1",
			"misra_c": "8.9",
			"misra_cpp": "3-4-1",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, local identifiers are not defined at block scope",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的本地标识符未在块范围内定义",
			"code": "MSR_8_9",
			"override": "T",
			"master_id": "2014",
			"name": "For local identifiers, defined them at block scope",
			"name_cn": "对于本地标识符，在块范围内定义它们",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "For local identifiers, defined them at block scope",
			"desc_cn": "对于本地标识符，在块范围内定义它们",
			"abstract": "For local identifiers, defined them at block scope",
			"explanation": "When the identifier of an object only appear in a single function,  it should be defined at block scope to prevent it from being accessed elsewhere",
			"abstract_cn": "对于本地标识符，在块范围内定义它们",
			"explanation_cn": "当对象的标识符只出现在单个函数中时，应该在块范围内定义它，以防止它在其他地方被访问",
			"example_good": "///c:\n#include <stdio.h>\n\nextern int foo (int *a);\nextern void foo2 ( void );\n\nint count ( void )\n{\n    static int num = 0; // object declared at block scope\n    num++; // object appears only in this function\n    return num;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nextern int foo(int *a);\nextern void foo2( void );\nstatic int num = 0; // object declared, global scope\n\nint count( void )\n{\n    num++; // object appears only in this function\n    return num;\n}\n\nextern void foo2( void )\n{\n    foo(&num); // object may be modified at outer scope\n}",
			"details_en": "#### Abstract\nFor local identifiers, defined them at block scope\n\n#### Explanation\nWhen the identifier of an object only appear in a single function,  it should be defined at block scope to prevent it from being accessed elsewhere",
			"details_cn": "#### 概要\n对于本地标识符，在块范围内定义它们\n\n#### 解释\n当对象的标识符只出现在单个函数中时，应该在块范围内定义它，以防止它在其他地方被访问",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int foo (int *a);\nextern void foo2 ( void );\n\nint count ( void )\n{\n    static int num = 0; // object declared at block scope\n    num++; // object appears only in this function\n    return num;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int foo(int *a);\nextern void foo2( void );\nstatic int num = 0; // object declared, global scope\n\nint count( void )\n{\n    num++; // object appears only in this function\n    return num;\n}\n\nextern void foo2( void )\n{\n    foo(&num); // object may be modified at outer scope\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629169875168"
	},
	{
		"name": "Inline function should have a static declaration",
		"code": "MSR_8_10",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, inline function ${so.func} does not have static declaration.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的内联函数没有静态声明 。",
			"code": "MSR_8_10",
			"override": "T",
			"master_id": "2015",
			"name": "Inline function should have a static declaration",
			"name_cn": "内联函数应具有静态声明 ",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A static storage class should be used to declare inline functions",
			"desc_cn": "应该用静态存储类声明内联函数",
			"abstract": "A static storage class should be used to declare inline functions",
			"explanation": "Referencing an inline function of an external linkage may affect the execution time, so the inline function should be declared with a static storage class.",
			"abstract_cn": "应该用静态存储类声明内联函数",
			"explanation_cn": "引用外部链接的内联函数可能会影响执行的时间，因此应该用静态储存类声明内联函数。",
			"example_good": "///c:\n#include <stdio.h>\n\nstatic inline int func( void ); // inline function declared with internal linkage\n\nint func2( void )\n{\n    func();\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nextern inline int func( void ); // inline function declared with external linkage\n\nint func2( void )\n{\n    func();\n}",
			"details_en": "#### Abstract\nA static storage class should be used to declare inline functions\n\n#### Explanation\nReferencing an inline function of an external linkage may affect the execution time, so the inline function should be declared with a static storage class.",
			"details_cn": "#### 概要\n应该用静态存储类声明内联函数\n\n#### 解释\n引用外部链接的内联函数可能会影响执行的时间，因此应该用静态储存类声明内联函数。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstatic inline int func( void ); // inline function declared with internal linkage\n\nint func2( void )\n{\n    func();\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern inline int func( void ); // inline function declared with external linkage\n\nint func2( void )\n{\n    func();\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629169937109"
	},
	{
		"name": "When an array with external linkage is declared, its size should be explicitly specified",
		"code": "MSR_8_11",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M3-1-4",
			"misra_c": "8.11",
			"misra_cpp": "3-1-3",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the size of the array of external linkage is not explicitly specified.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中未明确外部链接的数组的大小。",
			"code": "MSR_8_11",
			"override": "T",
			"master_id": "2016",
			"name": "When an array with external linkage is declared, its size should be explicitly specified",
			"name_cn": "声明带有外部链接的数组时，应明确指定其大小",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The size of the array of external linkage must be explicitly specified",
			"desc_cn": "需要明确外部链接的数组的大小",
			"abstract": "The size of the array of external linkage must be explicitly specified",
			"explanation": "In order to ensure consistency and determine the boundaries of the storage area, the size of the array must be determined when declaring an externally linked array.",
			"abstract_cn": "需要明确外部链接的数组的大小",
			"explanation_cn": "为了保证一致性以及确定存储区的边界，在声明外部链接的数组时必须确定该数组的大小。",
			"example_good": "///c:\n#include <stdio.h>\n\nextern int array[20]; // declare array with external linkage and its size\n\nint foo ( void )\n{\n    return array[10];\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nextern int array[]; // declare array with external linkage but without size\n\nint foo ( void )\n{\n    return array[10]; // 10 may be bigger than actual array size\n}",
			"details_en": "#### Abstract\nThe size of the array of external linkage must be explicitly specified\n\n#### Explanation\nIn order to ensure consistency and determine the boundaries of the storage area, the size of the array must be determined when declaring an externally linked array.",
			"details_cn": "#### 概要\n需要明确外部链接的数组的大小\n\n#### 解释\n为了保证一致性以及确定存储区的边界，在声明外部链接的数组时必须确定该数组的大小。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int array[20]; // declare array with external linkage and its size\n\nint foo ( void )\n{\n    return array[10];\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nextern int array[]; // declare array with external linkage but without size\n\nint foo ( void )\n{\n    return array[10]; // 10 may be bigger than actual array size\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629170079841"
	},
	{
		"name": "An implicitly specified enum constant list should be unique",
		"code": "MSR_8_12",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the implicitly specified enum constant list is not unique.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的隐式指定的枚举常量列表不唯一。",
			"code": "MSR_8_12",
			"override": "T",
			"master_id": "2017",
			"name": "An implicitly specified enum constant list should be unique",
			"name_cn": "隐式指定的枚举常量列表应是唯一的",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The value of the enumeration member assigned by default must be unique",
			"desc_cn": "默认赋值的枚举成员的值唯一",
			"abstract": "The value of the enumeration member assigned by default must be unique",
			"explanation": "In order to avoid the incorrect repetition of the value of the enumeration member, the value of the enumeration member should be ",
			"abstract_cn": "默认赋值的枚举成员的值唯一",
			"explanation_cn": "为了避免枚举成员的值错误地重复，应该保证通过枚举值列表顺序默认赋值地枚举成员的值唯一。",
			"example_good": "///c:\n#include <stdio.h>\n\n// all implicitly-specified enmueration constants is unique\ntypedef enum weekday {thu = 4, fri, sat = 6, sun = 6};",
			"example_bad": "///c:\n#include <stdio.h>\n\n// implicitly-specified enmueration sat is not unique\ntypedef enum weekday {thu = 4, fri, sat, sun = 6};",
			"details_en": "#### Abstract\nThe value of the enumeration member assigned by default must be unique\n\n#### Explanation\nIn order to avoid the incorrect repetition of the value of the enumeration member, the value of the enumeration member should be ",
			"details_cn": "#### 概要\n默认赋值的枚举成员的值唯一\n\n#### 解释\n为了避免枚举成员的值错误地重复，应该保证通过枚举值列表顺序默认赋值地枚举成员的值唯一。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// all implicitly-specified enmueration constants is unique\ntypedef enum weekday {thu = 4, fri, sat = 6, sun = 6};"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// implicitly-specified enmueration sat is not unique\ntypedef enum weekday {thu = 4, fri, sat, sun = 6};"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629170158219"
	},
	{
		"name": "A pointer should point to a const-qualified type whenever possible",
		"code": "MSR_8_13",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the pointer is not declared with const qualifier.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中指针声明不是常量。",
			"code": "MSR_8_13",
			"override": "T",
			"master_id": "2018",
			"name": "A pointer should point to a const-qualified type whenever possible",
			"name_cn": "指针应尽可能指向 const 限定的类型",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Try to declare pointers with const qualifier",
			"desc_cn": "建议将指针声明限定为常量",
			"abstract": "Try to declare pointers with const qualifier",
			"explanation": "A pointer should always point to the same underlying qualified type. Mixed type assignments should be always explicitly casted.",
			"abstract_cn": "建议将指针声明限定为常量",
			"explanation_cn": "指针应指向相同限定的类型。指针若是指向的限定类型不同，应进行显式转换。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func (const char *ptr);\n\nvoid func (const char *ptr) // pointer declared const-qualified\n{\n    // ptr pointed to is not modified\n    printf (\"%c\", *ptr);\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func (char *ptr);\n\nvoid func (char *ptr) // pointer declared is not const-qualified\n{\n    // ptr pointed to is not modified, it should be const-qualified\n    printf (\"%c\", *ptr);\n}",
			"details_en": "#### Abstract\nTry to declare pointers with const qualifier\n\n#### Explanation\nA pointer should always point to the same underlying qualified type. Mixed type assignments should be always explicitly casted.",
			"details_cn": "#### 概要\n建议将指针声明限定为常量\n\n#### 解释\n指针应指向相同限定的类型。指针若是指向的限定类型不同，应进行显式转换。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func (const char *ptr);\n\nvoid func (const char *ptr) // pointer declared const-qualified\n{\n    // ptr pointed to is not modified\n    printf (\"%c\", *ptr);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func (char *ptr);\n\nvoid func (char *ptr) // pointer declared is not const-qualified\n{\n    // ptr pointed to is not modified, it should be const-qualified\n    printf (\"%c\", *ptr);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629170214347"
	},
	{
		"name": "Restrict qualifier should not be used",
		"code": "MSR_8_14",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the restrict type qualifier is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了restrict关键字",
			"code": "MSR_8_14",
			"override": "T",
			"master_id": "2019",
			"name": "Restrict qualifier should not be used",
			"name_cn": "不能使用限制限定符",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Try to avoid using the restrict type qualifier",
			"desc_cn": "尽量避免使用restrict关键字",
			"abstract": "Try to avoid using the restrict type qualifier",
			"explanation": "In order to prevent problems such as overlapping of the areas pointed to by the pointer, the restrict type qualifier should be avoided as much as possible.",
			"abstract_cn": "尽量避免使用restrict关键字",
			"explanation_cn": "为防止指针指向的区域重合等问题，应该尽量避免使用restrict关键字。",
			"example_good": "///c:\n#include <stdio.h>\n\n// restrict type qualifier removed\nextern void func (int * ptr1, int * ptr2);\n\nvoid func2(void)\n{\n    int i;\n    int *a,*b;\n    a = b = &i;\n    func (a, b);\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\n// restrict-qualified parameters declared\nextern void func (int * restrict ptr1, int * restrict ptr2);\n\nvoid func2(void)\n{\n    int i;\n    int *a,*b;\n    a = b = &i;\n    // overlap memory areas\n    func (a, b);\n}",
			"details_en": "#### Abstract\nTry to avoid using the restrict type qualifier\n\n#### Explanation\nIn order to prevent problems such as overlapping of the areas pointed to by the pointer, the restrict type qualifier should be avoided as much as possible.",
			"details_cn": "#### 概要\n尽量避免使用restrict关键字\n\n#### 解释\n为防止指针指向的区域重合等问题，应该尽量避免使用restrict关键字。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// restrict type qualifier removed\nextern void func (int * ptr1, int * ptr2);\n\nvoid func2(void)\n{\n    int i;\n    int *a,*b;\n    a = b = &i;\n    func (a, b);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// restrict-qualified parameters declared\nextern void func (int * restrict ptr1, int * restrict ptr2);\n\nvoid func2(void)\n{\n    int i;\n    int *a,*b;\n    a = b = &i;\n    // overlap memory areas\n    func (a, b);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629173998655"
	},
	{
		"name": "Arrays should not be partially initialized",
		"code": "MSR_9_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, arrays are partially initialized",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的数组只被部分初始化",
			"code": "MSR_9_3",
			"override": "T",
			"master_id": "2020",
			"name": "Arrays should not be partially initialized",
			"name_cn": "数组不应该部分初始化",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Arrays must not be partially initialized",
			"desc_cn": "不能只初始化数组的一部分",
			"abstract": "Arrays must not be partially initialized",
			"explanation": "In order to ensure that there are no unprocessed values in the array after explicitly initializing the array, all elements in the array must also be explicitly initialized.",
			"abstract_cn": "不能只初始化数组的一部分",
			"explanation_cn": "为了保证在显式初始化数组后数组中不再存在未经过处理的值，在对数组进行显式初始化时也必须对数组内所有的元素进行显式初始化操作。",
			"example_good": "///c:\n#include <stdio.h>\n\nint func ( void )\n{\n    int a[10] = {0}; // array totally initialized\n    return a[9];\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint func ( void )\n{\n    int a[10] = {0, 0, 0}; // array only initialized three elements\n    return a[9]; // a[9] is still unknown value\n}",
			"details_en": "#### Abstract\nArrays must not be partially initialized\n\n#### Explanation\nIn order to ensure that there are no unprocessed values in the array after explicitly initializing the array, all elements in the array must also be explicitly initialized.",
			"details_cn": "#### 概要\n不能只初始化数组的一部分\n\n#### 解释\n为了保证在显式初始化数组后数组中不再存在未经过处理的值，在对数组进行显式初始化时也必须对数组内所有的元素进行显式初始化操作。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func ( void )\n{\n    int a[10] = {0}; // array totally initialized\n    return a[9];\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func ( void )\n{\n    int a[10] = {0, 0, 0}; // array only initialized three elements\n    return a[9]; // a[9] is still unknown value\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174050627"
	},
	{
		"name": "Multiple initialization of elements in an object is not allowed",
		"code": "MSR_9_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the elements in the object have been initialized more than once",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，对象中的元素被初始化多于一次",
			"code": "MSR_9_4",
			"override": "T",
			"master_id": "2021",
			"name": "Multiple initialization of elements in an object is not allowed",
			"name_cn": "不允许对对象中的元素进行多次初始化",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The elements in the object can only be initialized once",
			"desc_cn": "对象中的元素只能初始化一次",
			"abstract": "The elements in the object can only be initialized once",
			"explanation": "When initializing arrays and structures that are not in the default order, you must not initialize the same element(s) repeatedly.",
			"abstract_cn": "对象中的元素只能初始化一次",
			"explanation_cn": "在进行不按默认顺序的数组和结构体的初始化的时，必须注意不能对同一元素进行重复的初始化。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func( void )\n{\n    // all elements initialized once\n    int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1};\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func( void )\n{\n    // a[0] initialized twice\n    int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1, [ 0 ] = 4};\n}",
			"details_en": "#### Abstract\nThe elements in the object can only be initialized once\n\n#### Explanation\nWhen initializing arrays and structures that are not in the default order, you must not initialize the same element(s) repeatedly.",
			"details_cn": "#### 概要\n对象中的元素只能初始化一次\n\n#### 解释\n在进行不按默认顺序的数组和结构体的初始化的时，必须注意不能对同一元素进行重复的初始化。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func( void )\n{\n    // all elements initialized once\n    int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1};\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func( void )\n{\n    // a[0] initialized twice\n    int arr[3] = { [ 0 ] = 3, [ 1 ] = 2, [ 2 ] = 1, [ 0 ] = 4};\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174105777"
	},
	{
		"name": "If initializers are used in an array, its size must be known",
		"code": "MSR_9_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the size of the array that uses explicit initializer is not declared",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用显式初始化的数组未声明其大小",
			"code": "MSR_9_5",
			"override": "T",
			"master_id": "2022",
			"name": "If initializers are used in an array, its size must be known",
			"name_cn": "如果在数组中使用初始值设定项，则必须知道其大小",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The size of the array must be declared if an explicit initializer is used on the array",
			"desc_cn": "使用显式初始化的数组必须声明其大小",
			"abstract": "The size of the array must be declared if an explicit initializer is used on the array",
			"explanation": "In order to determine the maximum number of elements in the array, when this array is explicitly initialized, the array size must be specified.",
			"abstract_cn": "使用显式初始化的数组必须声明其大小",
			"explanation_cn": "为确定数组的最大的元素数量，使用显式初始化方法进行初始化的数组的大小必须是确定的。",
			"example_good": "///c:\n// This is example from MISRA document\n// Compliant\nint a2[ 10 ] = { [ 0 ] = 1 };",
			"example_bad": "///c:\n// This is example from MISRA document\n// Non-compliant - probably unint entional to have single element\nint a1[ ] = { [ 0 ] = 1 };",
			"details_en": "#### Abstract\nThe size of the array must be declared if an explicit initializer is used on the array\n\n#### Explanation\nIn order to determine the maximum number of elements in the array, when this array is explicitly initialized, the array size must be specified.",
			"details_cn": "#### 概要\n使用显式初始化的数组必须声明其大小\n\n#### 解释\n为确定数组的最大的元素数量，使用显式初始化方法进行初始化的数组的大小必须是确定的。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n// This is example from MISRA document\n// Compliant\nint a2[ 10 ] = { [ 0 ] = 1 };"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n// This is example from MISRA document\n// Non-compliant - probably unint entional to have single element\nint a1[ ] = { [ 0 ] = 1 };"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174191770"
	},
	{
		"name": "Down casting of an expression is not allowed",
		"code": "MSR_10_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-0-6",
			"misra_c": "10.3",
			"misra_cpp": "5-0-6",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} includes down casting of an expression",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现向下转换表达式",
			"code": "MSR_10_3",
			"override": "T",
			"master_id": "2023",
			"name": "Down casting of an expression is not allowed",
			"name_cn": "不允许向下转换表达式",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "You cannot assign values to objects with different essential types",
			"desc_cn": "不能为不同类型的对象赋值",
			"abstract": "You cannot assign values to objects with different essential types",
			"explanation": "It is erroneous to assign the value of an expression to an object with an inappropriate type or is not large enough to represent the data type of the value.",
			"abstract_cn": "不能为不同类型的对象赋值",
			"explanation_cn": "把表达式的值赋值给不恰当类型的或者大小不足以表示该值的数据类型的对象，都是错误的做法。",
			"example_good": "///c:\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid func ( void )\n{\n    short short_a;\n    int b;              // b declared as int for illustration\n    b = short_a;        // short_a assigned to wider essential type object\n    uint16_t c = 0;   // compliant by exception\n    bool d = false;     // compliant\n    uint16_t e = 5;   // compliant by exception\n    char f = \"f_char\";  // char to char\n}",
			"example_bad": "///c:\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid func ( void )\n{\n    short short_a;\n    long int b;\n    short_a = b;            // b assigned to narrower essential type\n    uint16_t c = 0.5f;    // float to unsigned\n    bool d = 1;             // signed to boolean\n    char e = 3;             // signed to char\n    uint32_t f = 'test';  // char to unsigned\n    uint16_t g = 5;       // signed to unsigned\n}",
			"details_en": "#### Abstract\nYou cannot assign values to objects with different essential types\n\n#### Explanation\nIt is erroneous to assign the value of an expression to an object with an inappropriate type or is not large enough to represent the data type of the value.",
			"details_cn": "#### 概要\n不能为不同类型的对象赋值\n\n#### 解释\n把表达式的值赋值给不恰当类型的或者大小不足以表示该值的数据类型的对象，都是错误的做法。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid func ( void )\n{\n    short short_a;\n    int b;              // b declared as int for illustration\n    b = short_a;        // short_a assigned to wider essential type object\n    uint16_t c = 0;   // compliant by exception\n    bool d = false;     // compliant\n    uint16_t e = 5;   // compliant by exception\n    char f = \"f_char\";  // char to char\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid func ( void )\n{\n    short short_a;\n    long int b;\n    short_a = b;            // b assigned to narrower essential type\n    uint16_t c = 0.5f;    // float to unsigned\n    bool d = 1;             // signed to boolean\n    char e = 3;             // signed to char\n    uint32_t f = 'test';  // char to unsigned\n    uint16_t g = 5;       // signed to unsigned\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174388735"
	},
	{
		"name": "operands and type conversion",
		"code": "MSR_10_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-0-4",
			"misra_c": "10.4",
			"misra_cpp": "5-0-4",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the two operands of the same operator are not of the same essential type category",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中同一操作符的两个操作数不是同一类型",
			"code": "MSR_10_4",
			"override": "T",
			"master_id": "2024",
			"name": "operands and type conversion",
			"name_cn": "操作数和类型转换",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The two operands of the same operator must be of the same essential type category",
			"desc_cn": "同一操作符的两个操作数为同一类型",
			"abstract": "The two operands of the same operator must be of the same essential type category",
			"explanation": "Using binary or ternary operands for two different types of operands may cause some information of the resulting value to be lost. Therefore, in general, the two operands of the uniform operator should be of the same type.",
			"abstract_cn": "同一操作符的两个操作数为同一类型",
			"explanation_cn": "用二元或者三元操作数对两个不同的类型的操作数可能会使所得的值的部分信息丢失。因此在一般情况下，统一操作符的两操作数应该为同一类型。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int int_var;\n    char char_var;\n    // int 1 added to char char_var, permitted\n    char_var += 1;\n    // int 1 added to int int_var, same type\n    int_var += 1;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int int_var;\n    char char_var;\n    // float 1.0f added to char char_var, not permitted\n    char_var += 1.0f;\n    // float 1.0f added to int int_var, differnt type\n    int_var += 1.0f;\n}",
			"details_en": "#### Abstract\nThe two operands of the same operator must be of the same essential type category\n\n#### Explanation\nUsing binary or ternary operands for two different types of operands may cause some information of the resulting value to be lost. Therefore, in general, the two operands of the uniform operator should be of the same type.",
			"details_cn": "#### 概要\n同一操作符的两个操作数为同一类型\n\n#### 解释\n用二元或者三元操作数对两个不同的类型的操作数可能会使所得的值的部分信息丢失。因此在一般情况下，统一操作符的两操作数应该为同一类型。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int int_var;\n    char char_var;\n    // int 1 added to char char_var, permitted\n    char_var += 1;\n    // int 1 added to int int_var, same type\n    int_var += 1;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int int_var;\n    char char_var;\n    // float 1.0f added to char char_var, not permitted\n    char_var += 1.0f;\n    // float 1.0f added to int int_var, differnt type\n    int_var += 1.0f;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174488685"
	},
	{
		"name": "Do not cast the value of an expression to an inappropriate essential type",
		"code": "A5_0_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "10.5 ",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the value of the expression is cast to an inappropriate essential type",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中表达式的值被转换为不适当的类型",
			"code": "A5_0_3",
			"override": "T",
			"master_id": "2025",
			"name": "Do not cast the value of an expression to an inappropriate essential type",
			"name_cn": "不要将表达式的值转换为不适当的基本类型",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Do not cast the value of an expression to an inappropriate essential type",
			"desc_cn": "不要将表达式的值转换为不适当的基本类型",
			"abstract": "Do not cast the value of an expression to an inappropriate essential type",
			"explanation": "Casting between two inappropriate types may result in the loss or change of data, so the value of the expression cannot be cast to an inappropriate type.",
			"abstract_cn": "不要将表达式的值转换为不适当的基本类型",
			"explanation_cn": "在两种不适当的类型之间进行强制类型转换可能会导致数据的丢失或者改变，因此表达式的值不能不能被强制转换为不适当的类型。",
			"example_good": "///cpp:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_var;\n    bool bool_var;\n    // int can be cast to char\n    char_var = ( char ) 1;\n    // int 1 can be cast to bool by exception\n    bool_var = ( bool ) 1;\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n \nvoid func ( void );\n \nbool bool_var;\nchar char_var;\nenum enum_var {} enum_var;\nsigned signed_var;\nunsigned unsigned_var;\nfloat float_var;\n \nvoid func ( void )\n{\n  // expression 1.0f cast to an narrower type char\n  char_var = ( char ) 1.0f;\n  // char_var cast to narrower type bool\n  bool_var = ( bool ) char_var;\n  char_var = ( char ) bool_var; // non-compliant\n  enum_var = ( enum enum_var ) bool_var; // non-compliant\n  signed_var = ( signed ) bool_var; // non-compliant\n  unsigned_var = ( unsigned ) bool_var; // non-compliant\n  float_var = ( float ) bool_var; // non-compliant\n  bool_var = ( bool ) char_var; // non-compliant\n  enum_var = ( enum enum_var ) char_var; // non-compliant\n  float_var = ( float ) char_var; // non-compliant\n  bool_var = ( bool ) enum_var; // non-compliant\n  bool_var = ( enum enum_var ) enum_var; // non-compliant\n  bool_var = ( bool ) signed_var; // non-compliant\n  bool_var = ( enum enum_var ) signed_var; // non-compliant\n  bool_var = ( bool ) unsigned_var; // non-compliant\n  bool_var = ( enum enum_var ) unsigned_var; // non-compliant\n  bool_var = ( bool ) float_var; // non-compliant\n  bool_var = ( enum enum_var ) float_var; // non-compliant\n}",
			"details_en": "#### Abstract\nDo not cast the value of an expression to an inappropriate essential type\n\n#### Explanation\nCasting between two inappropriate types may result in the loss or change of data, so the value of the expression cannot be cast to an inappropriate type.",
			"details_cn": "#### 概要\n不要将表达式的值转换为不适当的基本类型\n\n#### 解释\n在两种不适当的类型之间进行强制类型转换可能会导致数据的丢失或者改变，因此表达式的值不能不能被强制转换为不适当的类型。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    char char_var;\n    bool bool_var;\n    // int can be cast to char\n    char_var = ( char ) 1;\n    // int 1 can be cast to bool by exception\n    bool_var = ( bool ) 1;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n \nvoid func ( void );\n \nbool bool_var;\nchar char_var;\nenum enum_var {} enum_var;\nsigned signed_var;\nunsigned unsigned_var;\nfloat float_var;\n \nvoid func ( void )\n{\n  // expression 1.0f cast to an narrower type char\n  char_var = ( char ) 1.0f;\n  // char_var cast to narrower type bool\n  bool_var = ( bool ) char_var;\n  char_var = ( char ) bool_var; // non-compliant\n  enum_var = ( enum enum_var ) bool_var; // non-compliant\n  signed_var = ( signed ) bool_var; // non-compliant\n  unsigned_var = ( unsigned ) bool_var; // non-compliant\n  float_var = ( float ) bool_var; // non-compliant\n  bool_var = ( bool ) char_var; // non-compliant\n  enum_var = ( enum enum_var ) char_var; // non-compliant\n  float_var = ( float ) char_var; // non-compliant\n  bool_var = ( bool ) enum_var; // non-compliant\n  bool_var = ( enum enum_var ) enum_var; // non-compliant\n  bool_var = ( bool ) signed_var; // non-compliant\n  bool_var = ( enum enum_var ) signed_var; // non-compliant\n  bool_var = ( bool ) unsigned_var; // non-compliant\n  bool_var = ( enum enum_var ) unsigned_var; // non-compliant\n  bool_var = ( bool ) float_var; // non-compliant\n  bool_var = ( enum enum_var ) float_var; // non-compliant\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174549246"
	},
	{
		"name": "Assignment from a composite expression should remain the same size ",
		"code": "MSR_10_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-0-8",
			"misra_c": "10.6",
			"misra_cpp": "5-0-8",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the use of composite expressions to assign values to objects of larger data types does not use explicit conversions",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，使用复合表达式为更大的数据类型的对象赋值时未使用显式转换",
			"code": "MSR_10_6",
			"override": "T",
			"master_id": "2026",
			"name": "Assignment from a composite expression should remain the same size ",
			"name_cn": "复合表达式的赋值应保持相同的大小",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The use of composite expressions to assign values to objects of larger data types should use explicit conversions",
			"desc_cn": "使用复合表达式为更大的数据类型的对象赋值应使用显式转换",
			"abstract": "The use of composite expressions to assign values to objects of larger data types should use explicit conversions",
			"explanation": "Explicit conversion must be used when converting the value of a composite expression to a data type with more storage space and assigning it to an object.",
			"abstract_cn": "使用复合表达式为更大的数据类型的对象赋值应使用显式转换",
			"explanation_cn": "将一个复合表达式的值转换为储存空间更大的数据类型并赋值给一个对象时必须要使用显式转换。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    long long_var;\n    short short_a, short_b;\n    short_a = 1;\n    short_b = 1;\n    long_var = ( long )short_a + short_b; // explicitly converted to long\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    long int long_var;\n    short int short_a, short_b;\n    short_a = short_b = 1;\n    long_var = short_a + short_b; // implicitly converted to long\n}",
			"details_en": "#### Abstract\nThe use of composite expressions to assign values to objects of larger data types should use explicit conversions\n\n#### Explanation\nExplicit conversion must be used when converting the value of a composite expression to a data type with more storage space and assigning it to an object.",
			"details_cn": "#### 概要\n使用复合表达式为更大的数据类型的对象赋值应使用显式转换\n\n#### 解释\n将一个复合表达式的值转换为储存空间更大的数据类型并赋值给一个对象时必须要使用显式转换。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    long long_var;\n    short short_a, short_b;\n    short_a = 1;\n    short_b = 1;\n    long_var = ( long )short_a + short_b; // explicitly converted to long\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    long int long_var;\n    short int short_a, short_b;\n    short_a = short_b = 1;\n    long_var = short_a + short_b; // implicitly converted to long\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174601501"
	},
	{
		"name": "For composite expressions, any up casting on either side is not allowed",
		"code": "MSR_10_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "10.7",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, an explicit conversion is not used when a composite expression is converted to a larger data type as an operand",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，复合表达式作为操作数转化为更大的数据类型时未使用显式转换",
			"code": "MSR_10_7",
			"override": "T",
			"master_id": "2027",
			"name": "For composite expressions, any up casting on either side is not allowed",
			"name_cn": "对于复合表达式，不允许在任一侧进行任何向上转换",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "An explicit conversion is used when a composite expression is converted to a larger data type as an operand",
			"desc_cn": "复合表达式作为操作数转化为更大的数据类型时用显式转换",
			"abstract": "An explicit conversion is used when a composite expression is converted to a larger data type as an operand",
			"explanation": "When a composite expression is used as one of the operands of an operator and needs to be converted to a larger data type, explicit conversion must be used.",
			"abstract_cn": "复合表达式作为操作数转化为更大的数据类型时用显式转换",
			"explanation_cn": "当复合表达式作为操作符的其中一个操作数并且需要转化为更大的数据类型时，必须使用显示转换。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    short int short_a, short_b;\n    long int long_a, long_b;\n    long_a = 1;\n    short_a = short_b = 2;\n    long_b = ( ( long ) short_a * short_b ) * long_a; // explicitly converted to long\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    short int short_a, short_b;\n    long int long_a, long_b;\n    long_a = 1;\n    short_a = short_b = 2;\n    long_b = (short_a * short_b) * long_a; // implicitly converted to long\n}",
			"details_en": "#### Abstract\nAn explicit conversion is used when a composite expression is converted to a larger data type as an operand\n\n#### Explanation\nWhen a composite expression is used as one of the operands of an operator and needs to be converted to a larger data type, explicit conversion must be used.",
			"details_cn": "#### 概要\n复合表达式作为操作数转化为更大的数据类型时用显式转换\n\n#### 解释\n当复合表达式作为操作符的其中一个操作数并且需要转化为更大的数据类型时，必须使用显示转换。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    short int short_a, short_b;\n    long int long_a, long_b;\n    long_a = 1;\n    short_a = short_b = 2;\n    long_b = ( ( long ) short_a * short_b ) * long_a; // explicitly converted to long\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    short int short_a, short_b;\n    long int long_a, long_b;\n    long_a = 1;\n    short_a = short_b = 2;\n    long_b = (short_a * short_b) * long_a; // implicitly converted to long\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174658525"
	},
	{
		"name": "Composite expression cannot be up casted",
		"code": "MSR_10_8",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the value of a composite expression is cast to an inappropriate data type",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，复合表达式的值被转换为不适当的数据类型",
			"code": "MSR_10_8",
			"override": "T",
			"master_id": "2028",
			"name": "Composite expression cannot be up casted",
			"name_cn": "复合表达式不能向上转换",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The value of a composite expression cannot be cast to an inappropriate data type",
			"desc_cn": "复合表达式的值不能被转换为不适当的数据类型",
			"abstract": "The value of a composite expression cannot be cast to an inappropriate data type",
			"explanation": "The data type cast conversion may cause the loss or change of data.",
			"abstract_cn": "复合表达式的值不能被转换为不适当的数据类型",
			"explanation_cn": "在数据类型转换中可能会导致数据的丢失或者改变，因此不能复合表达式的值不能被转换为不适当的数据类型。",
			"example_good": "///c:\n#include <stdio.h>\n#include <stdint.h>\n\nvoid func ( void )\n{\n    float float_a, float_b;\n    int int_var;\n    float_a = float_b = 1.0f;\n    int_var = ( int ) float_a + ( int ) float_b; // float_a and float_b casted to type int\n\n    uint8_t uint_var;\n    uint_var = ( uint8_t ) int_var; // compliant\n}",
			"example_bad": "///c:\n#include <stdio.h>\n#include<stdint.h>\n\nvoid func ( void )\n{\n    float float_a, float_b;\n    int int_var;\n    float_a = float_b = 1.0f;\n    int_var = ( int ) ( float_a + float_b ); // casted to inappropriate type int\n\n    uint8_t uint_var;\n    uint_var = ( uint8_t ) ( float_a + float_b ); // different essential type\n}",
			"details_en": "#### Abstract\nThe value of a composite expression cannot be cast to an inappropriate data type\n\n#### Explanation\nThe data type cast conversion may cause the loss or change of data.",
			"details_cn": "#### 概要\n复合表达式的值不能被转换为不适当的数据类型\n\n#### 解释\n在数据类型转换中可能会导致数据的丢失或者改变，因此不能复合表达式的值不能被转换为不适当的数据类型。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdint.h>\n\nvoid func ( void )\n{\n    float float_a, float_b;\n    int int_var;\n    float_a = float_b = 1.0f;\n    int_var = ( int ) float_a + ( int ) float_b; // float_a and float_b casted to type int\n\n    uint8_t uint_var;\n    uint_var = ( uint8_t ) int_var; // compliant\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include<stdint.h>\n\nvoid func ( void )\n{\n    float float_a, float_b;\n    int int_var;\n    float_a = float_b = 1.0f;\n    int_var = ( int ) ( float_a + float_b ); // casted to inappropriate type int\n\n    uint8_t uint_var;\n    uint_var = ( uint8_t ) ( float_a + float_b ); // different essential type\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174711021"
	},
	{
		"name": "No conversion of pointer to incomplete type convert to any other type",
		"code": "MSR_11_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "A5-2-4",
			"misra_c": "11.2",
			"misra_cpp": "5-2-7",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, pointers to incomplete types are converted to pointers of other types",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，指向不完整类型的指针与其他类型的指针进行了转换",
			"code": "MSR_11_2",
			"override": "T",
			"master_id": "2029",
			"name": "No conversion of pointer to incomplete type convert to any other type",
			"name_cn": "不能将指向不完整类型的指针转换为任何其他类型",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Pointers to incomplete types cannot be converted to pointers of other types and vice versa ",
			"desc_cn": "指向不完整类型的指针与其他类型的指针不能转换，反之亦然",
			"abstract": "Pointers to incomplete types cannot be converted to pointers of other types and vice versa ",
			"explanation": "Type conversion operations between pointers to incomplete types may destroy the encapsulation of incomplete types, so pointers of incomplete types cannot be converted to pointers of other types.",
			"abstract_cn": "指向不完整类型的指针与其他类型的指针不能转换，反之亦然",
			"explanation_cn": "对指向不完整类型的指针进行类型转换操作可能会破坏不完整类型的封装，因此不能对不完整类型的指针转换为其他类型的指针。",
			"example_good": "///c:\n#include <stdio.h>\n\nunion uni\n{\n    int i;\n    char c;\n}; // union declared\n\nvoid func ( void )\n{\n    union uni union_var;\n    union_var.i =1;\n    int *ptr_int;\n    // ptr_int point to union_var.i\n    ptr_int = &union_var.i;\n\n    // exception 1\n    struct a;\n    struct a *p;\n    p = NULL;\n\n    // exception 2\n    struct a *test ( void );\n    ( void ) test ();\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nunion uni; // incomplete type declared\n\nvoid func ( void )\n{\n    union uni *ptr_union;\n    int *ptr_int; \n    // ptr_int converted to pointer to incomplete type\n    ptr_union = ( union uni * ) ptr_int;\n    // ptr_union (incomplete type) converted to int pointer\n    ptr_int = ( int * )ptr_union;\n}",
			"details_en": "#### Abstract\nPointers to incomplete types cannot be converted to pointers of other types and vice versa \n\n#### Explanation\nType conversion operations between pointers to incomplete types may destroy the encapsulation of incomplete types, so pointers of incomplete types cannot be converted to pointers of other types.",
			"details_cn": "#### 概要\n指向不完整类型的指针与其他类型的指针不能转换，反之亦然\n\n#### 解释\n对指向不完整类型的指针进行类型转换操作可能会破坏不完整类型的封装，因此不能对不完整类型的指针转换为其他类型的指针。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nunion uni\n{\n    int i;\n    char c;\n}; // union declared\n\nvoid func ( void )\n{\n    union uni union_var;\n    union_var.i =1;\n    int *ptr_int;\n    // ptr_int point to union_var.i\n    ptr_int = &union_var.i;\n\n    // exception 1\n    struct a;\n    struct a *p;\n    p = NULL;\n\n    // exception 2\n    struct a *test ( void );\n    ( void ) test ();\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nunion uni; // incomplete type declared\n\nvoid func ( void )\n{\n    union uni *ptr_union;\n    int *ptr_int; \n    // ptr_int converted to pointer to incomplete type\n    ptr_union = ( union uni * ) ptr_int;\n    // ptr_union (incomplete type) converted to int pointer\n    ptr_int = ( int * )ptr_union;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174794072"
	},
	{
		"name": "No casting between pointers of different types",
		"code": "MSR_11_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "11.3",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, pointers are cast to pointers of other types",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中指针被转换为其他类型的指针",
			"code": "MSR_11_3",
			"override": "T",
			"master_id": "2030",
			"name": "No casting between pointers of different types",
			"name_cn": "不同类型的指针之间不能相互转换",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Pointers cannot be cast to pointers of other types",
			"desc_cn": "不能将指针转换为其他类型的指针",
			"abstract": "Pointers cannot be cast to pointers of other types",
			"explanation": "Casting one type of pointer to another type of pointer may be incorrectly aligned causing undefined behavior, so you cannot convert pointers to other types of pointers.",
			"abstract_cn": "不能将指针转换为其他类型的指针",
			"explanation_cn": "将指向一种类型的指针转换为另一种类型的指针可能会导致对齐错误以及未定义的行为，因此不能将指针转换为其他类型的指针。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int *ptr_int;    // pointer to int declared\n    char *ptr_char;  // pointer to char declared\n    *ptr_char = NULL;\n    *ptr_int = NULL; // pointers point to null\n    const *ptr_const;\n    const volatile *ptr_const_v;\n    ptr_const_v = (const volatile *) ptr_const; // compliant\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int *ptr_int;                 // pointer to int declared\n    char *ptr_char;               // pointer to char declared\n    ptr_int = ( int * ) ptr_char; // convert to int type pointer\n\n    const int * const * ptr_const_int;\n    ptr_const_int = ( const int * const * ) ptr_int; // convert to constant-qualified int type pointer\n}",
			"details_en": "#### Abstract\nPointers cannot be cast to pointers of other types\n\n#### Explanation\nCasting one type of pointer to another type of pointer may be incorrectly aligned causing undefined behavior, so you cannot convert pointers to other types of pointers.",
			"details_cn": "#### 概要\n不能将指针转换为其他类型的指针\n\n#### 解释\n将指向一种类型的指针转换为另一种类型的指针可能会导致对齐错误以及未定义的行为，因此不能将指针转换为其他类型的指针。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int *ptr_int;    // pointer to int declared\n    char *ptr_char;  // pointer to char declared\n    *ptr_char = NULL;\n    *ptr_int = NULL; // pointers point to null\n    const *ptr_const;\n    const volatile *ptr_const_v;\n    ptr_const_v = (const volatile *) ptr_const; // compliant\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int *ptr_int;                 // pointer to int declared\n    char *ptr_char;               // pointer to char declared\n    ptr_int = ( int * ) ptr_char; // convert to int type pointer\n\n    const int * const * ptr_const_int;\n    ptr_const_int = ( const int * const * ) ptr_int; // convert to constant-qualified int type pointer\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174851321"
	},
	{
		"name": "No conversion of int type to pointer",
		"code": "MSR_11_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-2-9",
			"misra_c": "11.4",
			"misra_cpp": "5-2-9",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, there is conversion between pointers and integers",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现指针和整数相互转换",
			"code": "MSR_11_4",
			"override": "T",
			"master_id": "2031",
			"name": "No conversion of int type to pointer",
			"name_cn": "避免指针和整数相互转换",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Avoid the conversion between pointers and integers",
			"desc_cn": "避免指针和整数相互转换",
			"abstract": "Avoid the conversion between pointers and integers",
			"explanation": "Implementing the conversion between pointers and integers may result in data overflow of the integers or mis-alignment of the pointers. Avoid conversion between pointers and integers as much as possible.",
			"abstract_cn": "避免指针和整形的相互转换",
			"explanation_cn": "在实现指针和整形的转换可能会导致整形的数据溢出或者指针无法正常对齐，因此尽可能避免指针和整形的相互转换。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int *ptr_int;\n    int int_a, int_b;\n    int_a = 1;\n    ptr_int = &int_a; // ptr_int point to int_a\n    int_b = *ptr_int; // *ptr_int assigned to int_b\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int *ptr_int;\n    int int_a, int_b;\n    int_a = 1;\n    ptr_int = ( int * ) int_a; // convert int to pointer\n    int_b = ( int ) ptr_int;   // convert pointer to type int\n}",
			"details_en": "#### Abstract\nAvoid the conversion between pointers and integers\n\n#### Explanation\nImplementing the conversion between pointers and integers may result in data overflow of the integers or mis-alignment of the pointers. Avoid conversion between pointers and integers as much as possible.",
			"details_cn": "#### 概要\n避免指针和整形的相互转换\n\n#### 解释\n在实现指针和整形的转换可能会导致整形的数据溢出或者指针无法正常对齐，因此尽可能避免指针和整形的相互转换。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int *ptr_int;\n    int int_a, int_b;\n    int_a = 1;\n    ptr_int = &int_a; // ptr_int point to int_a\n    int_b = *ptr_int; // *ptr_int assigned to int_b\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int *ptr_int;\n    int int_a, int_b;\n    int_a = 1;\n    ptr_int = ( int * ) int_a; // convert int to pointer\n    int_b = ( int ) ptr_int;   // convert pointer to type int\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174903243"
	},
	{
		"name": "No conversion from pointers to void into pointer to object",
		"code": "MSR_11_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-2-8",
			"misra_c": "11.5",
			"misra_cpp": "5-2-8",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, null pointers are coverted to pointers to objects",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现将空类型指针转换为指向其他对象的指针",
			"code": "MSR_11_5",
			"override": "T",
			"master_id": "2032",
			"name": "No conversion from pointers to void into pointer to object",
			"name_cn": "避免将空类型指针转换为指向其他对象的指针",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Avoid converting null pointers to pointers to objects",
			"desc_cn": "避免将空类型指针转换为指向其他对象的指针",
			"abstract": "Avoid converting null pointers to pointers to objects",
			"explanation": "Conversion from pointer to void into pointer to object may result in undefined behaviour.",
			"abstract_cn": "避免将空类型指针转换为指向其他对象的指针",
			"explanation_cn": "从指向 void 的指针转换为指向对象的指针可能会导致未定义的行为。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    void *ptr_void; // void pointer declared\n    int *ptr_int;   // int pointer declared\n    int int_var;\n    ptr_int = &int_var;\n    // convert int pointer into void pointer\n    ptr_void = ( void * ) ptr_int;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    void *ptr_void; // void pointer declared\n    int *ptr_int;   // int pointer declared\n    int int_var;\n    ptr_void = &int_var;\n    // convert void pointer into int pointer\n    ptr_int = ( int * ) ptr_void;\n}",
			"details_en": "#### Abstract\nAvoid converting null pointers to pointers to objects\n\n#### Explanation\nConversion from pointer to void into pointer to object may result in undefined behaviour.",
			"details_cn": "#### 概要\n避免将空类型指针转换为指向其他对象的指针\n\n#### 解释\n从指向 void 的指针转换为指向对象的指针可能会导致未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    void *ptr_void; // void pointer declared\n    int *ptr_int;   // int pointer declared\n    int int_var;\n    ptr_int = &int_var;\n    // convert int pointer into void pointer\n    ptr_void = ( void * ) ptr_int;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    void *ptr_void; // void pointer declared\n    int *ptr_int;   // int pointer declared\n    int int_var;\n    ptr_void = &int_var;\n    // convert void pointer into int pointer\n    ptr_int = ( int * ) ptr_void;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629174951145"
	},
	{
		"name": "No casting between a void pointer and an arithmetic type",
		"code": "MSR_11_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "11.6",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, there is null type pointer and arithmetic type conversion",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现空类型指针以及算术类型的转换",
			"code": "MSR_11_6",
			"override": "T",
			"master_id": "2033",
			"name": "No casting between a void pointer and an arithmetic type",
			"name_cn": "避免空指针和算术类型之间的转换",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Cannot perform a null type pointer and arithmetic type conversion",
			"desc_cn": "不能进行空类型指针以及算术类型的转换",
			"abstract": "Cannot perform a null type pointer and arithmetic type conversion",
			"explanation": "During data conversion, data type conversion between null pointers and arithmetic types may cause unalignment with undefined behavior during data conversion.",
			"abstract_cn": "不能进行空类型指针以及算术类型的转换",
			"explanation_cn": "对空类型指针和算术类型相互的数据类型转换可能会引起对齐问题以及数据转换中出现未定义行为。",
			"example_good": "///c:\n#include <stdio.h>\n\n#define ZERO 0\n\nvoid func ( void )\n{\n    void *ptr_void;\n    int int_var;\n    // ptr_void point to the address of int_var\n    ptr_void = &int_var;\n    ptr_void = (void *)ZERO;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    void *ptr_void;\n    int int_var;\n    // convert int_var to void pointer\n    ptr_void = ( void * ) int_var;\n}",
			"details_en": "#### Abstract\nCannot perform a null type pointer and arithmetic type conversion\n\n#### Explanation\nDuring data conversion, data type conversion between null pointers and arithmetic types may cause unalignment with undefined behavior during data conversion.",
			"details_cn": "#### 概要\n不能进行空类型指针以及算术类型的转换\n\n#### 解释\n对空类型指针和算术类型相互的数据类型转换可能会引起对齐问题以及数据转换中出现未定义行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n#define ZERO 0\n\nvoid func ( void )\n{\n    void *ptr_void;\n    int int_var;\n    // ptr_void point to the address of int_var\n    ptr_void = &int_var;\n    ptr_void = (void *)ZERO;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    void *ptr_void;\n    int int_var;\n    // convert int_var to void pointer\n    ptr_void = ( void * ) int_var;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175010532"
	},
	{
		"name": "Cast between void pointer and a non-int arithmetic type should not be performed",
		"code": "MSR_11_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "11.7",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, there is casting between pointers to objects and non-integer arithmetic types",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现指向对象的指针与非整形的算术类型的转换",
			"code": "MSR_11_7",
			"override": "T",
			"master_id": "2034",
			"name": "Cast between void pointer and a non-int arithmetic type should not be performed",
			"name_cn": "不能进行指向对象的指针与非整形的算术类型的转换",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Cast between void pointer and a non-int arithmetic type should not be performed",
			"desc_cn": "不能进行指向对象的指针与非整形的算术类型的转换",
			"abstract": "Cast between void pointer and a non-int arithmetic type should not be performed",
			"explanation": "In order to prevent undefined behavior during the type conversion process, the data type conversion between the pointer to the object and the non-integer arithmetic is not allowed. ",
			"abstract_cn": "不能进行指向对象的指针与非整形的算术类型的转换",
			"explanation_cn": "为了防止在类型转换过程中出现未定义行为，不应进行指向对象的指针与非整形算术类型的相互数据类型转换。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int a, b;\n    int *p;\n    a = ( int ) p; // compliant\n    p = ( int * ) b; // compliant\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    char a, b;\n    int *p;\n    a = ( char ) p;  // non-compliant\n    p = ( int * ) b; // non-compliant\n}",
			"details_en": "#### Abstract\nCast between void pointer and a non-int arithmetic type should not be performed\n\n#### Explanation\nIn order to prevent undefined behavior during the type conversion process, the data type conversion between the pointer to the object and the non-integer arithmetic is not allowed. ",
			"details_cn": "#### 概要\n不能进行指向对象的指针与非整形的算术类型的转换\n\n#### 解释\n为了防止在类型转换过程中出现未定义行为，不应进行指向对象的指针与非整形算术类型的相互数据类型转换。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int a, b;\n    int *p;\n    a = ( int ) p; // compliant\n    p = ( int * ) b; // compliant\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    char a, b;\n    int *p;\n    a = ( char ) p;  // non-compliant\n    p = ( int * ) b; // non-compliant\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175078109"
	},
	{
		"name": "Const or volatile pointers to pointed should not be cast away ",
		"code": "MSR_11_8",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "A5-2-3",
			"misra_c": "11.8",
			"misra_cpp": "5-2-5",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, pointer data type cast removes const or volatile qualifiers",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，指针的数据类型转换去除了const和volatile限定符",
			"code": "MSR_11_8",
			"override": "T",
			"master_id": "2035",
			"name": "Const or volatile pointers to pointed should not be cast away ",
			"name_cn": "指针的数据类型转换不能去除const和volatile限定符",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Pointer data type cast cannot remove const or volatile qualifiers",
			"desc_cn": "指针的数据类型转换不能去除const和volatile限定符",
			"abstract": "Pointer data type cast cannot remove const or volatile qualifiers",
			"explanation": "The const and volatile qualifiers in the definition cannot be removed when the pointer data type is converted. This may cause errors in the reading and writing process of the pointer.",
			"abstract_cn": "指针的数据类型转换不能去除const和volatile限定符",
			"explanation_cn": "在进行指针的数据类型转换时不能去除定义中的const和volatile限定符，否则可能导致该指针的读写过程出现错误。",
			"example_good": "///c:\n#include <stdio.h>\n#include <malloc.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    // const pointer declared\n    int * const ptr_const = ( int *) malloc ( sizeof ( int ) );\n    int *ptr_int;\n    // ptr_int point to the address of ptr_const\n    ptr_int = ptr_const;\n    // more code that may change ptr_const\n    // ...\n    \n}",
			"example_bad": "///c:\n#include <stdio.h>\n#include <malloc.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int * const *p_constpt;\n    volatile int *p_volatile;\n    // pointer to const declared\n    const int * ptr_const = ( int *) malloc ( sizeof ( int ) );\n    int *ptr_int;\n    int * *p_ptr_int;\n    // const qualifier removed in a cast\n    ptr_int = ( int * ) ptr_const;\n    ptr_int = ( int * ) p_volatile;\n    p_ptr_int = ( int * * ) p_constpt;\n    // more code that may change ptr_const\n    // ... \n}",
			"details_en": "#### Abstract\nPointer data type cast cannot remove const or volatile qualifiers\n\n#### Explanation\nThe const and volatile qualifiers in the definition cannot be removed when the pointer data type is converted. This may cause errors in the reading and writing process of the pointer.",
			"details_cn": "#### 概要\n指针的数据类型转换不能去除const和volatile限定符\n\n#### 解释\n在进行指针的数据类型转换时不能去除定义中的const和volatile限定符，否则可能导致该指针的读写过程出现错误。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <malloc.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    // const pointer declared\n    int * const ptr_const = ( int *) malloc ( sizeof ( int ) );\n    int *ptr_int;\n    // ptr_int point to the address of ptr_const\n    ptr_int = ptr_const;\n    // more code that may change ptr_const\n    // ...\n    \n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <malloc.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int * const *p_constpt;\n    volatile int *p_volatile;\n    // pointer to const declared\n    const int * ptr_const = ( int *) malloc ( sizeof ( int ) );\n    int *ptr_int;\n    int * *p_ptr_int;\n    // const qualifier removed in a cast\n    ptr_int = ( int * ) ptr_const;\n    ptr_int = ( int * ) p_volatile;\n    p_ptr_int = ( int * * ) p_constpt;\n    // more code that may change ptr_const\n    // ... \n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175130038"
	},
	{
		"name": "int null pointer const must be the NULL macro",
		"code": "MSR_11_9",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M4-10-2",
			"misra_c": "11.9",
			"misra_cpp": "4-10-2",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a null integer pointer not only points to the macro NULL",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，一个空整型指针不仅指向宏 NULL",
			"code": "MSR_11_9",
			"override": "T",
			"master_id": "2036",
			"name": "int null pointer const must be the NULL macro",
			"name_cn": "空的整型指针只能指向宏定义NULL",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A null integer pointer can only point to the macro NULL",
			"desc_cn": "空的整型指针只能指向宏定义NULL",
			"abstract": "A null integer pointer can only point to the macro NULL",
			"explanation": "An integer constant expression with the value 0 should be derived from expansion of the macro NULL if it appears as the value being assigned to a pointer or an operand of equal/not-equal, or operand of a trigraph.",
			"abstract_cn": "空的整型指针只能指向宏定义NULL",
			"explanation_cn": "在向指针赋值，或使用指针作为等于、不等于或者三目运算符时，应能用宏定义NULL表示空的整型。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *int_ptr = NULL; // ptr_int point to NULL\n    // NULL appear as an operand with the other operand a pointer\n    if ( int_ptr != (int *)NULL )\n    {\n        *int_ptr = NULL;\n    }\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *int_ptr = 0; // 0 assigned to ptr_int\n    // 0 appear as an operand with the other operand a pointer\n    if ( int_ptr != 0 )\n    {\n        *int_ptr = NULL;\n    }\n}",
			"details_en": "#### Abstract\nA null integer pointer can only point to the macro NULL\n\n#### Explanation\nAn integer constant expression with the value 0 should be derived from expansion of the macro NULL if it appears as the value being assigned to a pointer or an operand of equal/not-equal, or operand of a trigraph.",
			"details_cn": "#### 概要\n空的整型指针只能指向宏定义NULL\n\n#### 解释\n在向指针赋值，或使用指针作为等于、不等于或者三目运算符时，应能用宏定义NULL表示空的整型。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *int_ptr = NULL; // ptr_int point to NULL\n    // NULL appear as an operand with the other operand a pointer\n    if ( int_ptr != (int *)NULL )\n    {\n        *int_ptr = NULL;\n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    int *int_ptr = 0; // 0 assigned to ptr_int\n    // 0 appear as an operand with the other operand a pointer\n    if ( int_ptr != 0 )\n    {\n        *int_ptr = NULL;\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175190976"
	},
	{
		"name": "Shift amount of shift operator must be smaller than the bit size of operand",
		"code": "MSR_12_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-8-1",
			"misra_c": "12.2",
			"misra_cpp": "5-8-1",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the right operand of the shift operator is not taken from zero to one less than the number of bits in the left operand",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，位移运算符的右操作数不是从零到左操作数的位数中取值",
			"code": "MSR_12_2",
			"override": "T",
			"master_id": "2037",
			"name": "Shift amount of shift operator must be smaller than the bit size of operand",
			"name_cn": "移位运算符的移位量必须小于操作数的位数",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The right operand of the shift operator should be taken from zero to one less than the number of bits in the left operand",
			"desc_cn": "位移运算符的右操作数应该从零到左操作数的位数中取值",
			"abstract": "The right operand of the shift operator should be taken from zero to one less than the number of bits in the left operand",
			"explanation": "The right operand of the shift operator should be a positive integer, the value range is from zero to one less than the number of digits in the left operand. Any value beyond this range will cause undefined behavior.",
			"abstract_cn": "位移运算符的右操作数应该从零到左操作数的位数中取取值",
			"explanation_cn": "位移运算符的右操作数应该为一个正整数，取值范围为零到左操作数的位数，取超出该范围的值为未定义的行为。",
			"example_good": "///c:\n#include <stdint.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    uint16_t uint16_var = 2;\n    uint32_t uint32_var;\n    // 17 is in the range 0 to the size of uint16_var\n    uint32_var = uint32_var << 17;\n}",
			"example_bad": "///c:\n#include <stdint.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    uint16_t uint16_var = 2;\n    // 17 is bigger than the size of uint16_var\n    uint16_var = uint16_var << 17;\n}",
			"details_en": "#### Abstract\nThe right operand of the shift operator should be taken from zero to one less than the number of bits in the left operand\n\n#### Explanation\nThe right operand of the shift operator should be a positive integer, the value range is from zero to one less than the number of digits in the left operand. Any value beyond this range will cause undefined behavior.",
			"details_cn": "#### 概要\n位移运算符的右操作数应该从零到左操作数的位数中取取值\n\n#### 解释\n位移运算符的右操作数应该为一个正整数，取值范围为零到左操作数的位数，取超出该范围的值为未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdint.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    uint16_t uint16_var = 2;\n    uint32_t uint32_var;\n    // 17 is in the range 0 to the size of uint16_var\n    uint32_var = uint32_var << 17;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdint.h>\n\nvoid func ( void );\n\nvoid func ( void )\n{\n    uint16_t uint16_var = 2;\n    // 17 is bigger than the size of uint16_var\n    uint16_var = uint16_var << 17;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175249070"
	},
	{
		"name": "Comma operator not allowed",
		"code": "MSR_12_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-18-1",
			"misra_c": "12.3",
			"misra_cpp": "5-18-1",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the comma operator is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了逗号运算符",
			"code": "MSR_12_3",
			"override": "T",
			"master_id": "2038",
			"name": "Comma operator not allowed",
			"name_cn": "不允许使用逗号运算符",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Try not to use the comma operator",
			"desc_cn": "尽量不使用逗号运算符",
			"abstract": "Try not to use the comma operator",
			"explanation": "Since using the comma operator will reduce the readability of the code, try to avoid using the comma operator.",
			"abstract_cn": "尽量不使用逗号运算符",
			"explanation_cn": "由于使用逗号运算符会降低代码的可读性，因此要尽量避免使用逗号运算符。",
			"example_good": "///c:\n#include <stdint.h>\n\nstatic char a[ 10 ];\n\nvoid func ( void )\n{\n    int i;\n    char *p;\n    // same effect achieved by other mean\n    p = &a[ 0 ];\n    for ( i = 0; i < 10 ; ++i)\n    {\n        *p++ = i;\n    }\n}",
			"example_bad": "///c:\n#include <stdint.h>\n\nstatic char a[ 10 ];\n\nvoid func ( void )\n{\n    int i;\n    char *p;\n    // comma operator would reduce the readability of code\n    for ( i = 0, p = &a[ 0 ]; i < 10 ; ++i, *p++ = i)\n    {\n        foo(p);\n    }\n}",
			"details_en": "#### Abstract\nTry not to use the comma operator\n\n#### Explanation\nSince using the comma operator will reduce the readability of the code, try to avoid using the comma operator.",
			"details_cn": "#### 概要\n尽量不使用逗号运算符\n\n#### 解释\n由于使用逗号运算符会降低代码的可读性，因此要尽量避免使用逗号运算符。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdint.h>\n\nstatic char a[ 10 ];\n\nvoid func ( void )\n{\n    int i;\n    char *p;\n    // same effect achieved by other mean\n    p = &a[ 0 ];\n    for ( i = 0; i < 10 ; ++i)\n    {\n        *p++ = i;\n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdint.h>\n\nstatic char a[ 10 ];\n\nvoid func ( void )\n{\n    int i;\n    char *p;\n    // comma operator would reduce the readability of code\n    for ( i = 0, p = &a[ 0 ]; i < 10 ; ++i, *p++ = i)\n    {\n        foo(p);\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175306920"
	},
	{
		"name": "Const expression should not cause unsigned wrap-around",
		"code": "MSR_12_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-19-1",
			"misra_c": "12.4",
			"misra_cpp": "5-19-1",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a constant expression causes an unsigned integer wrap-around",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，无符号整形常量表达式的值导致了回绕",
			"code": "MSR_12_4",
			"override": "T",
			"master_id": "2039",
			"name": "Const expression should not cause unsigned wrap-around",
			"name_cn": "无符号整形常量表达式的值不能导致回绕",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A constant expression should not cause an unsigned integer wrap-around",
			"desc_cn": "无符号整形常量表达式的值不能导致回绕",
			"abstract": "A constant expression should not cause an unsigned integer wrap-around",
			"explanation": "To prevent wrap-around, the value range of the unsigned integer constant expression should be in the range of zero to the maximum value that the unsigned integer can represent.",
			"abstract_cn": "无符号整形常量表达式的值不能导致回绕",
			"explanation_cn": "为防止发生回绕，因此无符号整形常量表达式的值的取值范围应为零到无符号整形能表示的最大值。",
			"example_good": "///c:\n#include <stdio.h>\n\n#define MAXIMUM 0xffffffffu // maximum value of unsigned int\n\nconst unsigned int const_int = 1;\nvoid func( void );\n\nvoid func( void )\n{\n    unsigned int uint_var;\n    // 0xffffffff assigned to long_long_var\n    uint_var = MAXIMUM;\n    // uint_var + 1 and uint_var + const_int is not a constant expression\n    uint_var = uint_var + 1;\n    uint_var = uint_var + const_int;\n    \n    if (( 1 < 0 ) || ( 0u - 10u ))\n    {\n        // compliant\n    }\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\n#define MAXIMUM 0xffffffffu // value of unsigned int (assume int is 32 bits)\n#define ONE     0x1u\nvoid func( void );\n\nvoid func( void )\n{\n    unsigned int uint_var;\n    // the value of MAXIMUM + 1 lead to wrap-around\n    uint_var = MAXIMUM + ONE;\n}",
			"details_en": "#### Abstract\nA constant expression should not cause an unsigned integer wrap-around\n\n#### Explanation\nTo prevent wrap-around, the value range of the unsigned integer constant expression should be in the range of zero to the maximum value that the unsigned integer can represent.",
			"details_cn": "#### 概要\n无符号整形常量表达式的值不能导致回绕\n\n#### 解释\n为防止发生回绕，因此无符号整形常量表达式的值的取值范围应为零到无符号整形能表示的最大值。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n#define MAXIMUM 0xffffffffu // maximum value of unsigned int\n\nconst unsigned int const_int = 1;\nvoid func( void );\n\nvoid func( void )\n{\n    unsigned int uint_var;\n    // 0xffffffff assigned to long_long_var\n    uint_var = MAXIMUM;\n    // uint_var + 1 and uint_var + const_int is not a constant expression\n    uint_var = uint_var + 1;\n    uint_var = uint_var + const_int;\n    \n    if (( 1 < 0 ) || ( 0u - 10u ))\n    {\n        // compliant\n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n#define MAXIMUM 0xffffffffu // value of unsigned int (assume int is 32 bits)\n#define ONE     0x1u\nvoid func( void );\n\nvoid func( void )\n{\n    unsigned int uint_var;\n    // the value of MAXIMUM + 1 lead to wrap-around\n    uint_var = MAXIMUM + ONE;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175363869"
	},
	{
		"name": "Initializer lists should not contain persistent side effects",
		"code": "MSR_13_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "13.1",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the initialization list has side effects",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，初始化列表产生了副作用",
			"code": "MSR_13_1",
			"override": "T",
			"master_id": "2040",
			"name": "Initializer lists should not contain persistent side effects",
			"name_cn": "初始化列表不应含有持久的副作用",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The initialization list should not have side effects",
			"desc_cn": "初始化列表不应该产生副作用",
			"abstract": "The initialization list should not have side effects",
			"explanation": "In order to avoid causing errors in the initialization content and side effects affecting the operation of the program, operations that produce side effects such as assigning other parameters to other parameters, should not be performed in the initialization list.",
			"abstract_cn": "初始化列表不应该产生副作用",
			"explanation_cn": "为避免导致初始化的内容出现错误以及副作用影响程序运行，不应该在初始化列表中进行对其他参数赋值等产生副作用的操作。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func( void )\n{\n    int x = 0;\n    // array initialized with no side effect\n    int arr[2] = { 1, 2 };\n    // more code may call x\n    // ...\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func( void )\n{\n    int x = 0;\n    // object x modified due to side effect\n    int arr[2] = { ++x, ++x };\n    // more code may call x\n    // ...\n}",
			"details_en": "#### Abstract\nThe initialization list should not have side effects\n\n#### Explanation\nIn order to avoid causing errors in the initialization content and side effects affecting the operation of the program, operations that produce side effects such as assigning other parameters to other parameters, should not be performed in the initialization list.",
			"details_cn": "#### 概要\n初始化列表不应该产生副作用\n\n#### 解释\n为避免导致初始化的内容出现错误以及副作用影响程序运行，不应该在初始化列表中进行对其他参数赋值等产生副作用的操作。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func( void )\n{\n    int x = 0;\n    // array initialized with no side effect\n    int arr[2] = { 1, 2 };\n    // more code may call x\n    // ...\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func( void )\n{\n    int x = 0;\n    // object x modified due to side effect\n    int arr[2] = { ++x, ++x };\n    // more code may call x\n    // ...\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175419977"
	},
	{
		"name": "The values and side effects of expressions in the execution order must be the same",
		"code": "MSR_13_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "13.2",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, the value of ${so.func} is not deterministic in all possible execution orders.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，表达式${so.func}的值在所有可能的运行顺序下不是唯一确定的。",
			"code": "MSR_13_2",
			"override": "T",
			"master_id": "2041",
			"name": "The values and side effects of expressions in the execution order must be the same",
			"name_cn": "所有执行顺序下表达式的值及副作用一致",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The values and side effects of all expressions in the execution order must be the same",
			"desc_cn": "所有执行顺序下表达式的值及副作用一致",
			"abstract": "The values and side effects of all expressions in the execution order must be the same",
			"explanation": "Since the expression may have multiple execution orders, the design expression should ensure that the value of the expression and its side effects are the same in all possible execution orders.",
			"abstract_cn": "所有执行顺序下表达式的值及副作用一致",
			"explanation_cn": "由于表达式可能存在多种执行的顺序，设计表达式应该保证在所有可能的执行顺序下表达式的值以及其副作用都相同。",
			"example_good": "///c:\n#include <stdio.h>\n\nint func( void )\n{\n    int a = 6;\n    // the value will sure to be -60\n    a -= a*a;\n    a += a;\n    return a;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint func( void )\n{\n    int a = 6;\n\n    a += a -= a*a;\n    return a;\n}",
			"details_en": "#### Abstract\nThe values and side effects of all expressions in the execution order must be the same\n\n#### Explanation\nSince the expression may have multiple execution orders, the design expression should ensure that the value of the expression and its side effects are the same in all possible execution orders.",
			"details_cn": "#### 概要\n所有执行顺序下表达式的值及副作用一致\n\n#### 解释\n由于表达式可能存在多种执行的顺序，设计表达式应该保证在所有可能的执行顺序下表达式的值以及其副作用都相同。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func( void )\n{\n    int a = 6;\n    // the value will sure to be -60\n    a -= a*a;\n    a += a;\n    return a;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func( void )\n{\n    int a = 6;\n\n    a += a -= a*a;\n    return a;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175499543"
	},
	{
		"name": "Side effect free expr (except ++, --)",
		"code": "MSR_13_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M5-2-10",
			"misra_c": "13.3",
			"misra_cpp": "5-2-10",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the increment (++) or decrement (--) operators have additional side effects",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，增减量运算符出现额外的副作用",
			"code": "MSR_13_3",
			"override": "T",
			"master_id": "2042",
			"name": "Side effect free expr (except ++, --)",
			"name_cn": "增减量运算符无副作用",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The increment (++) or decrement (--) operators cannot have additional side effects",
			"desc_cn": "增减量运算符不能有额外的副作用",
			"abstract": "The increment (++) or decrement (--) operators cannot have additional side effects",
			"explanation": "Avoid mixing increment or decrement operators with other operators in expressions, including function calls, as this will cause an undefined behavior. Doing so will impair readability of the code.",
			"abstract_cn": "增减量运算符不能有额外的副作用",
			"explanation_cn": "避免混合使用增量或减量运算符与其他运算符，包括函数调用，否则可能损害程序可读性。",
			"example_good": "///c:\n#include <stdio.h>\n\nint func( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // make the code more readable by this mean\n    ++int_a;\n    int_c = int_a * int_b;\n    int_b--;\n    return int_c;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint func1( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // the complex expression impairs the readability\n    int_c = ++int_a * int_b--;\n    return int_c;\n}\n\nvoid func2 ( void )\n{\n    int x = 1;\n    // function call is side effect\n    if ( ( func1() - ++x ) > 5)\n    {\n        // non-compliant\n    }\n}",
			"details_en": "#### Abstract\nThe increment (++) or decrement (--) operators cannot have additional side effects\n\n#### Explanation\nAvoid mixing increment or decrement operators with other operators in expressions, including function calls, as this will cause an undefined behavior. Doing so will impair readability of the code.",
			"details_cn": "#### 概要\n增减量运算符不能有额外的副作用\n\n#### 解释\n避免混合使用增量或减量运算符与其他运算符，包括函数调用，否则可能损害程序可读性。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // make the code more readable by this mean\n    ++int_a;\n    int_c = int_a * int_b;\n    int_b--;\n    return int_c;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func1( void )\n{\n    int int_a, int_b, int_c;\n    int_a = int_b = 1;\n    // the complex expression impairs the readability\n    int_c = ++int_a * int_b--;\n    return int_c;\n}\n\nvoid func2 ( void )\n{\n    int x = 1;\n    // function call is side effect\n    if ( ( func1() - ++x ) > 5)\n    {\n        // non-compliant\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175577169"
	},
	{
		"name": "Assign operators inside an expression ",
		"code": "MSR_13_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "13.4",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the result of the assignment operator is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中赋值运算符的结果被使用",
			"code": "MSR_13_4",
			"override": "T",
			"master_id": "2043",
			"name": "Assign operators inside an expression ",
			"name_cn": "在表达式中分配运算符",
			"severity": "H",
			"compliance": "A",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The result of the assignment operator cannot be used",
			"desc_cn": "赋值运算符的结果不能被使用",
			"abstract": "The result of the assignment operator cannot be used",
			"explanation": "The result of the assignment operator should not be used since it introduces additional side-effects. Doing so also impairs readability of the code.",
			"abstract_cn": "赋值运算符的结果不能被使用",
			"explanation_cn": "由于会引入额外的副作用，赋值运算符的结果不能被作为一个值使用，否则会损害程序可读性。",
			"example_good": "///c:\n#include <stdio.h>\n#include <stdbool.h>\n\nvoid func( void )\n{\n    bool bool_var;\n    bool_var = true;\n    // == is not an assignment operator\n    while (bool_var == true)\n    {\n        // some code that change bool_var\n        // ...\n    }\n    \n}",
			"example_bad": "///c:\n#include <stdio.h>\n#include <stdbool.h>\n\nint test( void )\n{\n  return 0;\n}\n\nint func(int x, int y)\n{\n  int ret_var;\n  ret_var = 1;\n  bool bool_var;\n\n  if ( ( ret_var == 1 ) || ( bool_var = true ) )\n  {\n    // non-compliant\n  }\n\n  if ( ( ret_var = test() ) > 1 )\n  {\n    // non-compliant\n  }\n\n  while (0) {\n    // ...\n    if (x = 0) {  // typical typo interpreted as an assignment\n      ret_var = x = y; // non-compliant\n    }\n  }\n  return ret_var;\n}",
			"details_en": "#### Abstract\nThe result of the assignment operator cannot be used\n\n#### Explanation\nThe result of the assignment operator should not be used since it introduces additional side-effects. Doing so also impairs readability of the code.",
			"details_cn": "#### 概要\n赋值运算符的结果不能被使用\n\n#### 解释\n由于会引入额外的副作用，赋值运算符的结果不能被作为一个值使用，否则会损害程序可读性。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdbool.h>\n\nvoid func( void )\n{\n    bool bool_var;\n    bool_var = true;\n    // == is not an assignment operator\n    while (bool_var == true)\n    {\n        // some code that change bool_var\n        // ...\n    }\n    \n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdbool.h>\n\nint test( void )\n{\n  return 0;\n}\n\nint func(int x, int y)\n{\n  int ret_var;\n  ret_var = 1;\n  bool bool_var;\n\n  if ( ( ret_var == 1 ) || ( bool_var = true ) )\n  {\n    // non-compliant\n  }\n\n  if ( ( ret_var = test() ) > 1 )\n  {\n    // non-compliant\n  }\n\n  while (0) {\n    // ...\n    if (x = 0) {  // typical typo interpreted as an assignment\n      ret_var = x = y; // non-compliant\n    }\n  }\n  return ret_var;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175662250"
	},
	{
		"name": "The right operand of the && and || operators should not contain persistent side effect",
		"code": "MSR_13_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the right operand of the && and || operators have side effects",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，&&和||运算符的右操作数有副作用",
			"code": "MSR_13_5",
			"override": "T",
			"master_id": "2044",
			"name": "The right operand of the && and || operators should not contain persistent side effect",
			"name_cn": "&&和||运算符的右操作数不应该有副作用",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The right operand of the && and || operators cannot have side effects",
			"desc_cn": "&&和||运算符的右操作数不能有副作用",
			"abstract": "The right operand of the && and || operators cannot have side effects",
			"explanation": "The evaluation of the right hand operand of the && and || operators is conditional on the value of the left-hand operand. The right hand operand",
			"abstract_cn": "&&和||运算符的右操作数不能有副作用",
			"explanation_cn": "为了防止右操作数不执行导致应有的副作用没有产生，&&和||运算符的右操作数不能产生副作用。",
			"example_good": "///c:\n#include <stdio.h>\n#include <stdbool.h>\n\nstatic int int_a;\nvoid func( void );\nint func2( void );\nbool return_true( void );\n\nvoid func( void )\n{\n    int int_b;\n    \n    // right operand do not have side effect\n    if( return_true() || int_b == func2() );\n    // more code that may read int_a\n    // ...\n}\n\nint func2( void )\n{\n    return int_a + 1; // do not have side effect\n}\n\nbool return_true( void )\n{\n    return true;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n#include <stdbool.h>\n\nstatic int int_a;\nvoid func( void );\nint func2( void );\nbool return_true( void );\n\nvoid func( void )\n{\n    int int_b;\n    \n    // int_a is not modified as intended\n    if( return_true() || int_b == func2() );\n    // more code that may read int_a\n    // ...\n}\n\nint func2( void )\n{\n    int_a++; // side effect: int_a is modified\n    return int_a;\n}\n\nbool return_true( void )\n{\n    return true;\n}\n\nvoid func3( void )\n{\n    volatile int x;\n    int y = 1;\n    if ( ( y != 0) || ( x != 1 ) );\n    // access volatile object x has persistent side effect\n}\n\nvoid func4( void )\n{\n    int *fp = func2;\n    if ( (fp == NULL) || (*fp) );\n    // fp points to function with persistent effect\n}",
			"details_en": "#### Abstract\nThe right operand of the && and || operators cannot have side effects\n\n#### Explanation\nThe evaluation of the right hand operand of the && and || operators is conditional on the value of the left-hand operand. The right hand operand",
			"details_cn": "#### 概要\n&&和||运算符的右操作数不能有副作用\n\n#### 解释\n为了防止右操作数不执行导致应有的副作用没有产生，&&和||运算符的右操作数不能产生副作用。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdbool.h>\n\nstatic int int_a;\nvoid func( void );\nint func2( void );\nbool return_true( void );\n\nvoid func( void )\n{\n    int int_b;\n    \n    // right operand do not have side effect\n    if( return_true() || int_b == func2() );\n    // more code that may read int_a\n    // ...\n}\n\nint func2( void )\n{\n    return int_a + 1; // do not have side effect\n}\n\nbool return_true( void )\n{\n    return true;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdbool.h>\n\nstatic int int_a;\nvoid func( void );\nint func2( void );\nbool return_true( void );\n\nvoid func( void )\n{\n    int int_b;\n    \n    // int_a is not modified as intended\n    if( return_true() || int_b == func2() );\n    // more code that may read int_a\n    // ...\n}\n\nint func2( void )\n{\n    int_a++; // side effect: int_a is modified\n    return int_a;\n}\n\nbool return_true( void )\n{\n    return true;\n}\n\nvoid func3( void )\n{\n    volatile int x;\n    int y = 1;\n    if ( ( y != 0) || ( x != 1 ) );\n    // access volatile object x has persistent side effect\n}\n\nvoid func4( void )\n{\n    int *fp = func2;\n    if ( (fp == NULL) || (*fp) );\n    // fp points to function with persistent effect\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175733195"
	},
	{
		"name": "The operand of sizeof operator should not have potential side effects",
		"code": "MSR_13_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the operand of sizeof operator has persistent side effects",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，sizeof的操作数有持续的副作用",
			"code": "MSR_13_6",
			"override": "T",
			"master_id": "2045",
			"name": "The operand of sizeof operator should not have potential side effects",
			"name_cn": "sizeof 运算符的操作数不应有潜在的副作用",
			"severity": "H",
			"compliance": "M",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The operand of sizeof operator cannot have persistent side effects",
			"desc_cn": "sizeof的操作数不能有持续的副作用",
			"abstract": "The operand of sizeof operator cannot have persistent side effects",
			"explanation": "Since sizeof operator does not necessarily execute the expression in its operand, the operand of sizeof must not produce side effects.",
			"abstract_cn": "sizeof的操作数不能有持续的副作用",
			"explanation_cn": "由于sizeof不一定会执行它的操作数中的表达式，sizeof的操作数不能产生副作用。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func( void )\n{\n    int int_a, int_b;\n\n    // the operand do not have side effect\n    int_a = sizeof( int_b );\n    int_b++; // int_b modified as intended\n    // some code that may read int_b\n    // ...\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func( void )\n{\n    int int_a, int_b;\n    \n    // int_b is not modified as intended\n    int_a = sizeof( int_b++ );\n    // some code that may read int_b\n    // ...\n}",
			"details_en": "#### Abstract\nThe operand of sizeof operator cannot have persistent side effects\n\n#### Explanation\nSince sizeof operator does not necessarily execute the expression in its operand, the operand of sizeof must not produce side effects.",
			"details_cn": "#### 概要\nsizeof的操作数不能有持续的副作用\n\n#### 解释\n由于sizeof不一定会执行它的操作数中的表达式，sizeof的操作数不能产生副作用。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func( void )\n{\n    int int_a, int_b;\n\n    // the operand do not have side effect\n    int_a = sizeof( int_b );\n    int_b++; // int_b modified as intended\n    // some code that may read int_b\n    // ...\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func( void )\n{\n    int int_a, int_b;\n    \n    // int_b is not modified as intended\n    int_a = sizeof( int_b++ );\n    // some code that may read int_b\n    // ...\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1629175787637"
	},
	{
		"name": "Pointer arithmetic should not be used, except for ++ and --",
		"code": "MSR_18_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, pointer arithmetic is used, except for ++ and --",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，使用了除++和--之外的指针算术",
			"code": "MSR_18_4",
			"override": "T",
			"master_id": "2047",
			"name": "Pointer arithmetic should not be used, except for ++ and --",
			"name_cn": "不能使用指针算术，除了++和--",
			"severity": "L",
			"compliance": "A",
			"desc_en": "Pointer arithmetic should not be used, except for ++ and --",
			"desc_cn": "不能使用指针算术，除了++和--",
			"abstract": "Pointer arithmetic should not be used, except for ++ and --",
			"explanation": "Pointer arithmetic is confusing to the novice programmers. The expression ptr+1 may be mistakenly interpreted as adding one byte to the address held in ptr.",
			"abstract_cn": "不能使用指针算术，除了++和--",
			"explanation_cn": "指针算法会让初学者感到困惑。表达式ptr+1可能被错误地解释为向ptr中保存的地址添加一个字节",
			"example_good": "///c:\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    int *ptr;\n    ptr = arr;\n    ptr++;  // ++ operator is allowed\n    ptr[1] = 0;\n}",
			"example_bad": "///c:\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    int *ptr;\n    ptr = arr;\n\n    * (ptr + 1) = 0; // Using + in pointer arithmetic is confusing\n}",
			"details_en": "#### Abstract\nPointer arithmetic should not be used, except for ++ and --\n\n#### Explanation\nPointer arithmetic is confusing to the novice programmers. The expression ptr+1 may be mistakenly interpreted as adding one byte to the address held in ptr.",
			"details_cn": "#### 概要\n不能使用指针算术，除了++和--\n\n#### 解释\n指针算法会让初学者感到困惑。表达式ptr+1可能被错误地解释为向ptr中保存的地址添加一个字节",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    int *ptr;\n    ptr = arr;\n    ptr++;  // ++ operator is allowed\n    ptr[1] = 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    int *ptr;\n    ptr = arr;\n\n    * (ptr + 1) = 0; // Using + in pointer arithmetic is confusing\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630563656674"
	},
	{
		"name": "Variable length array types should not be used",
		"code": "MSR_18_8",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, variable length array types are used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了可变长数组类型",
			"code": "MSR_18_8",
			"override": "T",
			"master_id": "2048",
			"name": "Variable length array types should not be used",
			"name_cn": "不得使用可变长数组类型",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Variable length array types should not be used",
			"desc_cn": "不得使用可变长数组类型",
			"abstract": "Variable length array types should not be used",
			"explanation": "The use of variable-length array types would make it impossible to determine statically the amount of memory that must be reserved for a stack",
			"abstract_cn": "不得使用可变长数组类型",
			"explanation_cn": "使用可变长度数组类型将无法静态确定必须为堆栈保留的内存量",
			"example_good": "///c:\nvoid foo() {\n    // Don't use variable-length array\n    int arr[5];\n}\n\nvoid func() {\n    foo();\n}",
			"example_bad": "///c:\nvoid foo(int n) {\n    int arr[n];\n}\n\nvoid func() {\n    foo(-1);\n}",
			"details_en": "#### Abstract\nVariable length array types should not be used\n\n#### Explanation\nThe use of variable-length array types would make it impossible to determine statically the amount of memory that must be reserved for a stack",
			"details_cn": "#### 概要\n不得使用可变长数组类型\n\n#### 解释\n使用可变长度数组类型将无法静态确定必须为堆栈保留的内存量",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid foo() {\n    // Don't use variable-length array\n    int arr[5];\n}\n\nvoid func() {\n    foo();\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid foo(int n) {\n    int arr[n];\n}\n\nvoid func() {\n    foo(-1);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630565545156"
	},
	{
		"name": "Union should not be used",
		"code": "MSR_19_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, union is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了联合",
			"code": "MSR_19_2",
			"override": "T",
			"master_id": "2049",
			"name": "Union should not be used",
			"name_cn": "不得使用联合",
			"compliance": "A",
			"desc_en": "Union should not be used",
			"desc_cn": "不得使用联合",
			"abstract": "Union should not be used",
			"explanation": "If the union member read is wider than the member written then the value is unspecified. Since it is possible to access bytes with unspecified values, unions should not be used.",
			"abstract_cn": "不得使用联合",
			"explanation_cn": "如果读取的联合成员比写入的成员宽，则该值未指定。由于可以访问具有未指定值的字节，因此不应使用联合",
			"example_good": "///c:\n#include <stdio.h>\n#include <string.h>\n\nstruct Foo {\n    int i;\n    float f;\n    char str[10];\n};\n\nvoid func() {\n    struct Foo data;\n\n    data.i = 5;\n    data.f = 10.5;\n    strcpy(data.str, \"string\");\n\n    // Use struct instead of union to keep everything\n    printf(\"%d\\n\", data.i);\n    printf(\"%f\\n\", data.f);\n    printf(\"%s\\n\", data.str);\n}",
			"example_bad": "///c:\ntypedef union UnionT\n{\n  int    i;\n  char   c;\n  double d;\n} UNIONT;\n\ntypedef struct MyData\n{\n  int     tag;\n  UNIONT  u;\n} MYDATA;\n\n\nint foo(char ch_param)\n{\n   MYDATA md;\n\n   md.tag = 0;  // say, 0 for int, 1 for char, 2 for double\n   md.u.c = ch_param;\n\n   return md.u.i; // return is undefined\n}",
			"details_en": "#### Abstract\nUnion should not be used\n\n#### Explanation\nIf the union member read is wider than the member written then the value is unspecified. Since it is possible to access bytes with unspecified values, unions should not be used.",
			"details_cn": "#### 概要\n不得使用联合\n\n#### 解释\n如果读取的联合成员比写入的成员宽，则该值未指定。由于可以访问具有未指定值的字节，因此不应使用联合",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <string.h>\n\nstruct Foo {\n    int i;\n    float f;\n    char str[10];\n};\n\nvoid func() {\n    struct Foo data;\n\n    data.i = 5;\n    data.f = 10.5;\n    strcpy(data.str, \"string\");\n\n    // Use struct instead of union to keep everything\n    printf(\"%d\\n\", data.i);\n    printf(\"%f\\n\", data.f);\n    printf(\"%s\\n\", data.str);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\ntypedef union UnionT\n{\n  int    i;\n  char   c;\n  double d;\n} UNIONT;\n\ntypedef struct MyData\n{\n  int     tag;\n  UNIONT  u;\n} MYDATA;\n\n\nint foo(char ch_param)\n{\n   MYDATA md;\n\n   md.tag = 0;  // say, 0 for int, 1 for char, 2 for double\n   md.u.c = ch_param;\n\n   return md.u.i; // return is undefined\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630568247278"
	},
	{
		"name": "Memory allocation related functions in stdlib.h shall not be used",
		"code": "MSR_21_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, memory allocation related function ${so.func} in stdlib.h is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了stdlib.h 中的内存分配相关函数",
			"code": "MSR_21_3",
			"override": "T",
			"master_id": "2050",
			"name": "Memory allocation related functions in stdlib.h shall not be used",
			"name_cn": "不得使用 stdlib.h 中的内存分配相关函数",
			"compliance": "R",
			"desc_en": "Memory allocation related functions in stdlib.h shall not be used",
			"desc_cn": "不得使用 stdlib.h 中的内存分配相关函数",
			"abstract": "Memory allocation related functions in stdlib.h shall not be used",
			"explanation": "The use of memory allocation related functions in stdlib.h can lead to an undefined behaviour. For example:  memory that was dynamically allocated may not be freed subsequently.",
			"abstract_cn": "不得使用 stdlib.h 中的内存分配相关函数",
			"explanation_cn": "在stdlib.h中使用内存分配相关函数可能会导致未定义的行为。例如：动态分配的内存可能不会随后释放",
			"example_good": "///c:\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func() {\n\n    #define MAX_STR_SZ 10   \n    char str[MAX_STR_SZ];\n    strncpy(str, \"string\", MAX_STR_SZ);\n    \n    strcpy(str, \"string\");\n    printf(\"%s\", str);\n}",
			"example_bad": "///c:\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func() {\n    char *str;\n\n    str = (char *) malloc(10);\n    strcpy(str, \"string\");\n    printf(\"%s\", str);\n\n    free(str);\n}",
			"details_en": "#### Abstract\nMemory allocation related functions in stdlib.h shall not be used\n\n#### Explanation\nThe use of memory allocation related functions in stdlib.h can lead to an undefined behaviour. For example:  memory that was dynamically allocated may not be freed subsequently.",
			"details_cn": "#### 概要\n不得使用 stdlib.h 中的内存分配相关函数\n\n#### 解释\n在stdlib.h中使用内存分配相关函数可能会导致未定义的行为。例如：动态分配的内存可能不会随后释放",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func() {\n\n    #define MAX_STR_SZ 10   \n    char str[MAX_STR_SZ];\n    strncpy(str, \"string\", MAX_STR_SZ);\n    \n    strcpy(str, \"string\");\n    printf(\"%s\", str);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <string.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func() {\n    char *str;\n\n    str = (char *) malloc(10);\n    strcpy(str, \"string\");\n    printf(\"%s\", str);\n\n    free(str);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630568715524"
	},
	{
		"name": "setjmp.h should not be used",
		"code": "MSR_21_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, setjmp.h is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了setjmp.h ",
			"code": "MSR_21_4",
			"override": "T",
			"master_id": "2051",
			"name": "setjmp.h should not be used",
			"name_cn": "不可以使用setjmp.h ",
			"compliance": "R",
			"desc_en": "setjmp.h should not be used",
			"desc_cn": "不可以使用setjmp.h ",
			"abstract": "setjmp.h should not be used",
			"explanation": "Setjmp allows the normal function call/return mechanisms to be bypassed. The use of that can lead to undefined and unspecified behavior.",
			"abstract_cn": "不可以使用setjmp.h ",
			"explanation_cn": "Setjmp允许绕过正常的函数调用/返回机制。使用该选项可能导致未定义和未指定的行为",
			"example_good": "///c:\n#include <stdio.h>\n#include <stdlib.h>\n\n// Do not use functions from setjmp.h\nvoid func() {\n    int val;\n    val = 10;\n    printf(\"%d\", val);\n}",
			"example_bad": "///c:\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\nvoid func() {\n    int val;\n    jmp_buf env_buffer;\n\n    val = setjmp(env_buffer);\n\n    // Set value to val after lngjmp\n    if (val != 0) {\n        printf(\"Return from longjmp with value = %d\", val);\n        exit(0);\n    }\n\n    // Jump back to top\n    printf(\"Jump to top\");\n    // Using longjmp and setjmp can cause undefined behaviour\n    longjmp(env_buffer, 10);\n}",
			"details_en": "#### Abstract\nsetjmp.h should not be used\n\n#### Explanation\nSetjmp allows the normal function call/return mechanisms to be bypassed. The use of that can lead to undefined and unspecified behavior.",
			"details_cn": "#### 概要\n不可以使用setjmp.h \n\n#### 解释\nSetjmp允许绕过正常的函数调用/返回机制。使用该选项可能导致未定义和未指定的行为",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdlib.h>\n\n// Do not use functions from setjmp.h\nvoid func() {\n    int val;\n    val = 10;\n    printf(\"%d\", val);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdlib.h>\n#include <setjmp.h>\n\nvoid func() {\n    int val;\n    jmp_buf env_buffer;\n\n    val = setjmp(env_buffer);\n\n    // Set value to val after lngjmp\n    if (val != 0) {\n        printf(\"Return from longjmp with value = %d\", val);\n        exit(0);\n    }\n\n    // Jump back to top\n    printf(\"Jump to top\");\n    // Using longjmp and setjmp can cause undefined behaviour\n    longjmp(env_buffer, 10);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630568852352"
	},
	{
		"name": "signal.h should not be used",
		"code": "MSR_21_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, signal.h is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了signal.h ",
			"code": "MSR_21_5",
			"override": "T",
			"master_id": "2052",
			"name": "signal.h should not be used",
			"name_cn": "不可以使用signal.h ",
			"compliance": "R",
			"desc_en": "signal.h should not be used",
			"desc_cn": "不可以使用signal.h ",
			"abstract": "signal.h should not be used",
			"explanation": "Since signal handling contains an implementation-defined and undefined behaviour, signal.h should not be used for C90 and C99 modes.",
			"abstract_cn": "不可以使用signal.h ",
			"explanation_cn": "由于信号处理包含实现定义和未定义的行为，signal.h不得用于C90和C99模式",
			"example_good": "///c:\n#include <stdio.h>\n#include <stdbool.h>\n#include <unistd.h>\n\nvoid func() { \n    // Do not use signal handler functions \n\n    while(true) {    \n        printf(\"Inside func()\");    \n        sleep(1);  \n    }\n}",
			"example_bad": "///c:\n#include <stdio.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <unistd.h>\n\nvoid sig_handler(int signum) {\n    printf(\"\\nInside handler function\\n\");\n}\n\nvoid func() { \n    // Register signal handler\n    // Using functions from signal.h can lead to undefined behaviour\n    signal(SIGINT,sig_handler); \n  \n    while(true) {    \n        printf(\"Inside func()\");    \n        sleep(1);  \n    }\n}",
			"details_en": "#### Abstract\nsignal.h should not be used\n\n#### Explanation\nSince signal handling contains an implementation-defined and undefined behaviour, signal.h should not be used for C90 and C99 modes.",
			"details_cn": "#### 概要\n不可以使用signal.h \n\n#### 解释\n由于信号处理包含实现定义和未定义的行为，signal.h不得用于C90和C99模式",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdbool.h>\n#include <unistd.h>\n\nvoid func() { \n    // Do not use signal handler functions \n\n    while(true) {    \n        printf(\"Inside func()\");    \n        sleep(1);  \n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <signal.h>\n#include <stdbool.h>\n#include <unistd.h>\n\nvoid sig_handler(int signum) {\n    printf(\"\\nInside handler function\\n\");\n}\n\nvoid func() { \n    // Register signal handler\n    // Using functions from signal.h can lead to undefined behaviour\n    signal(SIGINT,sig_handler); \n  \n    while(true) {    \n        printf(\"Inside func()\");    \n        sleep(1);  \n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630569074551"
	},
	{
		"name": "I/O functions in stdio.h should not be used",
		"code": "MSR_21_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, I/O functions in stdio.h is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 stdio.h 中的 I/O 函数",
			"code": "MSR_21_6",
			"override": "T",
			"master_id": "2053",
			"name": "I/O functions in stdio.h should not be used",
			"name_cn": "不得使用 stdio.h 中的 I/O 函数",
			"compliance": "R",
			"desc_en": "I/O functions in stdio.h should not be used",
			"desc_cn": "不得使用 stdio.h 中的 I/O 函数",
			"abstract": "I/O functions in stdio.h should not be used",
			"explanation": "Since I/O have unspecified, undefined and implementation-defined behaviours，I/O functions and their wide char equivalents in stdio.h should not be used for C90 and C99 modes.",
			"abstract_cn": "不得使用 stdio.h 中的 I/O 函数",
			"explanation_cn": "由于I/O具有未指定的、未定义的和实现定义的行为，因此在stdio.h中，I/O函数及其字符等价物不得用于C90和C99模式",
			"example_good": "///c:\nvoid func() {\n    // Do something\n    // Do not use stdio.h functions\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid bar_c(void* ptr)\n{\n    int* dest = (int*)ptr;\n    int data = (*dest);\n    int i;\n    int Buffer[10] = { 0 };\n    if(data >= 0)\n      {\n         Buffer[data] = 1;\n         for(i=0; i<10; i++)\n         {\n             printf(\"%d\", Buffer[i]);\n         }\n     }\n }\n\n void foo_v()\n {\n     int data;\n     data = -1;\n     fscanf(stdin, \"%d\", &data); // this can easily cause array out of bound\n     bar_c(&data);\n } ",
			"details_en": "#### Abstract\nI/O functions in stdio.h should not be used\n\n#### Explanation\nSince I/O have unspecified, undefined and implementation-defined behaviours，I/O functions and their wide char equivalents in stdio.h should not be used for C90 and C99 modes.",
			"details_cn": "#### 概要\n不得使用 stdio.h 中的 I/O 函数\n\n#### 解释\n由于I/O具有未指定的、未定义的和实现定义的行为，因此在stdio.h中，I/O函数及其字符等价物不得用于C90和C99模式",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    // Do something\n    // Do not use stdio.h functions\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid bar_c(void* ptr)\n{\n    int* dest = (int*)ptr;\n    int data = (*dest);\n    int i;\n    int Buffer[10] = { 0 };\n    if(data >= 0)\n      {\n         Buffer[data] = 1;\n         for(i=0; i<10; i++)\n         {\n             printf(\"%d\", Buffer[i]);\n         }\n     }\n }\n\n void foo_v()\n {\n     int data;\n     data = -1;\n     fscanf(stdin, \"%d\", &data); // this can easily cause array out of bound\n     bar_c(&data);\n } "
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630569135845"
	},
	{
		"name": "ascii conversion functions in stdlib.h should not be used",
		"code": "MSR_21_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "A18-0-2",
			"misra_c": "21.7",
			"misra_cpp": "18-0-2",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, ascii conversion functions in stdlib.h is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 stdlib.h 中的 ascii 转换函数",
			"code": "MSR_21_7",
			"override": "T",
			"master_id": "2054",
			"name": "ascii conversion functions in stdlib.h should not be used",
			"name_cn": "不得使用 stdlib.h 中的 ascii 转换函数",
			"compliance": "R",
			"desc_en": "ascii conversion functions in stdlib.h should not be used",
			"desc_cn": "不得使用 stdlib.h 中的 ascii 转换函数",
			"abstract": "ascii conversion functions in stdlib.h should not be used",
			"explanation": "Since atof, atol and atoll functions have undefined behaviors associated with them when the string cannot be converted, they should not be used for C90 and C99 modes.",
			"abstract_cn": "不得使用 stdlib.h 中的 ascii 转换函数",
			"explanation_cn": "由于atof、atol和atol函数在字符串无法转换时具有未定义的行为，因此它们不应用于C90和C99模式",
			"example_good": "///c:\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func() {\n   float val;\n   char str[10];\n   \n   strcpy(str, \"914\");\n   val = 914.000; //Do not use atof, atol, atoll, atoi\n   printf(\"String value = %s, Float value = %f\\n\", str, val);\n}",
			"example_bad": "///c:\n#include <iostream>\n#include <cstdlib>\n\nint foo()\n{\n  char s[] = \"98\";\n  long num;\n\n  num = atol(s);\n\n  std::cout << \"number in long = \" << num << std::endl;\n    \n}",
			"details_en": "#### Abstract\nascii conversion functions in stdlib.h should not be used\n\n#### Explanation\nSince atof, atol and atoll functions have undefined behaviors associated with them when the string cannot be converted, they should not be used for C90 and C99 modes.",
			"details_cn": "#### 概要\n不得使用 stdlib.h 中的 ascii 转换函数\n\n#### 解释\n由于atof、atol和atol函数在字符串无法转换时具有未定义的行为，因此它们不应用于C90和C99模式",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid func() {\n   float val;\n   char str[10];\n   \n   strcpy(str, \"914\");\n   val = 914.000; //Do not use atof, atol, atoll, atoi\n   printf(\"String value = %s, Float value = %f\\n\", str, val);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <iostream>\n#include <cstdlib>\n\nint foo()\n{\n  char s[] = \"98\";\n  long num;\n\n  num = atol(s);\n\n  std::cout << \"number in long = \" << num << std::endl;\n    \n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630569245970"
	},
	{
		"name": "Do not use abort, exit and system of stdlib.h",
		"code": "MSR_21_8",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "M18-0-3",
			"misra_c": "21.8",
			"misra_cpp": "18-0-3",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, abort, exit and system of stdlib.h are used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 stdlib.h 的 abort、exit 和 system",
			"code": "MSR_21_8",
			"override": "T",
			"master_id": "2055",
			"name": "Do not use abort, exit and system of stdlib.h",
			"name_cn": "不要使用 stdlib.h 的 abort、exit 和 system",
			"compliance": "R",
			"desc_en": "Do not use abort, exit and system of stdlib.h",
			"desc_cn": "不要使用 stdlib.h 的 abort、exit 和 system",
			"abstract": "Do not use abort, exit and system of stdlib.h",
			"explanation": "Since abort, exit and system of stdlib.h have undefined and implementation-defined behaviors, they should not be used for C90 and C99 modes.",
			"abstract_cn": "不要使用 stdlib.h 的 abort、exit 和 system",
			"explanation_cn": "由于stdlib.h 中的 abort、exit 和 system具有未定义和实现定义的行为，因此它们不应用于C90和C99模式。",
			"example_good": "///c:\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func () {\n   printf(\"Start of program\\n\");\n   \n   // Do not use abort, exit, getenv or system\n\n   printf(\"End of program\\n\");\n\n   return(0);\n}",
			"example_bad": "///c:\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n  char* ptr_h;\n  char h[64];\n\n  ptr_h = getenv(\"HOME\");  // value of HOME could be > 64, need size guard\n  if (ptr_h != NULL) {\n    // ...\n  }\n  return 0;\n}",
			"details_en": "#### Abstract\nDo not use abort, exit and system of stdlib.h\n\n#### Explanation\nSince abort, exit and system of stdlib.h have undefined and implementation-defined behaviors, they should not be used for C90 and C99 modes.",
			"details_cn": "#### 概要\n不要使用 stdlib.h 的 abort、exit 和 system\n\n#### 解释\n由于stdlib.h 中的 abort、exit 和 system具有未定义和实现定义的行为，因此它们不应用于C90和C99模式。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func () {\n   printf(\"Start of program\\n\");\n   \n   // Do not use abort, exit, getenv or system\n\n   printf(\"End of program\\n\");\n\n   return(0);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void)\n{\n  char* ptr_h;\n  char h[64];\n\n  ptr_h = getenv(\"HOME\");  // value of HOME could be > 64, need size guard\n  if (ptr_h != NULL) {\n    // ...\n  }\n  return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630569303741"
	},
	{
		"name": "bsearch and qsort should not be used",
		"code": "MSR_21_9",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, bsearch and qsort is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 bsearch 和 qsort",
			"code": "MSR_21_9",
			"master_id": "2056",
			"name": "bsearch and qsort should not be used",
			"name_cn": "不得使用 bsearch 和 qsort",
			"compliance": "R",
			"desc_en": "bsearch and qsort should not be used",
			"desc_cn": "不得使用 bsearch 和 qsort",
			"abstract": "bsearch and qsort should not be used",
			"explanation": "If bsearch and qsort function do not behave consistently when comparing elements, or they modify any of the elements, the behavior is undefined. So they should not be used for C90 and C99 modes.",
			"abstract_cn": "不得使用 bsearch 和 qsort",
			"explanation_cn": "如果bsearch和qsort函数在比较元素时行为不一致，或者它们修改了任何元素，则该行为未定义。因此，它们不应用于C90和C99模式",
			"example_good": "///c:\n#include <stdio.h>\n#include <stdlib.h>\n\nint arr[] = { 1, 2, 3, 4, 5 };\n\nvoid func () {\n   int key = 3;\n\n   // Use other method other than bsearch for searching element in an array\n   for (int i = 0; i < sizeof(arr) / 4; i++) {\n      if (arr[i] == key) {\n         printf(\"Item found\");\n         break;\n      }\n   }\n}",
			"example_bad": "///c:\n#include <stdio.h>\n#include <stdlib.h>\n\n\nint cmpfunc(const void * a, const void * b) {\n   return ( *(int*)a - *(int*)b );\n}\n\nint arr[] = { 1, 2, 3, 4, 5 };\n\nvoid func () {\n   int *item;\n   int key = 3;\n\n   // use bsearch to compare and find values of 3 in the array arr\n   item = (int*) bsearch (&key, arr, 5, sizeof (int), cmpfunc);\n   if( item != NULL ) {\n      printf(\"Found item\");\n   } else {\n      printf(\"Item is not in the array\");\n   }\n}",
			"details_en": "#### Abstract\nbsearch and qsort should not be used\n\n#### Explanation\nIf bsearch and qsort function do not behave consistently when comparing elements, or they modify any of the elements, the behavior is undefined. So they should not be used for C90 and C99 modes.",
			"details_cn": "#### 概要\n不得使用 bsearch 和 qsort\n\n#### 解释\n如果bsearch和qsort函数在比较元素时行为不一致，或者它们修改了任何元素，则该行为未定义。因此，它们不应用于C90和C99模式",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdlib.h>\n\nint arr[] = { 1, 2, 3, 4, 5 };\n\nvoid func () {\n   int key = 3;\n\n   // Use other method other than bsearch for searching element in an array\n   for (int i = 0; i < sizeof(arr) / 4; i++) {\n      if (arr[i] == key) {\n         printf(\"Item found\");\n         break;\n      }\n   }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdlib.h>\n\n\nint cmpfunc(const void * a, const void * b) {\n   return ( *(int*)a - *(int*)b );\n}\n\nint arr[] = { 1, 2, 3, 4, 5 };\n\nvoid func () {\n   int *item;\n   int key = 3;\n\n   // use bsearch to compare and find values of 3 in the array arr\n   item = (int*) bsearch (&key, arr, 5, sizeof (int), cmpfunc);\n   if( item != NULL ) {\n      printf(\"Found item\");\n   } else {\n      printf(\"Item is not in the array\");\n   }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630569343049"
	},
	{
		"name": "Time and date functions in stdlib.h should not be used",
		"code": "MSR_21_10",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, time and date functions in stdlib.h are used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中使用了 stdlib.h 中的时间和日期函数",
			"code": "MSR_21_10",
			"override": "T",
			"master_id": "2057",
			"name": "Time and date functions in stdlib.h should not be used",
			"name_cn": "不得使用 stdlib.h 中的时间和日期函数",
			"compliance": "R",
			"desc_en": "Time and date functions in stdlib.h should not be used",
			"desc_cn": "不得使用 stdlib.h 中的时间和日期函数",
			"abstract": "Time and date functions in stdlib.h should not be used",
			"explanation": "Since the time and date functions have unspecified, undefined and implementation-defined behaviors, they should not be used for C90 and C99 modes.",
			"abstract_cn": "不得使用 stdlib.h 中的时间和日期函数",
			"explanation_cn": "由于时间和日期函数具有未指定、未定义和实现定义的行为，因此它们不应用于C90和C99模式。",
			"example_good": "///c:\n#include <stdio.h>\n \nvoid func (){\n   // Do something\n   // Do not use time and date function\n}",
			"example_bad": "///c:\n#include <stdio.h>\n#include <time.h>\n \nvoid func (){\n   // Using time and date function can lead to undefined behaviour\n   printf(\"%ld\", time(NULL));\n}",
			"details_en": "#### Abstract\nTime and date functions in stdlib.h should not be used\n\n#### Explanation\nSince the time and date functions have unspecified, undefined and implementation-defined behaviors, they should not be used for C90 and C99 modes.",
			"details_cn": "#### 概要\n不得使用 stdlib.h 中的时间和日期函数\n\n#### 解释\n由于时间和日期函数具有未指定、未定义和实现定义的行为，因此它们不应用于C90和C99模式。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n \nvoid func (){\n   // Do something\n   // Do not use time and date function\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <time.h>\n \nvoid func (){\n   // Using time and date function can lead to undefined behaviour\n   printf(\"%ld\", time(NULL));\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1630569401770"
	},
	{
		"name": "The value of an expression should be the same under any order of evaluation permitted by the standard",
		"code": "MSR_5_0_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "MSR13.2",
			"misra_cpp": "5-0-1",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, the value of ${so.func} is not the same under any evaluation order permitted by the language standard",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}的结果值在任何编程语言允许的运行顺序下都不是一样的",
			"code": "MSR_5_0_1",
			"override": "T",
			"master_id": "3001",
			"name": "The value of an expression should be the same under any order of evaluation permitted by the standard",
			"name_cn": "在标准允许的任何评估顺序下，表达式的值应该相同",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "For an evaluation of any expression and its side effects, the value must be the same under any evaluation order permitted by the language standard",
			"desc_cn": "评估一个表达式及其副作用时，其结果值在任何编程语言允许的运行顺序下都应该是一样的",
			"abstract": "For an evaluation of any expression and its side effects, the value must be the same under any evaluation order permitted by the language standard",
			"explanation": "Since the expression may have multiple execution orders, the design for any expression, should ensure that the value of the expression and its side effects are the same in all possible execution orders as prescribed by the lexical rule for the expression.",
			"abstract_cn": "评估一个表达式及其副作用时，其结果值在任何编程语言允许的运行顺序下都应该是一样的",
			"explanation_cn": "由于表达式可能有多层运行顺序，表达式的设计应确保在所有可能的符合词法的运行顺序下，其结果值和副作用都是一样的。",
			"example_good": "///cpp:\n#define LEN 1024\n\nint array_int[LEN];\n\nint foo(int i, int j)\n{\n  if (j > 0) {\n    return i+1;\n  }\n  else\n    return i;\n}\n\nint bar(unsigned int parm_b)\n{\n  if (parm_b < LEN) \n  {\n    unsigned int temp = parm_b++;\n    array_int[temp] = parm_b ; // behavior is deterministic\n  }\n  return parm_b;\n}\n\nint call_foo(int i)\n{\n  int j = i++;\n  return foo(j, i); // return value non-ambiguous\n}",
			"example_bad": "///cpp:\n#define LEN 1024\n\nint array_int[LEN];\n\nint foo(int i, int j)\n{ \n  if (j > 0) {\n    return i+1;\n  }\n  else\n    return i;\n}\n\nint bar(unsigned int parm_b)\n{\n  if (parm_b < LEN)\n    array_int[parm_b++] = parm_b ; // behavior is undefined\n  return parm_b;\n}\n  \nint call_foo(int i)\n{\n  return foo(i++, i); // return value is implementation defined\n}",
			"details_en": "#### Abstract\nFor an evaluation of any expression and its side effects, the value must be the same under any evaluation order permitted by the language standard\n\n#### Explanation\nSince the expression may have multiple execution orders, the design for any expression, should ensure that the value of the expression and its side effects are the same in all possible execution orders as prescribed by the lexical rule for the expression.",
			"details_cn": "#### 概要\n评估一个表达式及其副作用时，其结果值在任何编程语言允许的运行顺序下都应该是一样的\n\n#### 解释\n由于表达式可能有多层运行顺序，表达式的设计应确保在所有可能的符合词法的运行顺序下，其结果值和副作用都是一样的。",
			"examples": {
				"good": {
					"cpp": [
						"\n#define LEN 1024\n\nint array_int[LEN];\n\nint foo(int i, int j)\n{\n  if (j > 0) {\n    return i+1;\n  }\n  else\n    return i;\n}\n\nint bar(unsigned int parm_b)\n{\n  if (parm_b < LEN) \n  {\n    unsigned int temp = parm_b++;\n    array_int[temp] = parm_b ; // behavior is deterministic\n  }\n  return parm_b;\n}\n\nint call_foo(int i)\n{\n  int j = i++;\n  return foo(j, i); // return value non-ambiguous\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#define LEN 1024\n\nint array_int[LEN];\n\nint foo(int i, int j)\n{ \n  if (j > 0) {\n    return i+1;\n  }\n  else\n    return i;\n}\n\nint bar(unsigned int parm_b)\n{\n  if (parm_b < LEN)\n    array_int[parm_b++] = parm_b ; // behavior is undefined\n  return parm_b;\n}\n  \nint call_foo(int i)\n{\n  return foo(i++, i); // return value is implementation defined\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631680588534"
	},
	{
		"name": "The value of an expression cannot be cast to sizes larger than the underlying type of the expression",
		"code": "MSR_5_0_8",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "MSR10.6",
			"misra_cpp": "5-0-8",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, the value of ${so.func} is cast to sizes larger than the underlying type of the expression",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，表达式的值转换后大于表达式现有类型的大小",
			"code": "MSR_5_0_8",
			"override": "T",
			"master_id": "3002",
			"name": "The value of an expression cannot be cast to sizes larger than the underlying type of the expression",
			"name_cn": "表达式的值转换后不能大于表达式现有类型的大小",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The value of an expression cannot be cast to sizes larger than the underlying type of the expression",
			"desc_cn": "表达式的值转换后不能大于表达式现有类型的大小",
			"abstract": "The value of an expression cannot be cast to sizes larger than the underlying type of the expression",
			"explanation": "When the value of an expression is cast to a size larger than its underlying type, there may be information loss such as signedness of the value.",
			"abstract_cn": "表达式的值转换后不能大于表达式现有类型的大小",
			"explanation_cn": "当表达式的值在转换后大于现有类型的大小时，有可能导致信息损失，譬如表达式值的符号。",
			"example_good": "///cpp:\nvoid func_5_0_8(int si, short sh_j, float flt_k)\n{\n  short  local_sh = 0x1234;\n  int    local_int1, local_int2;\n  float  local_flt = 1.0;\n  double local_dbl, local_dbl2;\n\n  local_int1 = static_cast< int > (local_sh) + sh_j;  // compliant\n  local_int2 = static_cast< int > (local_int1) + si;     // compliant\n\n  local_dbl2 = static_cast<double> ((double)flt_k) + local_flt;  // compliant\n  \n}",
			"example_bad": "///cpp:\nvoid func_5_0_8(int si, short sh_j, float flt_k)\n{\n  short  local_sh = 0x1234;\n  int    local_int1, local_int2;\n  float  local_flt = 1.0;\n  double local_dbl, local_dbl2;\n\n  local_int1 = static_cast< int > (local_sh + sh_j);  // non-compliant\n\n  local_dbl2 = static_cast<double> (flt_k + local_flt);  // non-compliant\n  \n}",
			"details_en": "#### Abstract\nThe value of an expression cannot be cast to sizes larger than the underlying type of the expression\n\n#### Explanation\nWhen the value of an expression is cast to a size larger than its underlying type, there may be information loss such as signedness of the value.",
			"details_cn": "#### 概要\n表达式的值转换后不能大于表达式现有类型的大小\n\n#### 解释\n当表达式的值在转换后大于现有类型的大小时，有可能导致信息损失，譬如表达式值的符号。",
			"examples": {
				"good": {
					"cpp": [
						"\nvoid func_5_0_8(int si, short sh_j, float flt_k)\n{\n  short  local_sh = 0x1234;\n  int    local_int1, local_int2;\n  float  local_flt = 1.0;\n  double local_dbl, local_dbl2;\n\n  local_int1 = static_cast< int > (local_sh) + sh_j;  // compliant\n  local_int2 = static_cast< int > (local_int1) + si;     // compliant\n\n  local_dbl2 = static_cast<double> ((double)flt_k) + local_flt;  // compliant\n  \n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\nvoid func_5_0_8(int si, short sh_j, float flt_k)\n{\n  short  local_sh = 0x1234;\n  int    local_int1, local_int2;\n  float  local_flt = 1.0;\n  double local_dbl, local_dbl2;\n\n  local_int1 = static_cast< int > (local_sh + sh_j);  // non-compliant\n\n  local_dbl2 = static_cast<double> (flt_k + local_flt);  // non-compliant\n  \n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631680711919"
	},
	{
		"name": "More than 2 indirections",
		"code": "MSR_5_0_19",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, declaration of objects contains more than two levels of pointer indirection",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，在声明对象时有多于两层的间接指针",
			"code": "MSR_5_0_19",
			"override": "T",
			"master_id": "3003",
			"name": "More than 2 indirections",
			"name_cn": "多于两层间接指针",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "Declaration of objects cannot contain more than two levels of pointer indirection",
			"desc_cn": "在声明对象时不能有多于两层的间接指针",
			"abstract": "Declaration of objects cannot contain more than two levels of pointer indirection",
			"explanation": "Having more than two levels of indirection, which gives, at least three levels of dereferencing an object, means it can be very hard to understand the intended behavior of the program.",
			"abstract_cn": "在声明对象时不能有多于两层的间接指针",
			"explanation_cn": "当声明对象时有多于两层的间接指针，会引起至少三层的解引用，从而给理解程序预期的行为带来困难。",
			"example_good": "///cpp:\nint array[10][20];\n\n// this example is equivalent to the \"avoid\" example\n// \nint mlk_three_indirect(int val)\n{\n  int j = val;\n  int *p = &j;\n  int **p_2, **r_2;\n  int *p_2_array = &array[*p][0];\n  int p3;\n  \n  array[val][0] = val;\n  p3 = array[val][0];\n  return p3;\n\n}",
			"example_bad": "///cpp:\nint array[10][20];\n\nint mlk_three_indirect(int val)\n{\n  int j = val;\n  int *p = &j;\n  int **p_2, **r_2;\n  int *p_2_array = &array[*p][0];\n  int ***p3;\n\n  // ... \n  p_2 = &p;\n  \n  // ...\n  array[val][0] = **p_2;\n  \n  //...\n  r_2 = &p_2_array;\n  \n  // ...\n  p3 = &r_2;\n  \n  // ... \n  return ***p3;\n\n}",
			"details_en": "#### Abstract\nDeclaration of objects cannot contain more than two levels of pointer indirection\n\n#### Explanation\nHaving more than two levels of indirection, which gives, at least three levels of dereferencing an object, means it can be very hard to understand the intended behavior of the program.",
			"details_cn": "#### 概要\n在声明对象时不能有多于两层的间接指针\n\n#### 解释\n当声明对象时有多于两层的间接指针，会引起至少三层的解引用，从而给理解程序预期的行为带来困难。",
			"examples": {
				"good": {
					"cpp": [
						"\nint array[10][20];\n\n// this example is equivalent to the \"avoid\" example\n// \nint mlk_three_indirect(int val)\n{\n  int j = val;\n  int *p = &j;\n  int **p_2, **r_2;\n  int *p_2_array = &array[*p][0];\n  int p3;\n  \n  array[val][0] = val;\n  p3 = array[val][0];\n  return p3;\n\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\nint array[10][20];\n\nint mlk_three_indirect(int val)\n{\n  int j = val;\n  int *p = &j;\n  int **p_2, **r_2;\n  int *p_2_array = &array[*p][0];\n  int ***p3;\n\n  // ... \n  p_2 = &p;\n  \n  // ...\n  array[val][0] = **p_2;\n  \n  //...\n  r_2 = &p_2_array;\n  \n  // ...\n  p3 = &r_2;\n  \n  // ... \n  return ***p3;\n\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631681301110"
	},
	{
		"name": "Bad enum initialization",
		"code": "MSR_8_5_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the enum initialization is incorrect",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中出现错误的枚举初始化",
			"code": "MSR_8_5_3",
			"override": "T",
			"master_id": "3004",
			"name": "Bad enum initialization",
			"name_cn": "错误的枚举初始化",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "The only explicit initialization of an enum with the “=” construct is such that all, none or the first one, are initialized",
			"desc_cn": "对于带有“=”构造的枚举，显式初始化能初始化或者不初始化全部枚举，也能仅初始化第一个枚举",
			"abstract": "The only explicit initialization of an enum with the “=” construct is such that all, none or the first one, are initialized",
			"explanation": "Explicit and uniform initialization of an enum list prevents mixing of automatic and manual assignment, which is error-prone. The compiler can also detect possible out of range errors for the enum.",
			"abstract_cn": "对于带有“=”构造的枚举，显式初始化能初始化或者不初始化全部枚举，也能仅初始化第一个枚举",
			"explanation_cn": "使用显式且一致的方式对枚举列表进行初始化，可以避免因混淆自动与手动赋值而造成错误，并且能使编译器发现枚举中可能是超出范围的错误。",
			"example_good": "///cpp:\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\n// compliant (but assignment not in sequence )\ntypedef enum bad_enum_color { white=0,\n         blue=1,         // 2 is not used \n         yellow=3 } BadEnum;  \n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}",
			"example_bad": "///cpp:\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\ntypedef enum bad_enum_color { white=0,\n\t\t\t      blue=1,\n\t\t\t      yellow } BadEnum;  // non-compliant\n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}",
			"details_en": "#### Abstract\nThe only explicit initialization of an enum with the “=” construct is such that all, none or the first one, are initialized\n\n#### Explanation\nExplicit and uniform initialization of an enum list prevents mixing of automatic and manual assignment, which is error-prone. The compiler can also detect possible out of range errors for the enum.",
			"details_cn": "#### 概要\n对于带有“=”构造的枚举，显式初始化能初始化或者不初始化全部枚举，也能仅初始化第一个枚举\n\n#### 解释\n使用显式且一致的方式对枚举列表进行初始化，可以避免因混淆自动与手动赋值而造成错误，并且能使编译器发现枚举中可能是超出范围的错误。",
			"examples": {
				"good": {
					"cpp": [
						"\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\n// compliant (but assignment not in sequence )\ntypedef enum bad_enum_color { white=0,\n         blue=1,         // 2 is not used \n         yellow=3 } BadEnum;  \n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\ntypedef enum color { red=3 } GoodEnum;   // compliant\n\ntypedef enum bad_enum_color { white=0,\n\t\t\t      blue=1,\n\t\t\t      yellow } BadEnum;  // non-compliant\n\ntypedef enum no_assign { NO_ONE, NO_TWO, NO_THREE } GoodEnum_NoAssign;\n\nextern void bar( color c, bad_enum_color b, no_assign n);\n\nvoid func_use(void)\n{\n  color var_color = red;\n  bad_enum_color var_bad_color = blue;\n  no_assign var_no_assign = NO_TWO;\n\n  bar(var_color, var_bad_color, var_no_assign);\n  return;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631681649014"
	},
	{
		"name": "Base class has virtual and non-virtual",
		"code": "MSR_10_1_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a base class is virtual and non-virtual in a multiple inheritance hierarchy",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的基类在多继承体系中既是虚拟的又是非虚拟的",
			"code": "MSR_10_1_3",
			"override": "T",
			"master_id": "3005",
			"name": "Base class has virtual and non-virtual",
			"name_cn": "基类有虚拟和非虚拟的",
			"severity": "H",
			"compliance": "R",
			"likelihood": "L",
			"cost": "H",
			"desc_en": "A base class should not be both, virtual and non-virtual in a multiple inheritance hierarchy",
			"desc_cn": "基类不能在多继承体系中既是虚拟的又是非虚拟的",
			"abstract": "A base class should not be both, virtual and non-virtual in a multiple inheritance hierarchy",
			"explanation": "If the base class is both virtual and non-virtual in a multiple inheritance hierarchy, then there will be multiple copies of the base class sub-object in the derived object. This is likely a declaration error.",
			"abstract_cn": "基类不能在多继承体系中既是虚拟的又是非虚拟的",
			"explanation_cn": "如果基类在多继承体系中既是虚拟的又是非虚拟的，那么会在派生对象中产生多个基类子对象的复制版。这可能导致声明错误。",
			"example_good": "///cpp:\nclass Base {};\n\nclass Derived1 : public virtual Base {}; // Base is virtual\n\nclass Derived2 : public virtual Base {}; // Base virtual\n\n// This hierarchy has two derived class from virtual base class\nclass V_and_V : public Derived1, public Derived2 { /* code here */ };\n  \n",
			"example_bad": "///cpp:\nclass Base {};\n\nclass Derived1 : public virtual Base {};\n\nclass Derived2 : public Base { };\n\n\nclass V_and_nonV : public Derived1, public Derived2 { };",
			"details_en": "#### Abstract\nA base class should not be both, virtual and non-virtual in a multiple inheritance hierarchy\n\n#### Explanation\nIf the base class is both virtual and non-virtual in a multiple inheritance hierarchy, then there will be multiple copies of the base class sub-object in the derived object. This is likely a declaration error.",
			"details_cn": "#### 概要\n基类不能在多继承体系中既是虚拟的又是非虚拟的\n\n#### 解释\n如果基类在多继承体系中既是虚拟的又是非虚拟的，那么会在派生对象中产生多个基类子对象的复制版。这可能导致声明错误。",
			"examples": {
				"good": {
					"cpp": [
						"\nclass Base {};\n\nclass Derived1 : public virtual Base {}; // Base is virtual\n\nclass Derived2 : public virtual Base {}; // Base virtual\n\n// This hierarchy has two derived class from virtual base class\nclass V_and_V : public Derived1, public Derived2 { /* code here */ };\n  \n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\nclass Base {};\n\nclass Derived1 : public virtual Base {};\n\nclass Derived2 : public Base { };\n\n\nclass V_and_nonV : public Derived1, public Derived2 { };"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631682426620"
	},
	{
		"name": "Dynamic type in ctor or dtor",
		"code": "MSR_12_1_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, an object’s dynamic type is used from the body of its constructor or destructor",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，对象的动态类型在构造函数或者析构函数本体使用",
			"code": "MSR_12_1_1",
			"override": "T",
			"master_id": "3006",
			"name": "Dynamic type in ctor or dtor",
			"name_cn": "ctor 或 dtor 中的动态类型",
			"compliance": "R",
			"desc_en": "An object’s dynamic type cannot be used from the body of its constructor or destructor",
			"desc_cn": "对象的动态类型不能在构造函数或者析构函数本体使用",
			"abstract": "An object’s dynamic type cannot be used from the body of its constructor or destructor",
			"explanation": "A non-static member of an object can have an initialization with the declaration of the member in its body (NSDMI). To avoid confusion, any member initialized this way (NSDMI) or with a constructor should be the same.",
			"abstract_cn": "对象的动态类型不能在构造函数或者析构函数本体使用",
			"explanation_cn": "对象的非静态成员能通过成员声明进行初始化（NSDMI)。为避免混淆，成员既可以通过NSDMI方式来初始化也可以通过构造函数来初始化，两种方式对于成员的初始化应该是一样的。",
			"example_good": "///cpp:\nclass Base {\npublic:\n  virtual void func_char();\n  \n  Base() {\n    Base::func_char();   // dynamic, non-virtual call\n  };\n};\n\n\nvoid foo(void)\n{\n  Base example;\n\n  example.func_char();  //  \n  return;\n}\n  ",
			"example_bad": "///cpp:\n#include <typeinfo>\n\nclass Base {\npublic:\n  virtual void func_char();\n  \n  Base() {\n    func_char();   // dynamic, virtual call to a virtual function\n    typeid(Base);  // dynamic typeid on a class with virtual function\n  };\n};\n\n\nvoid foo(void)\n{\n  Base example;\n\n  example.func_char();  //  \n  return;\n}\n  ",
			"details_en": "#### Abstract\nAn object’s dynamic type cannot be used from the body of its constructor or destructor\n\n#### Explanation\nA non-static member of an object can have an initialization with the declaration of the member in its body (NSDMI). To avoid confusion, any member initialized this way (NSDMI) or with a constructor should be the same.",
			"details_cn": "#### 概要\n对象的动态类型不能在构造函数或者析构函数本体使用\n\n#### 解释\n对象的非静态成员能通过成员声明进行初始化（NSDMI)。为避免混淆，成员既可以通过NSDMI方式来初始化也可以通过构造函数来初始化，两种方式对于成员的初始化应该是一样的。",
			"examples": {
				"good": {
					"cpp": [
						"\nclass Base {\npublic:\n  virtual void func_char();\n  \n  Base() {\n    Base::func_char();   // dynamic, non-virtual call\n  };\n};\n\n\nvoid foo(void)\n{\n  Base example;\n\n  example.func_char();  //  \n  return;\n}\n  "
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <typeinfo>\n\nclass Base {\npublic:\n  virtual void func_char();\n  \n  Base() {\n    func_char();   // dynamic, virtual call to a virtual function\n    typeid(Base);  // dynamic typeid on a class with virtual function\n  };\n};\n\n\nvoid foo(void)\n{\n  Base example;\n\n  example.func_char();  //  \n  return;\n}\n  "
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631682569290"
	},
	{
		"name": "ctor must explicitly call ctor for all its immediate base classes",
		"code": "MSR_12_1_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, ctor does not explicitly call ctor for all its immediate base classes",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中ctor没有为其所有直接基类显式调用 ctor",
			"code": "MSR_12_1_2",
			"override": "T",
			"master_id": "3007",
			"name": "ctor must explicitly call ctor for all its immediate base classes",
			"name_cn": "ctor 必须为其所有直接基类显式调用 ctor",
			"compliance": "A",
			"desc_en": "ctor must explicitly call ctor for all its immediate base classes",
			"desc_cn": "ctor 必须为其所有直接基类显式调用 ctor",
			"abstract": "ctor must explicitly call ctor for all its immediate base classes",
			"explanation": "If ctor call ctor for all its immediate base classes, it would reduce confusion over which constructor and parameters to use.",
			"abstract_cn": "ctor 必须为其所有直接基类显式调用 ctor",
			"explanation_cn": "如果 ctor 为其所有直接基类调用 ctor，它将减少对使用哪个构造函数和参数的混淆。",
			"example_good": "///cpp:\nclass Base {\npublic:\n  Base() {}\n  Base(int i);\n};\nclass Derived1 : public virtual Base {\npublic:\n  //  Derived1() {}\n  Derived1(int) : Base(0) {}\n};\nclass Derived2 : public virtual Base {\npublic:\n  //  Derived2() {}\n  Derived2(int) : Base(1) {}\n};",
			"example_bad": "///cpp:\nclass Base {\npublic:\n  Base() {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  //  Hier()    {}\n  Hier(int) {} // constructor used is ambiguous w.r.t. Derived1 or Derived2\n\n};",
			"details_en": "#### Abstract\nctor must explicitly call ctor for all its immediate base classes\n\n#### Explanation\nIf ctor call ctor for all its immediate base classes, it would reduce confusion over which constructor and parameters to use.",
			"details_cn": "#### 概要\nctor 必须为其所有直接基类显式调用 ctor\n\n#### 解释\n如果 ctor 为其所有直接基类调用 ctor，它将减少对使用哪个构造函数和参数的混淆。",
			"examples": {
				"good": {
					"cpp": [
						"\nclass Base {\npublic:\n  Base() {}\n  Base(int i);\n};\nclass Derived1 : public virtual Base {\npublic:\n  //  Derived1() {}\n  Derived1(int) : Base(0) {}\n};\nclass Derived2 : public virtual Base {\npublic:\n  //  Derived2() {}\n  Derived2(int) : Base(1) {}\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\nclass Base {\npublic:\n  Base() {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  //  Hier()    {}\n  Hier(int) {} // constructor used is ambiguous w.r.t. Derived1 or Derived2\n\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631683055833"
	},
	{
		"name": "constructor with single parameter of basic type should be explicit",
		"code": "MSR_12_1_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, constructor with single parameter of basic type is not explicit",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，具有基本类型的单个参数的构造函数不是显式的",
			"code": "MSR_12_1_3",
			"override": "T",
			"master_id": "3008",
			"name": "constructor with single parameter of basic type should be explicit",
			"name_cn": "具有单个基本类型参数的构造函数应该是显式的",
			"compliance": "R",
			"desc_en": "constructor with single parameter of basic type should be explicit",
			"desc_cn": "具有单个基本类型参数的构造函数应该是显式的",
			"abstract": "constructor with single parameter of basic type should be explicit",
			"explanation": "Explicit declaration of constructor prevents it from being used to convert from fundamental type to class type implicitly.",
			"abstract_cn": "具有单个基本类型参数的构造函数应该是显式的",
			"explanation_cn": "构造函数的显式声明防止它被用来隐式地从基本类型转换为类类型。",
			"example_good": "///cpp:\nclass Base {\npublic:\n  Base() {}\n  explicit Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {} \n  explicit Derived1(int) : Base(0) {}    // make explicit\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  explicit Derived2(int) : Base(1) {}    // make explicit\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  explicit Hier(int) : Derived1(2), Derived2(), Base() {}  // make explicit\n\n};",
			"example_bad": "///cpp:\n\nclass Base {\npublic:\n  Base(void) {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\nclass Hier : public Derived1, public Derived2 {\n  Hier(int)    {}\n};",
			"details_en": "#### Abstract\nconstructor with single parameter of basic type should be explicit\n\n#### Explanation\nExplicit declaration of constructor prevents it from being used to convert from fundamental type to class type implicitly.",
			"details_cn": "#### 概要\n具有单个基本类型参数的构造函数应该是显式的\n\n#### 解释\n构造函数的显式声明防止它被用来隐式地从基本类型转换为类类型。",
			"examples": {
				"good": {
					"cpp": [
						"\nclass Base {\npublic:\n  Base() {}\n  explicit Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {} \n  explicit Derived1(int) : Base(0) {}    // make explicit\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  explicit Derived2(int) : Base(1) {}    // make explicit\n}; \n\n\nclass Hier : public Derived1, public Derived2 {\n  explicit Hier(int) : Derived1(2), Derived2(), Base() {}  // make explicit\n\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n\nclass Base {\npublic:\n  Base(void) {}\n  Base(int i);\n};\n\n\nclass Derived1 : public virtual Base {\npublic:\n  Derived1() {}\n  Derived1(int) : Base(0) {}\n}; \n\nclass Derived2 : public virtual Base {\npublic:\n  Derived2() {}\n  Derived2(int) : Base(1) {}\n}; \n\nclass Hier : public Derived1, public Derived2 {\n  Hier(int)    {}\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631683220419"
	},
	{
		"name": "Non-POD member in a class must be private",
		"code": "MSR_11_0_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, non-POD member in a class is not private",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，类中的非 POD 成员必须不是私有的",
			"code": "MSR_11_0_1",
			"override": "T",
			"master_id": "3009",
			"name": "Non-POD member in a class must be private",
			"name_cn": "类中的非 POD 成员必须是私有的",
			"compliance": "R",
			"desc_en": "Non-POD member in a class must be private",
			"desc_cn": "类中的非 POD 成员必须是私有的",
			"abstract": "Non-POD member in a class must be private",
			"explanation": "",
			"abstract_cn": "类中的非 POD 成员必须是私有的",
			"explanation_cn": "",
			"example_good": "///cpp:\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Class_Without_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nclass Class_with_POD\n{\nprivate:\n  char    c;         // will need interfaces to access and modify\n  char*   pc;  \n};",
			"example_bad": "///cpp:\n#include <stdint.h>\n\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Class_Without_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nclass Class_with_POD\n{\npublic:\n  int8_t   c;         // POD has no default constructor\n  char*   pc;  \n};",
			"details_en": "#### Abstract\nNon-POD member in a class must be private\n\n#### Explanation\n",
			"details_cn": "#### 概要\n类中的非 POD 成员必须是私有的\n\n#### 解释\n",
			"examples": {
				"good": {
					"cpp": [
						"\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Class_Without_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nclass Class_with_POD\n{\nprivate:\n  char    c;         // will need interfaces to access and modify\n  char*   pc;  \n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdint.h>\n\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Class_Without_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nclass Class_with_POD\n{\npublic:\n  int8_t   c;         // POD has no default constructor\n  char*   pc;  \n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631683383735"
	},
	{
		"name": "All visible names within an inheritance hierarchy must be unique",
		"code": "MSR_10_2_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the visiable names within a inheritance hierarchy are not unique",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中，继承层次结构中的所有可见名称不是唯一的",
			"code": "MSR_10_2_1",
			"override": "T",
			"master_id": "3010",
			"name": "All visible names within an inheritance hierarchy must be unique",
			"name_cn": "继承层次结构中的所有可见名称必须是唯一的",
			"compliance": "A",
			"desc_en": "All visible names within an inheritance hierarchy must be unique",
			"desc_cn": "继承层次结构中的所有可见名称必须是唯一的",
			"abstract": "All visible names within an inheritance hierarchy must be unique",
			"explanation": "",
			"abstract_cn": "继承层次结构中的所有可见名称必须是唯一的",
			"explanation_cn": "",
			"example_good": "///cpp:\nclass Base {\npublic:\n  Base() {}\n  void func_char(char) {};\n};\n\nclass Derived : public Base {\npublic:\n  Derived() : Base() {}\n  void func_int(int) {};\n};\n\n\nint foo(void)\n{\n  int   i;\n  char ch;\n  Derived example;\n\n  example.func_int(i);\n\n  example.func_char(ch);  // func(char) in Base is not visible\n\n  return i;  \n}",
			"example_bad": "///cpp:\n\nclass Base {\npublic:\n  void func(char) {};\n};\n\nclass Derived : public Base {\npublic:\n  void func(int) {};\n};\n\n\nint foo(void)\n{\n  int   i;\n  char ch;\n  Derived example;\n\n  example.func(i);\n  example.func(ch);  // func(char) in Base is not visible \n  \n}",
			"details_en": "#### Abstract\nAll visible names within an inheritance hierarchy must be unique\n\n#### Explanation\n",
			"details_cn": "#### 概要\n继承层次结构中的所有可见名称必须是唯一的\n\n#### 解释\n",
			"examples": {
				"good": {
					"cpp": [
						"\nclass Base {\npublic:\n  Base() {}\n  void func_char(char) {};\n};\n\nclass Derived : public Base {\npublic:\n  Derived() : Base() {}\n  void func_int(int) {};\n};\n\n\nint foo(void)\n{\n  int   i;\n  char ch;\n  Derived example;\n\n  example.func_int(i);\n\n  example.func_char(ch);  // func(char) in Base is not visible\n\n  return i;  \n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n\nclass Base {\npublic:\n  void func(char) {};\n};\n\nclass Derived : public Base {\npublic:\n  void func(int) {};\n};\n\n\nint foo(void)\n{\n  int   i;\n  char ch;\n  Derived example;\n\n  example.func(i);\n  example.func(ch);  // func(char) in Base is not visible \n  \n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631687209359"
	},
	{
		"name": "Value returned by a function should be used",
		"code": "MSR_17_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, value returned by ${so.func} is not used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}的返回值未被使用",
			"code": "MSR_17_7",
			"override": "T",
			"master_id": "2058",
			"name": "Value returned by a function should be used",
			"name_cn": "应使用函数返回的值",
			"compliance": "R",
			"desc_en": "The value returned by a function which has non-void return type should be used",
			"desc_cn": "应使用具有非 void 返回类型的函数返回的值",
			"abstract": "The value returned by a function which has non-void return type should be used",
			"explanation": "Calling a function without using the return value may be an error for a C90 and a C99 mode. Return value of a function should be cast to the void type if it is intended not to be used explicitly.",
			"abstract_cn": "应使用具有非 void 返回类型的函数返回的值",
			"explanation_cn": "对于 C90 和 C99 模式，不使用返回值调用函数可能是错误的。如果不打算显式使用函数的返回值，则应将其强制转换为 void 类型。",
			"example_good": "///c:\nextern int func_ret_int(int, int);\n\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n, m);\n  }\n  else {\n    (void)func_ret_int(m, m); // func return value ignored\n  }\n}\n",
			"example_bad": "///c:\nextern int func_ret_int(int);\n\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n);\n  }\n  else {\n    func_ret_int(m); // func return value ignored\n  }\n}",
			"details_en": "#### Abstract\nThe value returned by a function which has non-void return type should be used\n\n#### Explanation\nCalling a function without using the return value may be an error for a C90 and a C99 mode. Return value of a function should be cast to the void type if it is intended not to be used explicitly.",
			"details_cn": "#### 概要\n应使用具有非 void 返回类型的函数返回的值\n\n#### 解释\n对于 C90 和 C99 模式，不使用返回值调用函数可能是错误的。如果不打算显式使用函数的返回值，则应将其强制转换为 void 类型。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nextern int func_ret_int(int, int);\n\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n, m);\n  }\n  else {\n    (void)func_ret_int(m, m); // func return value ignored\n  }\n}\n"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nextern int func_ret_int(int);\n\n\nvoid bar(int n, int m)\n{\n  if (n > 0) {\n    n += func_ret_int(n);\n  }\n  else {\n    func_ret_int(m); // func return value ignored\n  }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631687289715"
	},
	{
		"name": "A function parameter should not be modified",
		"code": "MSR_17_8",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a function parameter is modified",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中函数的参数被修改",
			"code": "MSR_17_8",
			"override": "T",
			"master_id": "2059",
			"name": "A function parameter should not be modified",
			"name_cn": "不得修改函数参数",
			"compliance": "A",
			"desc_en": "The parameter of a function should not be modified",
			"desc_cn": "不得修改函数的参数",
			"abstract": "The parameter of a function should not be modified",
			"explanation": "Modifying the parameter of a function can be confusing and in conflict with programmer expectations for C90 and C99 modes. So the The parameter of a function should not be modified.",
			"abstract_cn": "不得修改函数的参数",
			"explanation_cn": "对 C90 和 C99 模式而言，修改函数的参数可能会令人困惑并与程序员的期望相冲突。 所以不能修改函数的参数。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func(int param){\n    // Only use param, do not ever modify it by assigning another value\n    printf(\"%d\\n\", param);\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint param_0 =1;\n\nvoid func(int param){\n    // Modifying parameter can cause confusion\n    param = param_0;\n    printf(\"%d\\n\", param);\n}",
			"details_en": "#### Abstract\nThe parameter of a function should not be modified\n\n#### Explanation\nModifying the parameter of a function can be confusing and in conflict with programmer expectations for C90 and C99 modes. So the The parameter of a function should not be modified.",
			"details_cn": "#### 概要\n不得修改函数的参数\n\n#### 解释\n对 C90 和 C99 模式而言，修改函数的参数可能会令人困惑并与程序员的期望相冲突。 所以不能修改函数的参数。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func(int param){\n    // Only use param, do not ever modify it by assigning another value\n    printf(\"%d\\n\", param);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint param_0 =1;\n\nvoid func(int param){\n    // Modifying parameter can cause confusion\n    param = param_0;\n    printf(\"%d\\n\", param);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1631687330687"
	},
	{
		"name": "char not allowed in arithmetic expression",
		"code": "MSR_10_2",
		"rules": {
			"category": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, char is used in arithmetic expression ${so.func}",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，算术表达式${so.func}中使用了字符",
			"code": "MSR_10_2",
			"isCustom": "F",
			"override": "T",
			"master_id": "2046",
			"name": "char not allowed in arithmetic expression",
			"name_cn": "算术表达式中不允许使用字符",
			"desc_en": "Use basic character variables appropriately for addition and subtraction",
			"desc_cn": "正确使用基本字符型变量进行加减法运算",
			"abstract": "Use basic character variables appropriately for addition and subtraction",
			"explanation": "Since the data in the basic character variable does not represent a numeric value, the basic character variable should be used appropriately in the addition and subtraction expressions.",
			"abstract_cn": "正确使用基本字符型变量进行加减法运算",
			"explanation_cn": "由于基本字符型变量中的数据并不代表数值，在加法和减法表达式中应该正确地使用基本字符型变量。",
			"example_good": "///c:\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    // essentially character type declared\n  char char_var;   \n  char numb;\n  char_var = '9';\n  // convert numa to digit value 9\n  numb = char_var - '0';\n  return numb\n\n}\n",
			"example_bad": "///c:\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    // essentially character type declared\n    char char_var;\n    int numb;\n    char_var = '9';\n    // the result of char_var + '>' do not make sense\n    numb = char_var + '>';\n    return numb;\n\n}",
			"details_en": "#### Abstract\nUse basic character variables appropriately for addition and subtraction\n\n#### Explanation\nSince the data in the basic character variable does not represent a numeric value, the basic character variable should be used appropriately in the addition and subtraction expressions.",
			"details_cn": "#### 概要\n正确使用基本字符型变量进行加减法运算\n\n#### 解释\n由于基本字符型变量中的数据并不代表数值，在加法和减法表达式中应该正确地使用基本字符型变量。",
			"examples": {
				"good": {
					"cpp": "",
					"java": "",
					"c": "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    // essentially character type declared\n  char char_var;   \n  char numb;\n  char_var = '9';\n  // convert numa to digit value 9\n  numb = char_var - '0';\n  return numb\n\n}\n",
					"general": ""
				},
				"bad": {
					"cpp": "",
					"java": "",
					"c": "\n#include <stdio.h>\n\nint func( void );\n\nint func( void )\n{\n    // essentially character type declared\n    char char_var;\n    int numb;\n    char_var = '9';\n    // the result of char_var + '>' do not make sense\n    numb = char_var + '>';\n    return numb;\n\n}",
					"general": ""
				}
			}
		},
		"id": 1631703140264
	},
	{
		"name": "A for loop should be well-formed",
		"code": "MSR_14_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the for loop is not well-formed",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的for循环语句的格式不准确",
			"code": "MSR_14_2",
			"override": "T",
			"master_id": "2060",
			"name": "A for loop should be well-formed",
			"name_cn": "for循环应该是格式良好的",
			"compliance": "R",
			"desc_en": "A loop consists of three clauses. Firstly, a loop counter properly assigned and defined (empty is permissible). Secondly, a loop terminating expression that uses the loop counter, with no persistent side effects. And that expression does not contain objects modified in the loop body. Thirdly, an expression with the loop counter being modified and no other objects used that are modified in the loop body.",
			"desc_cn": "一个循环由三个子句组成。 首先，正确分配和定义一个循环计数器（允许为空）。 其次，使用循环计数器的循环终止表达式，没有持久的副作用。 并且该表达式不包含在循环体中修改的对象。 第三，循环计数器被修改且循环体中没有使用其他被修改的对象的表达式。",
			"abstract": "A for loop should be well-formed",
			"explanation": "The second and third clause of the for loop statement should not use any object that is modified in the for loop body. Using a restricted form of for loop will make code easier to check and review.",
			"abstract_cn": "for循环应该是格式良好的",
			"explanation_cn": "for循环语句的第二个和第三个子句不应使用在 for 循环体中修改的任何对象。 使用限制形式的 for 循环将使代码更容易检查和审查。",
			"example_good": "///c:\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Do something \n    }\n}",
			"example_bad": "///c:\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // modifying the induction variable i. Error prone and hard to review\n        i = i + 4;\n    }\n}",
			"details_en": "#### Abstract\nA for loop should be well-formed\n\n#### Explanation\nThe second and third clause of the for loop statement should not use any object that is modified in the for loop body. Using a restricted form of for loop will make code easier to check and review.",
			"details_cn": "#### 概要\nfor循环应该是格式良好的\n\n#### 解释\nfor循环语句的第二个和第三个子句不应使用在 for 循环体中修改的任何对象。 使用限制形式的 for 循环将使代码更容易检查和审查。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Do something \n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // modifying the induction variable i. Error prone and hard to review\n        i = i + 4;\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1634891188014"
	},
	{
		"name": "Controlling expressions should not be invariant",
		"code": "MSR_14_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} is using an invariant value for controlling expressions",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}的控制表达式不应是不变的",
			"code": "MSR_14_3",
			"override": "T",
			"master_id": "2061",
			"name": "Controlling expressions should not be invariant",
			"name_cn": "控制表达式不应是不变的",
			"compliance": "R",
			"desc_en": "Controlling expression of a statement should not be invariant",
			"desc_cn": "语句的控制表达式不应是不变的",
			"abstract": "Controlling expression of a statement should not be invariant",
			"explanation": "Using invariant values as controlling expresson can cause programming error. The compiler might even remove the code as it may not be able to be reached due to invariant expression. This might result in unwanted removal of defensive code.",
			"abstract_cn": "语句的控制表达式不应是不变的",
			"explanation_cn": "使用不变值作为控制表达式会导致编程错误。 编译器甚至可能会删除代码，因为由于表达式不变，它可能无法访问。 这可能会导致不必要地删除防御性代码。",
			"example_good": "///c:\n#include <stdbool.h>\n\nvoid func() {\n    // Compliant by exception 1\n    while (true) {\n        // Do something\n    } \n\n    // Compliant by exception 2\n    do {\n        // Do something\n    } while (0 == 1);\n}",
			"example_bad": "///c:\nvoid func() {\n    // The if statement always evaluates to false, dead code\n    if (10 > 11) {\n        // Do something\n    }\n}",
			"details_en": "#### Abstract\nControlling expression of a statement should not be invariant\n\n#### Explanation\nUsing invariant values as controlling expresson can cause programming error. The compiler might even remove the code as it may not be able to be reached due to invariant expression. This might result in unwanted removal of defensive code.",
			"details_cn": "#### 概要\n语句的控制表达式不应是不变的\n\n#### 解释\n使用不变值作为控制表达式会导致编程错误。 编译器甚至可能会删除代码，因为由于表达式不变，它可能无法访问。 这可能会导致不必要地删除防御性代码。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdbool.h>\n\nvoid func() {\n    // Compliant by exception 1\n    while (true) {\n        // Do something\n    } \n\n    // Compliant by exception 2\n    do {\n        // Do something\n    } while (0 == 1);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    // The if statement always evaluates to false, dead code\n    if (10 > 11) {\n        // Do something\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1634894787239"
	},
	{
		"name": "The goto statement should not be used",
		"code": "MSR_15_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} uses the goto statement",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用了goto语句",
			"code": "MSR_15_1",
			"override": "T",
			"master_id": "2062",
			"name": "The goto statement should not be used",
			"name_cn": "不应该使用goto语句",
			"compliance": "A",
			"desc_en": "The goto statement should not be used",
			"desc_cn": "不应该使用goto语句",
			"abstract": "The goto statement should not be used",
			"explanation": "Using the goto statement without constraints can lead to unstructured and extremely difficult to understand programs.",
			"abstract_cn": "不应该使用goto语句",
			"explanation_cn": "在没有约束的情况下使用 goto 语句会导致程序无结构化且极难理解。",
			"example_good": "///c:\nvoid func() {\n    int num = 0;\n\n    num += 1;\n    // Do not use the goto statement\n}",
			"example_bad": "///c:\nvoid func() {\n    int num = 0;\n\n    P1:\n    num += 1;\n\n    // Using the goto statement can cause confusion\n    goto P1;\n}",
			"details_en": "#### Abstract\nThe goto statement should not be used\n\n#### Explanation\nUsing the goto statement without constraints can lead to unstructured and extremely difficult to understand programs.",
			"details_cn": "#### 概要\n不应该使用goto语句\n\n#### 解释\n在没有约束的情况下使用 goto 语句会导致程序无结构化且极难理解。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    int num = 0;\n\n    num += 1;\n    // Do not use the goto statement\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    int num = 0;\n\n    P1:\n    num += 1;\n\n    // Using the goto statement can cause confusion\n    goto P1;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1634895371139"
	},
	{
		"name": "The goto statement should jump to a label declared later in the same function",
		"code": "MSR_15_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the goto statement does not jump to a label declared later in the same function",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的goto语句未跳转到稍后在同一函数中声明的标签",
			"code": "MSR_15_2",
			"override": "T",
			"master_id": "2063",
			"name": "The goto statement should jump to a label declared later in the same function",
			"name_cn": "goto语句应跳转到稍后在同一函数中声明的标签",
			"compliance": "R",
			"desc_en": "If a goto statement is really needed, it shall be a forward goto.",
			"desc_cn": "如果确实需要goto语句，则应为forward goto。",
			"abstract": "If a goto statement is really needed, it shall be a forward goto.",
			"explanation": "Since using the goto statement without constraints can lead to unstructured and extremely difficult to understand programs, the use of goto statement should be restricted. Using language provided iteration statement results in much more readable code.",
			"abstract_cn": "如果确实需要goto语句，则应为forward goto。",
			"explanation_cn": "由于使用没有约束的 goto 语句会导致程序非结构化且极难理解，因此应限制使用 goto 语句。 使用语言提供的迭代语句会产生更具可读性的代码。",
			"example_good": "///c:\nvoid func() {\n    int num = 0;\n\n    // No back jump in the code\n    goto P1;\n\n    P1:\n    num += 1;\n}\n",
			"example_bad": "///c:\nvoid func() {\n    int num = 0;\n\n    P1:\n    num += 1;\n\n    // Non-compliant as back jump is allowed\n    goto P1;\n}\n",
			"details_en": "#### Abstract\nIf a goto statement is really needed, it shall be a forward goto.\n\n#### Explanation\nSince using the goto statement without constraints can lead to unstructured and extremely difficult to understand programs, the use of goto statement should be restricted. Using language provided iteration statement results in much more readable code.",
			"details_cn": "#### 概要\n如果确实需要goto语句，则应为forward goto。\n\n#### 解释\n由于使用没有约束的 goto 语句会导致程序非结构化且极难理解，因此应限制使用 goto 语句。 使用语言提供的迭代语句会产生更具可读性的代码。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    int num = 0;\n\n    // No back jump in the code\n    goto P1;\n\n    P1:\n    num += 1;\n}\n"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    int num = 0;\n\n    P1:\n    num += 1;\n\n    // Non-compliant as back jump is allowed\n    goto P1;\n}\n"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635133617722"
	},
	{
		"name": "A goto statement and its label must be in the same scope",
		"code": "MSR_15_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a goto statement and its label are not in the same scope",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}中的goto语句和它的标签不在同一范围内",
			"code": "MSR_15_3",
			"override": "T",
			"master_id": "2064",
			"name": "A goto statement and its label must be in the same scope",
			"name_cn": "goto语句和它的标签必须在同一范围内",
			"compliance": "R",
			"desc_en": "Label should be declared in the same scope as its goto statement.",
			"desc_cn": "标签应在与其goto语句相同的范围内声明。",
			"abstract": "Label should be declared in the same scope as its goto statement.",
			"explanation": "Using the goto statement without constraints can lead to unstructured and extremely difficult to understand programs. Allowing goto statement to jump between blocks or into nested blocks to a reference label make the code visually complex.",
			"abstract_cn": "标签应在与其goto语句相同的范围内声明。",
			"explanation_cn": "在没有约束的情况下使用goto语句会导致程序无结构化且极难理解。 允许goto语句在块之间跳转或在嵌套块中跳转到引用标签使代码在视觉上变得复杂。",
			"example_good": "///c:\nvoid func() {\n    int num = 0;\n\n    P1:\n        if (num == 5) {\n        P2:\n            num += 1;\n        }\n\n    // Jumping into the reference label outside of the nested block\n    goto P1;\n}\n",
			"example_bad": "///c:\nvoid func() {\n    int num = 0;\n\n    P1:\n        if (num == 5) {\n        P2:\n            num += 1;\n        }\n\n    // Jumping into nested label is non-compliant\n    goto P2;\n}",
			"details_en": "#### Abstract\nLabel should be declared in the same scope as its goto statement.\n\n#### Explanation\nUsing the goto statement without constraints can lead to unstructured and extremely difficult to understand programs. Allowing goto statement to jump between blocks or into nested blocks to a reference label make the code visually complex.",
			"details_cn": "#### 概要\n标签应在与其goto语句相同的范围内声明。\n\n#### 解释\n在没有约束的情况下使用goto语句会导致程序无结构化且极难理解。 允许goto语句在块之间跳转或在嵌套块中跳转到引用标签使代码在视觉上变得复杂。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    int num = 0;\n\n    P1:\n        if (num == 5) {\n        P2:\n            num += 1;\n        }\n\n    // Jumping into the reference label outside of the nested block\n    goto P1;\n}\n"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    int num = 0;\n\n    P1:\n        if (num == 5) {\n        P2:\n            num += 1;\n        }\n\n    // Jumping into nested label is non-compliant\n    goto P2;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635133975885"
	},
	{
		"name": "There should not be more than one break or goto for early loop termination",
		"code": "MSR_15_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, loop early exits use both break and goto in the same loop",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}的循环提前退出在同一循环中同时使用了break和goto。",
			"code": "MSR_15_4",
			"override": "T",
			"master_id": "2065",
			"name": "There should not be more than one break or goto for early loop termination",
			"name_cn": "不应该有超过一个 break 或 goto 用于提前终止循环",
			"compliance": "A",
			"desc_en": "There should not be more than one break or goto for early loop termination",
			"desc_cn": "不应该有超过一个 break 或 goto 用于提前终止循环",
			"abstract": "There should not be more than one break or goto for early loop termination",
			"explanation": "Using the goto statement without constraints can lead to unstructured and extremely difficult to understand programs. Restricting the number of exits in a loop helps simplify the source code.",
			"abstract_cn": "不应该有超过一个 break 或 goto 用于提前终止循环",
			"explanation_cn": "在没有约束的情况下使用goto语句会导致程序无结构化且极难理解。 限制循环中的退出次数有助于简化源代码。",
			"example_good": "///c:\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Only use either break or goto, don",
			"example_bad": "///c:\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Multiple early termination\n        if (i == 2) {\n            break;\n        }\n        // Multiple early termination\n        else if (i == 2) {\n            goto EXIT;\n        }\n        else {\n            // Continue\n        }\n    }\n\n    EXIT:\n        ;\n}",
			"details_en": "#### Abstract\nThere should not be more than one break or goto for early loop termination\n\n#### Explanation\nUsing the goto statement without constraints can lead to unstructured and extremely difficult to understand programs. Restricting the number of exits in a loop helps simplify the source code.",
			"details_cn": "#### 概要\n不应该有超过一个 break 或 goto 用于提前终止循环\n\n#### 解释\n在没有约束的情况下使用goto语句会导致程序无结构化且极难理解。 限制循环中的退出次数有助于简化源代码。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Only use either break or goto, don"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    for (int i = 0; i < 5; i++) {\n        // Multiple early termination\n        if (i == 2) {\n            break;\n        }\n        // Multiple early termination\n        else if (i == 2) {\n            goto EXIT;\n        }\n        else {\n            // Continue\n        }\n    }\n\n    EXIT:\n        ;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635134563597"
	},
	{
		"name": "Each if statement in if-else should have an else statement",
		"code": "MSR_15_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} did not end with an else statement.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}的if-else缺少else语句。",
			"code": "MSR_15_7",
			"override": "T",
			"master_id": "2066",
			"name": "Each if statement in if-else should have an else statement",
			"name_cn": "if-else中的每一个if语句都应该有一个else语句",
			"compliance": "R",
			"desc_en": "Each if-else should have an if statement and end with an else statement.",
			"desc_cn": "if-else应包括if语句并以else语句结束。",
			"abstract": "Each if-else should have an if statement and end with an else statement.",
			"explanation": "Using the else statement to terminate the if ... else if constructs complements the requirement for a default clause in a switch statement ad is a kind of defensive programming.",
			"abstract_cn": "if-else应包括if语句并以else语句结束。",
			"explanation_cn": "使用else语句终止if...else if 结构补充了switch语句中对默认子句的要求，这是一种防御性编程。",
			"example_good": "///c:\n#include <stdbool.h>\n\nvoid func() {\n    bool flag;\n\n    if (flag == true) {\n        // Do something\n    }\n    else {\n        // Add else statement as defensive programming\n        // Do something\n    }\n}",
			"example_bad": "///c:\n#include <stdbool.h>\n\nvoid func() {\n    bool flag;\n\n    if (flag == true) {\n        // Do something\n    }\n    else if (flag == false) {\n        // Do something\n    }\n    // Non-compliant as there is no else statement\n}",
			"details_en": "#### Abstract\nEach if-else should have an if statement and end with an else statement.\n\n#### Explanation\nUsing the else statement to terminate the if ... else if constructs complements the requirement for a default clause in a switch statement ad is a kind of defensive programming.",
			"details_cn": "#### 概要\nif-else应包括if语句并以else语句结束。\n\n#### 解释\n使用else语句终止if...else if 结构补充了switch语句中对默认子句的要求，这是一种防御性编程。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdbool.h>\n\nvoid func() {\n    bool flag;\n\n    if (flag == true) {\n        // Do something\n    }\n    else {\n        // Add else statement as defensive programming\n        // Do something\n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdbool.h>\n\nvoid func() {\n    bool flag;\n\n    if (flag == true) {\n        // Do something\n    }\n    else if (flag == false) {\n        // Do something\n    }\n    // Non-compliant as there is no else statement\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635135725160"
	},
	{
		"name": "A default label should appear as either the first or the last switch label of a switch statement",
		"code": "MSR_16_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the default label for the switch statement was not placed in first or last.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，switch语句的默认标签没有放在first或last。",
			"code": "MSR_16_5",
			"override": "T",
			"master_id": "2067",
			"name": "A default label should appear as either the first or the last switch label of a switch statement",
			"name_cn": "默认标签应作为switch语句的第一个或最后一个switch标签出现",
			"compliance": "R",
			"desc_en": "The default label for the switch statement should be placed in first or last.",
			"desc_cn": "switch语句的默认标签没有放在第一个或最后一个位置。",
			"abstract": "The default label for the switch statement is not placed in first or last.",
			"explanation": "Putting the default label anywhere else other than the first or last in a switch statement makes it difficult to locate.",
			"abstract_cn": "switch语句的默认标签没有放在第一个或最后一个位置。",
			"explanation_cn": "将默认标签放在switch语句中的第一个或最后一个以外的任何其他位置会使其难以定位。",
			"example_good": "///c:\nint loop_cnt(int count, int input)\n{\n  int idx = count;\n  \n  switch (input) {\n  case 0:\n    idx--;\n    break;\n    \n  case 1:\n    idx++;\n    break;\n    \n  default:\n    break;\n  }\n  \n  // ...\n  return idx;\n}\n\n\nint loop_cnt_ex2(int count, int input)\n{\n  int idx = count;\n  \n  switch (input) {\n    \n  default:   // default at beginning of switch\n    break;\n    \n  case 0:\n    idx--;\n    break;\n    \n  case 1:\n    idx++;\n    break;\n\n  }\n  \n  // ...\n  return idx;\n}",
			"example_bad": "///c:\nint loop_cnt(int count, int input)\n{\n  int idx = count;\n  \n  switch (input) {\n    \n  case 0:\n    idx--;\n    break;\n    \n  default:  // default in between case statements\n    break;\n    \n  case 1:\n    idx++;\n    break;    \n\n  }\n  \n  // ...\n  return idx;\n}\n\n\nint loop_cnt_ex2(int count, int input)\n{\n  int idx = count;\n  \n  switch (input) {\n    \n  // missing default statement in begin nor end \n    \n  case 0:\n    idx--;\n    break;\n    \n  case 1:\n    idx++;\n    break;\n\n  }\n  \n  // ...\n  return idx;\n}",
			"details_en": "#### Abstract\nThe default label for the switch statement is not placed in first or last.\n\n#### Explanation\nPutting the default label anywhere else other than the first or last in a switch statement makes it difficult to locate.",
			"details_cn": "#### 概要\nswitch语句的默认标签没有放在第一个或最后一个位置。\n\n#### 解释\n将默认标签放在switch语句中的第一个或最后一个以外的任何其他位置会使其难以定位。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nint loop_cnt(int count, int input)\n{\n  int idx = count;\n  \n  switch (input) {\n  case 0:\n    idx--;\n    break;\n    \n  case 1:\n    idx++;\n    break;\n    \n  default:\n    break;\n  }\n  \n  // ...\n  return idx;\n}\n\n\nint loop_cnt_ex2(int count, int input)\n{\n  int idx = count;\n  \n  switch (input) {\n    \n  default:   // default at beginning of switch\n    break;\n    \n  case 0:\n    idx--;\n    break;\n    \n  case 1:\n    idx++;\n    break;\n\n  }\n  \n  // ...\n  return idx;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nint loop_cnt(int count, int input)\n{\n  int idx = count;\n  \n  switch (input) {\n    \n  case 0:\n    idx--;\n    break;\n    \n  default:  // default in between case statements\n    break;\n    \n  case 1:\n    idx++;\n    break;    \n\n  }\n  \n  // ...\n  return idx;\n}\n\n\nint loop_cnt_ex2(int count, int input)\n{\n  int idx = count;\n  \n  switch (input) {\n    \n  // missing default statement in begin nor end \n    \n  case 0:\n    idx--;\n    break;\n    \n  case 1:\n    idx++;\n    break;\n\n  }\n  \n  // ...\n  return idx;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635136242052"
	},
	{
		"name": "A switch-expression should not have essentially Boolean type",
		"code": "MSR_16_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a switch expression was of boolean type.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，switch表达式是布尔类型。",
			"code": "MSR_16_7",
			"override": "T",
			"master_id": "2068",
			"name": "A switch-expression should not have essentially Boolean type",
			"name_cn": "switch表达式不应具有本质上的布尔类型",
			"compliance": "R",
			"desc_en": "A switch expression should not be of boolean type.",
			"desc_cn": "switch表达式不应是布尔类型。",
			"abstract": "A switch expression should not be of boolean type.",
			"explanation": "Although it is possible to implement a switch statement controlling expression with a Boolean, it would be more appropriate to implement the logic with an if-else construct as defined by the standard.",
			"abstract_cn": "switch表达式不应是布尔类型。",
			"explanation_cn": "尽管可以使用布尔值实现switch语句控制表达式，但使用标准定义的if-else构造实现逻辑会更合适。",
			"example_good": "///c:\n#include <stdbool.h>\n#include <stdio.h>\n\nvoid func( int num ) {\n    // If else is more appropriate than switch for controlling expression with boolean\n    if (num == 0) {\n        printf(\"True\");\n    }\n    else {\n        printf(\"default\");\n    }\n}",
			"example_bad": "///c:\n#include <stdbool.h>\n#include <stdio.h>\n\nvoid func() {\n    int num = 0;\n    // Switch with boolean caluse as the controlling expression is redundant\n    switch(num == 0) {\n        case true:\n            printf(\"True case\");\n            break;\n        default:\n            printf(\"default case\");\n            break;\n    }\n}",
			"details_en": "#### Abstract\nA switch expression should not be of boolean type.\n\n#### Explanation\nAlthough it is possible to implement a switch statement controlling expression with a Boolean, it would be more appropriate to implement the logic with an if-else construct as defined by the standard.",
			"details_cn": "#### 概要\nswitch表达式不应是布尔类型。\n\n#### 解释\n尽管可以使用布尔值实现switch语句控制表达式，但使用标准定义的if-else构造实现逻辑会更合适。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdbool.h>\n#include <stdio.h>\n\nvoid func( int num ) {\n    // If else is more appropriate than switch for controlling expression with boolean\n    if (num == 0) {\n        printf(\"True\");\n    }\n    else {\n        printf(\"default\");\n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdbool.h>\n#include <stdio.h>\n\nvoid func() {\n    int num = 0;\n    // Switch with boolean caluse as the controlling expression is redundant\n    switch(num == 0) {\n        case true:\n            printf(\"True case\");\n            break;\n        default:\n            printf(\"default case\");\n            break;\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635136460765"
	},
	{
		"name": "The features of <stdarg.h> should not be used",
		"code": "MSR_17_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func},  features of <stdarg.h> were used.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用了<stdarg.h>的特性。",
			"code": "MSR_17_1",
			"override": "T",
			"master_id": "2069",
			"name": "The features of <stdarg.h> should not be used",
			"name_cn": "不得使用<stdarg.h>的特性",
			"compliance": "R",
			"desc_en": "The features of <stdarg.h> should not be used.",
			"desc_cn": "不能使用<stdarg.h>的特性。",
			"abstract": "The features of <stdarg.h> should not be used.",
			"explanation": "va_list, va_arg, va_start, va_end, and va_copy should never be used. There are many instances of undefined behaviour when the source code are not organized properly causing inconsistency in type or usages.",
			"abstract_cn": "不能使用<stdarg.h>的特性。",
			"explanation_cn": "不应使用va_list、va_arg、va_start、va_end和va_copy。 当源代码没有正确组织导致类型或用法不一致时，有许多未定义行为的实例。",
			"example_good": "///c:\nvoid func(double arg) {\n    double var;\n    \n    // Should not use <stdarg.h> for variable argument processing\n    var = arg;\n}",
			"example_bad": "///c:\n#include <stdarg.h>\n\nvoid func(va_list var_arg) {\n    double var;\n    \n    // Using va_list and va_arg can cause undefined behaviour\n    var = va_arg(var_arg, double);\n}",
			"details_en": "#### Abstract\nThe features of <stdarg.h> should not be used.\n\n#### Explanation\nva_list, va_arg, va_start, va_end, and va_copy should never be used. There are many instances of undefined behaviour when the source code are not organized properly causing inconsistency in type or usages.",
			"details_cn": "#### 概要\n不能使用<stdarg.h>的特性。\n\n#### 解释\n不应使用va_list、va_arg、va_start、va_end和va_copy。 当源代码没有正确组织导致类型或用法不一致时，有许多未定义行为的实例。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func(double arg) {\n    double var;\n    \n    // Should not use <stdarg.h> for variable argument processing\n    var = arg;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdarg.h>\n\nvoid func(va_list var_arg) {\n    double var;\n    \n    // Using va_list and va_arg can cause undefined behaviour\n    var = va_arg(var_arg, double);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635143431884"
	},
	{
		"name": "Functions should not call themselves, either directly or indirectly",
		"code": "MSR_17_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} called itself.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}调用了自身。",
			"code": "MSR_17_2",
			"override": "T",
			"master_id": "2070",
			"name": "Functions should not call themselves, either directly or indirectly",
			"name_cn": "函数不应直接或间接调用自身",
			"compliance": "R",
			"desc_en": "Functions should not call themselves, either directly or indirectly - recursive function (direct or indirect) should not be reused.",
			"desc_cn": "函数不得直接或间接调用自身 - 不得重用递归函数（直接或间接）。",
			"abstract": "Functions should not call themselves, either directly or indirectly - recursive function (direct or indirect) should not be reused.",
			"explanation": "When a function is calling itself, i.e. recursion, it can lead to stack space exhaustion. It is not possible to determine what the worst-case stack usage is before execution.",
			"abstract_cn": "函数不得直接或间接调用自身 - 不得重用递归函数（直接或间接）。",
			"explanation_cn": "当函数调用自身时，即递归，它会导致堆栈空间耗尽。 在执行之前无法确定最坏情况下的堆栈使用情况。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func(int num){\n    // Implement recursion using for loop instead\n    for (int i = num; i == 0; i--){\n        printf(\"%d\\n\", i);\n    }\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func(int num){\n    if (num == 0) {\n        return;\n    }\n\n    printf(\"%d\\n\", num);\n\n    func(num - 1); // Using recursion unless tightly controlled can exceed available stack\n}",
			"details_en": "#### Abstract\nFunctions should not call themselves, either directly or indirectly - recursive function (direct or indirect) should not be reused.\n\n#### Explanation\nWhen a function is calling itself, i.e. recursion, it can lead to stack space exhaustion. It is not possible to determine what the worst-case stack usage is before execution.",
			"details_cn": "#### 概要\n函数不得直接或间接调用自身 - 不得重用递归函数（直接或间接）。\n\n#### 解释\n当函数调用自身时，即递归，它会导致堆栈空间耗尽。 在执行之前无法确定最坏情况下的堆栈使用情况。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func(int num){\n    // Implement recursion using for loop instead\n    for (int i = num; i == 0; i--){\n        printf(\"%d\\n\", i);\n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func(int num){\n    if (num == 0) {\n        return;\n    }\n\n    printf(\"%d\\n\", num);\n\n    func(num - 1); // Using recursion unless tightly controlled can exceed available stack\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635144708325"
	},
	{
		"name": "Parameters of array type should have specified sizes",
		"code": "MSR_17_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, parameters of array type did not have specific sizes.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，数组类型的参数未确定其大小。",
			"code": "MSR_17_5",
			"override": "T",
			"master_id": "2071",
			"name": "Parameters of array type should have specified sizes",
			"name_cn": "数组类型的参数应具有特定大小",
			"compliance": "A",
			"desc_en": "Parameters of array type should have specified sizes.",
			"desc_cn": "数组类型的参数应具有特定大小。",
			"abstract": "Parameters of array type should have specified sizes.",
			"explanation": "Although it is legal in C to pass an array of the unspecified size to a parameter with a specified size, doing so can lead to unexpected behaviour such as array out of bound.",
			"abstract_cn": "数组类型的参数应具有特定大小。",
			"explanation_cn": "尽管在C中将未指定大小的数组传递给具有指定大小的参数是合法的，但这样做会导致意外行为，例如数组越界。",
			"example_good": "///c:\nvoid fun_arr1 (int array[4]) {\n    // Do something\n}\n\nvoid func(int num){\n    int arr[4] = {1, 2, 3, 4};\n\n    // Array size match prototype\n    func_arr1(arr);\n}",
			"example_bad": "///c:\nvoid arr1 (int array[4]) {\n    // Do something\n}\n\nvoid func(int num){\n    int arr[3] = {1, 2, 3};\n\n    // Array size does not match prototype\n    arr1(arr);\n}",
			"details_en": "#### Abstract\nParameters of array type should have specified sizes.\n\n#### Explanation\nAlthough it is legal in C to pass an array of the unspecified size to a parameter with a specified size, doing so can lead to unexpected behaviour such as array out of bound.",
			"details_cn": "#### 概要\n数组类型的参数应具有特定大小。\n\n#### 解释\n尽管在C中将未指定大小的数组传递给具有指定大小的参数是合法的，但这样做会导致意外行为，例如数组越界。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid fun_arr1 (int array[4]) {\n    // Do something\n}\n\nvoid func(int num){\n    int arr[4] = {1, 2, 3, 4};\n\n    // Array size match prototype\n    func_arr1(arr);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid arr1 (int array[4]) {\n    // Do something\n}\n\nvoid func(int num){\n    int arr[3] = {1, 2, 3};\n\n    // Array size does not match prototype\n    arr1(arr);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635145093759"
	},
	{
		"name": "A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand",
		"code": "MSR_18_1",
		"rules": {
			"category": "",
			"mapping": "",
			"misra_c": "",
			"misra_cpp": "",
			"gjb5369": "",
			"gjb8114": "",
			"language": "",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} assessed an undefined location with a pointer that went out of bound.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用了越界的指针评估未定义的位置。",
			"code": "MSR_18_1",
			"override": "T",
			"master_id": "2072",
			"name": "A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand",
			"name_cn": "对指针操作数进行算术运算产生的指针应寻址与该指针操作数相同的数组中的元素",
			"severity": "H",
			"compliance": "R",
			"desc_en": "Pointer arithmetic should not cause an array out of bound access",
			"desc_cn": "指针运算不应导致数组越界访问",
			"abstract": "Pointer arithmetic should not cause an array out of bound access",
			"explanation": "Compilers can only determine at compile time whether an array boundary has been exceeded. No checks are done at run-time for invalid array indexing. Using invalid indexing can cause program to have erroneous behaviour.",
			"abstract_cn": "指针运算不应导致数组越界访问",
			"explanation_cn": "编译器只能在编译时确定是否超出了数组边界。 在运行时不检查无效的数组索引。 使用无效的索引会导致程序出现错误行为。",
			"example_good": "///c:\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to one beyond only, still defined\n    int *p = &arr[3];\n}",
			"example_bad": "///c:\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to two beyond, undefined\n    int *p = &arr[4];\n}",
			"details_en": "#### Abstract\nPointer arithmetic should not cause an array out of bound access\n\n#### Explanation\nCompilers can only determine at compile time whether an array boundary has been exceeded. No checks are done at run-time for invalid array indexing. Using invalid indexing can cause program to have erroneous behaviour.",
			"details_cn": "#### 概要\n指针运算不应导致数组越界访问\n\n#### 解释\n编译器只能在编译时确定是否超出了数组边界。 在运行时不检查无效的数组索引。 使用无效的索引会导致程序出现错误行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to one beyond only, still defined\n    int *p = &arr[3];\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func(){\n    int arr[3] = {0, 1, 2};\n\n    // Points to two beyond, undefined\n    int *p = &arr[4];\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635145609184"
	},
	{
		"name": "The standard header file <tgmath.h> should not be used",
		"code": "MSR_21_11",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} use the standard header file <tgmath.h>",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用标准头文件 <tgmath.h>",
			"code": "MSR_21_11",
			"override": "T",
			"master_id": "2073",
			"name": "The standard header file <tgmath.h> should not be used",
			"name_cn": "不得使用标准头文件 <tgmath.h>",
			"compliance": "R",
			"desc_en": "The standard header file <tgmath.h> should not be used",
			"desc_cn": "不得使用标准头文件 <tgmath.h>",
			"abstract": "The standard header file <tgmath.h> should not be used",
			"explanation": "Since using functions declared in tgmath.h can result in undefined behaviour, <tgmath.h> shall not be used",
			"abstract_cn": "不得使用标准头文件 <tgmath.h>",
			"explanation_cn": "因为使用 tgmath.h 中声明的函数可能会导致未定义的行为，所以不应该使用<tgmath.h>",
			"example_good": "///c:\n#include <math.h>\n\nvoid func() {\n   float f1;\n   // Float version of square root is used, safer\n   f1 = sqrt(49);\n}",
			"example_bad": "///c:\n#include <tgmath.h>\n\nvoid func() {\n   float f1;\n   // Generic square root is used, can cause undefined behaviour\n   f1 = sqrt(49);\n}",
			"details_en": "#### Abstract\nThe standard header file <tgmath.h> should not be used\n\n#### Explanation\nSince using functions declared in tgmath.h can result in undefined behaviour, <tgmath.h> shall not be used",
			"details_cn": "#### 概要\n不得使用标准头文件 <tgmath.h>\n\n#### 解释\n因为使用 tgmath.h 中声明的函数可能会导致未定义的行为，所以不应该使用<tgmath.h>",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <math.h>\n\nvoid func() {\n   float f1;\n   // Float version of square root is used, safer\n   f1 = sqrt(49);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <tgmath.h>\n\nvoid func() {\n   float f1;\n   // Generic square root is used, can cause undefined behaviour\n   f1 = sqrt(49);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635409359459"
	},
	{
		"name": "The exception handling features of <fenv.h> should not be used",
		"code": "MSR_21_12",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} use exception handling features declared in <fenv.h>",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用了 <fenv.h> 中声明的异常处理特性",
			"code": "MSR_21_12",
			"override": "T",
			"master_id": "2074",
			"name": "The exception handling features of <fenv.h> should not be used",
			"name_cn": "不应使用 <fenv.h> 的异常处理功能",
			"compliance": "A",
			"desc_en": "The program used exception handling features declared in <fenv.h>",
			"desc_cn": "程序使用了 <fenv.h> 中声明的异常处理特性",
			"abstract": "The program used exception handling features declared in <fenv.h>",
			"explanation": "The floatin-point status flags may become unspecified in some circumstances. Attempting to access them may cause undefined behaviour. ",
			"abstract_cn": "程序使用了 <fenv.h> 中声明的异常处理特性",
			"explanation_cn": "在某些情况下，浮点状态标志可能变得未指定。 尝试访问它们可能会导致未定义的行为",
			"example_good": "///c:\n#include <fenv.h>\n#include <stdio.h>\n#include <math.h>\n\nvoid func() {\n   // Do not use functions from fenv.h for exception handling\n   sqrt(-1);\n}",
			"example_bad": "///c:\n#include <fenv.h>\n#include <stdio.h>\n#include <math.h>\n\nvoid func() {\n   // Using exception handlinf features can cause undefined behaviour\n   feclearexcept(FE_ALL_EXCEPT);\n   \n   sqrt(-1);\n\n   if (fetestexcept(FE_INVALID)) {\n      printf(\"FE_INVALID casued by sqrt(-1\");\n   }\n}",
			"details_en": "#### Abstract\nThe program used exception handling features declared in <fenv.h>\n\n#### Explanation\nThe floatin-point status flags may become unspecified in some circumstances. Attempting to access them may cause undefined behaviour. ",
			"details_cn": "#### 概要\n程序使用了 <fenv.h> 中声明的异常处理特性\n\n#### 解释\n在某些情况下，浮点状态标志可能变得未指定。 尝试访问它们可能会导致未定义的行为",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <fenv.h>\n#include <stdio.h>\n#include <math.h>\n\nvoid func() {\n   // Do not use functions from fenv.h for exception handling\n   sqrt(-1);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <fenv.h>\n#include <stdio.h>\n#include <math.h>\n\nvoid func() {\n   // Using exception handlinf features can cause undefined behaviour\n   feclearexcept(FE_ALL_EXCEPT);\n   \n   sqrt(-1);\n\n   if (fetestexcept(FE_INVALID)) {\n      printf(\"FE_INVALID casued by sqrt(-1\");\n   }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635410221208"
	},
	{
		"name": "A loop counter should not have essentially floating type",
		"code": "MSR_14_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} use floating point as a loop counter",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}使用了浮点作为循环计数器",
			"code": "MSR_14_1",
			"override": "T",
			"master_id": "2075",
			"name": "A loop counter should not have essentially floating type",
			"name_cn": "循环计数器不应具有本质上的浮动类型",
			"compliance": "R",
			"desc_en": "The program uses floating point as a loop counter which can cause mismatch betweeen expected and actual result.",
			"desc_cn": "该程序使用浮点作为循环计数器，这可能导致预期结果与实际结果不匹配。",
			"abstract": "The program uses floating point as a loop counter which can cause mismatch betweeen expected and actual result.",
			"explanation": "Using a floating point as a loop counter can cause accumulation of rounding errors. This might cause mismatch between the expected number of iterations and the actual number of iterations when the program runs depending on the implementation.",
			"abstract_cn": "该程序使用浮点作为循环计数器，这可能导致预期结果与实际结果不匹配。",
			"explanation_cn": "使用浮点数作为循环计数器会导致舍入误差的累积。 这可能会导致程序运行时预期迭代次数与实际迭代次数不匹配，具体取决于实现。",
			"example_good": "///c:\nvoid func() {\n    // Using int as a loop counter\n    for (int i = 1; i < 10; i++) {\n        // Do something\n    }\n}",
			"example_bad": "///c:\nvoid func() {\n    // Using float as a loop counter can lead to unexpected result\n    for (float f = 0.0f; f < 10.0f; f += 0.1f) {\n        // Do something\n    }\n}",
			"details_en": "#### Abstract\nThe program uses floating point as a loop counter which can cause mismatch betweeen expected and actual result.\n\n#### Explanation\nUsing a floating point as a loop counter can cause accumulation of rounding errors. This might cause mismatch between the expected number of iterations and the actual number of iterations when the program runs depending on the implementation.",
			"details_cn": "#### 概要\n该程序使用浮点作为循环计数器，这可能导致预期结果与实际结果不匹配。\n\n#### 解释\n使用浮点数作为循环计数器会导致舍入误差的累积。 这可能会导致程序运行时预期迭代次数与实际迭代次数不匹配，具体取决于实现。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    // Using int as a loop counter\n    for (int i = 1; i < 10; i++) {\n        // Do something\n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func() {\n    // Using float as a loop counter can lead to unexpected result\n    for (float f = 0.0f; f < 10.0f; f += 0.1f) {\n        // Do something\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635412602072"
	},
	{
		"name": "Every switch statement should have at least two switch-clauses",
		"code": "MSR_16_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "16_6",
			"misra_cpp": "6-4-8",
			"GJB5369": "",
			"GJB8114": "",
			"language": "",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func} have less than two switch-clause",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}有少于两个 switch 子句",
			"code": "MSR_16_6",
			"override": "T",
			"master_id": "2076",
			"name": "Every switch statement should have at least two switch-clauses",
			"name_cn": "每个 switch 语句应至少有两个 switch 子句",
			"compliance": "R",
			"desc_en": "Every switch statement should have more than one switch-clause",
			"desc_cn": "每个 switch 语句应该有多个 switch 子句",
			"abstract": "Every switch statement should have more than one switch-clause",
			"explanation": "Having a single path for a switch statement is not only redundant but also an indicative of programming error.",
			"abstract_cn": "每个 switch 语句应该有多个 switch 子句",
			"explanation_cn": "switch 语句只有一条路径不仅是多余的，而且也是编程错误的指示。",
			"example_good": "///c:\nint func ( char grade )\n{\n    // Switch statement have at least two switch-clauses\n    switch( grade ) \n    {        \n        case 'A':\n            printf( \"great\" );\n            break;\n        case 'B':\n            printf( \"good\" );\n            break;\n        default:\n            printf( \"not so well\" );\n            break;\n    }\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func() {\n    int num = 2;\n    switch(num + 2) {\n        default:\n            // Only one switch-clause\n            printf(\"default case\");\n            break;\n    }\n}",
			"details_en": "#### Abstract\nEvery switch statement should have more than one switch-clause\n\n#### Explanation\nHaving a single path for a switch statement is not only redundant but also an indicative of programming error.",
			"details_cn": "#### 概要\n每个 switch 语句应该有多个 switch 子句\n\n#### 解释\nswitch 语句只有一条路径不仅是多余的，而且也是编程错误的指示。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nint func ( char grade )\n{\n    // Switch statement have at least two switch-clauses\n    switch( grade ) \n    {        \n        case 'A':\n            printf( \"great\" );\n            break;\n        case 'B':\n            printf( \"good\" );\n            break;\n        default:\n            printf( \"not so well\" );\n            break;\n    }\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func() {\n    int num = 2;\n    switch(num + 2) {\n        default:\n            // Only one switch-clause\n            printf(\"default case\");\n            break;\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635474460724"
	},
	{
		"name": "Local variables should be initialized before being read",
		"code": "MSR_9_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, local variables are not initialized before being read",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 局部变量在被读取之前没有初始化",
			"code": "MSR_9_1",
			"override": "T",
			"master_id": "2077",
			"name": "Local variables should be initialized before being read",
			"name_cn": "局部变量在被读取之前应该被初始化",
			"compliance": "M",
			"desc_en": "Local variables should be initialized before being read",
			"desc_cn": "局部变量在被读取之前应该被初始化",
			"abstract": "Local variables should be initialized before being read",
			"explanation": "Objects with static storage duration are automatically initialized to zero unless initialized explicitly. Objects with atutomatic storage duration are not automatically initialized so that they can have indeterminate values.",
			"abstract_cn": "局部变量在被读取之前应该被初始化",
			"explanation_cn": "具有静态存储持续时间的对象会自动初始化为零\n除非显式初始化。 具有自动存储持续时间的对象不会自动初始化，因此它们可能具有不确定的值。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nLocal variables should be initialized before being read\n\n#### Explanation\nObjects with static storage duration are automatically initialized to zero unless initialized explicitly. Objects with atutomatic storage duration are not automatically initialized so that they can have indeterminate values.",
			"details_cn": "#### 概要\n局部变量在被读取之前应该被初始化\n\n#### 解释\n具有静态存储持续时间的对象会自动初始化为零\n除非显式初始化。 具有自动存储持续时间的对象不会自动初始化，因此它们可能具有不确定的值。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1635923801357"
	},
	{
		"name": "Subtraction between pointers should only be applied to pointers that address elements of the same array",
		"code": "MSR_18_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}，pointer subtraction causes an array out of bound access",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，指针减法导致了数组越界访问",
			"code": "MSR_18_2",
			"override": "T",
			"master_id": "2078",
			"name": "Subtraction between pointers should only be applied to pointers that address elements of the same array",
			"name_cn": "指针之间的减法应仅适用于寻址同一数组元素的指针",
			"compliance": "R",
			"desc_en": "Pointer subtraction should not cause access violation, such as array out of bound.",
			"desc_cn": "指针减法不应导致访问冲突，例如数组越界。",
			"abstract": "Pointer subtraction should not cause access violation, such as array out of bound.",
			"explanation": "If pointers do not point to elements of the same array or the element one beyond the end of that array, the subtraction between them is undefined behaviour.",
			"abstract_cn": "指针减法不应导致访问冲突，例如数组越界。",
			"explanation_cn": "如果指针不指向同一数组的元素或超出该数组末尾的元素，则它们之间的减法是未定义的行为。",
			"example_good": "",
			"example_bad": "///c:\n#include <stddef.h>\n\nvoid func()\n{\n    int arr[3] = {0, 1, 2};\n\n    // Points to two beyond\n    int *p1 = &arr[0];\n    int *p2 = &arr[2];\n\n    ptrdiff_t diff;\n    diff = p1 - p2; // undefined\n}",
			"details_en": "#### Abstract\nPointer subtraction should not cause access violation, such as array out of bound.\n\n#### Explanation\nIf pointers do not point to elements of the same array or the element one beyond the end of that array, the subtraction between them is undefined behaviour.",
			"details_cn": "#### 概要\n指针减法不应导致访问冲突，例如数组越界。\n\n#### 解释\n如果指针不指向同一数组的元素或超出该数组末尾的元素，则它们之间的减法是未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stddef.h>\n\nvoid func()\n{\n    int arr[3] = {0, 1, 2};\n\n    // Points to two beyond\n    int *p1 = &arr[0];\n    int *p2 = &arr[2];\n\n    ptrdiff_t diff;\n    diff = p1 - p2; // undefined\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1637137441796"
	},
	{
		"name": "Address of a local variable should not be passed outside of the variable's scope",
		"code": "MSR_18_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, address of a local variable is passed outside of the variable's scope",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，局部变量的地址被传递到变量的作用域之外",
			"code": "MSR_18_6",
			"master_id": "2079",
			"name": "Address of a local variable should not be passed outside of the variable's scope",
			"name_cn": "局部变量的地址不应传递到变量的作用域之外",
			"compliance": "R",
			"desc_en": "Address of a local variable should not be passed outside of the variable's scope",
			"desc_cn": "局部变量的地址不应传递到变量的作用域之外",
			"abstract": "Address of a local variable should not be passed outside of the variable's scope",
			"explanation": "When the lifetime of one object expires, its address becomes indeterminate. Then the use of that inderterminate address would result in undefined behaviour.",
			"abstract_cn": "局部变量的地址不应传递到变量的作用域之外",
			"explanation_cn": "当一个对象的生命周期到期时，其地址变得不确定。因此使用该中间终止地址将导致未定义的行为。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nAddress of a local variable should not be passed outside of the variable's scope\n\n#### Explanation\nWhen the lifetime of one object expires, its address becomes indeterminate. Then the use of that inderterminate address would result in undefined behaviour.",
			"details_cn": "#### 概要\n局部变量的地址不应传递到变量的作用域之外\n\n#### 解释\n当一个对象的生命周期到期时，其地址变得不确定。因此使用该中间终止地址将导致未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1637147737612"
	},
	{
		"name": "All resources obtained dynamically by means of Standard Library functions should be released",
		"code": "MSR_22_1",
		"rules": {
			"category": "",
			"mapping": "",
			"misra_c": "",
			"misra_cpp": "",
			"gjb5369": "",
			"gjb8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}，resources obtained dynamically from Standard library functions are not relaeased.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，通过标准库函数动态获取的资源没有被释放",
			"code": "MSR_22_1",
			"override": "T",
			"master_id": "2080",
			"name": "All resources obtained dynamically by means of Standard Library functions should be released",
			"name_cn": "所有通过标准库函数动态获取的资源都应该被释放",
			"compliance": "R",
			"desc_en": "Resources obtained dynamically from Standard library functions should be relaeased.",
			"desc_cn": "应释放从标准库函数动态获取的资源。",
			"abstract": "Resources obtained dynamically from Standard library functions should be relaeased.",
			"explanation": "It is possible for a failure to occur due to exhaustion of resources if those resources are not explicitly released . Releasing resources as soon as possible reduces the possibility of exhaustion.",
			"abstract_cn": "应释放从标准库函数动态获取的资源。",
			"explanation_cn": "如果没有明确释放这些资源，则可能由于资源耗尽而发生故障。 尽快释放资源可以减少耗尽的可能性。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nResources obtained dynamically from Standard library functions should be relaeased.\n\n#### Explanation\nIt is possible for a failure to occur due to exhaustion of resources if those resources are not explicitly released . Releasing resources as soon as possible reduces the possibility of exhaustion.",
			"details_cn": "#### 概要\n应释放从标准库函数动态获取的资源。\n\n#### 解释\n如果没有明确释放这些资源，则可能由于资源耗尽而发生故障。 尽快释放资源可以减少耗尽的可能性。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1637149414993"
	},
	{
		"name": "A block of memory should only be freed if it was allocated by Standard Library function",
		"code": "MSR_22_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}，a block of memory is freed when it was not allocated by Standard Library function",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，不是由标准库函数分配的内存块被释放",
			"code": "MSR_22_2",
			"override": "T",
			"master_id": "2081",
			"name": "A block of memory should only be freed if it was allocated by Standard Library function",
			"name_cn": "内存块仅当由标准库函数分配时才可以被释放",
			"compliance": "M",
			"desc_en": "A block of memory should only be freed if it was allocated by Standard Library function",
			"desc_cn": "内存块仅当由标准库函数分配时才可以被释放",
			"abstract": "A block of memory should only be freed if it was allocated by Standard Library function",
			"explanation": "It is undefined behavior to freeing non-allocated memory or freeing the same allocated memory more than one time.",
			"abstract_cn": "内存块仅当由标准库函数分配时才可以被释放",
			"explanation_cn": "释放未分配的内存或多次释放相同的分配内存是未定义的行为。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nA block of memory should only be freed if it was allocated by Standard Library function\n\n#### Explanation\nIt is undefined behavior to freeing non-allocated memory or freeing the same allocated memory more than one time.",
			"details_cn": "#### 概要\n内存块仅当由标准库函数分配时才可以被释放\n\n#### 解释\n释放未分配的内存或多次释放相同的分配内存是未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1637151548710"
	},
	{
		"name": "There should be no attempt to write to a stream which has been opened as read-only",
		"code": "MSR_22_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the stream which is opened as read-only is written to.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，以只读方式打开的流被写入。",
			"code": "MSR_22_4",
			"override": "T",
			"master_id": "2082",
			"name": "There should be no attempt to write to a stream which has been opened as read-only",
			"name_cn": "不应尝试写入已以只读方式打开的流",
			"compliance": "M",
			"desc_en": "Read-only stream should not be written to",
			"desc_cn": "不应写入以只读方式打开的流。",
			"abstract": "Read-only stream should not be written to",
			"explanation": "Since the Standard does not specify the behaviour if an attempt is made to write to a read-only stream, writting to a read-only stream is unsafe.",
			"abstract_cn": "不应写入以只读方式打开的流。",
			"explanation_cn": "由于标准没有指定尝试写入只读流时的行为，因此写入只读流是不安全的。",
			"example_good": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    FILE *fp;\n    fp = fopen ( \"test_file\", \"w+\" );\n    fprintf( fp, \"write to a stream\" ); // compliant\n    fclose( fp );\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    FILE *fp;\n    fp = fopen ( \"test_file\", \"r\" );\n    fprintf( fp, \"write to a read-only stream\" ); // non-compliant\n    fclose( fp );\n}",
			"details_en": "#### Abstract\nRead-only stream should not be written to\n\n#### Explanation\nSince the Standard does not specify the behaviour if an attempt is made to write to a read-only stream, writting to a read-only stream is unsafe.",
			"details_cn": "#### 概要\n不应写入以只读方式打开的流。\n\n#### 解释\n由于标准没有指定尝试写入只读流时的行为，因此写入只读流是不安全的。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    FILE *fp;\n    fp = fopen ( \"test_file\", \"w+\" );\n    fprintf( fp, \"write to a stream\" ); // compliant\n    fclose( fp );\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    FILE *fp;\n    fp = fopen ( \"test_file\", \"r\" );\n    fprintf( fp, \"write to a read-only stream\" ); // non-compliant\n    fclose( fp );\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1637198001045"
	},
	{
		"name": "The controlling expression of an if statement and iteration-statement should have Boolean type",
		"code": "MSR_14_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the controlling expression of an if statement does not have Boolean type.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}，if 语句的控制表达式不具有本质上的布尔类型",
			"code": "MSR_14_4",
			"override": "T",
			"master_id": "2084",
			"name": "The controlling expression of an if statement and iteration-statement should have Boolean type",
			"name_cn": "if 语句和迭代语句的控制表达式应该是布尔类型",
			"compliance": "R",
			"desc_en": "The controlling expression of an if or iteration statement should basically be of boolean type",
			"desc_cn": "if 或迭代语句的控制表达式基本上应是布尔类型",
			"abstract": "The controlling expression of an if or iteration statement should basically be of boolean type",
			"explanation": "The controlling expression without basically Boolean type of an if statement or iteration-statement would lead to a weak typing.",
			"abstract_cn": "if 或迭代语句的控制表达式基本上应是布尔类型",
			"explanation_cn": "没有 if 语句或迭代语句的基本布尔类型的控制表达式将导致弱类型。",
			"example_good": "///c:\n#define NULL 0\n\nint foo(int *p_int)\n{\n  int ret = 0;\n  int i;\n  \n  while (p_int != NULL) {   // p_int is a pointer\n      i = *p_int;\n      \n      if (i != 0) {   // i != 0 is a boolean expression\n\tret++;\n      }\n    ret++;\n    p_int--;\n    if (ret > 5)\n    {\n      break;\n    }\n  } \n  return ret;\n}",
			"example_bad": "///c:\nint foo(int *p_int)\n{\n  int ret = 0;\n  int i;\n  \n  while (p_int) {   // p_int is a pointer\n    i = *p_int;\n    \n    if (i) {   // i is int, not boolean\n      ret++;\n    }\n\n    ret++;\n    p_int--;\n  } \n  return ret;\n}",
			"details_en": "#### Abstract\nThe controlling expression of an if or iteration statement should basically be of boolean type\n\n#### Explanation\nThe controlling expression without basically Boolean type of an if statement or iteration-statement would lead to a weak typing.",
			"details_cn": "#### 概要\nif 或迭代语句的控制表达式基本上应是布尔类型\n\n#### 解释\n没有 if 语句或迭代语句的基本布尔类型的控制表达式将导致弱类型。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#define NULL 0\n\nint foo(int *p_int)\n{\n  int ret = 0;\n  int i;\n  \n  while (p_int != NULL) {   // p_int is a pointer\n      i = *p_int;\n      \n      if (i != 0) {   // i != 0 is a boolean expression\n\tret++;\n      }\n    ret++;\n    p_int--;\n    if (ret > 5)\n    {\n      break;\n    }\n  } \n  return ret;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nint foo(int *p_int)\n{\n  int ret = 0;\n  int i;\n  \n  while (p_int) {   // p_int is a pointer\n    i = *p_int;\n    \n    if (i) {   // i is int, not boolean\n      ret++;\n    }\n\n    ret++;\n    p_int--;\n  } \n  return ret;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1640241046699"
	},
	{
		"name": "Flexible array members should not be declared",
		"code": "MSR_18_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the flexible array menbers are declared.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 灵活的数组成员被声明。",
			"code": "MSR_18_7",
			"override": "T",
			"master_id": "2085",
			"name": "Flexible array members should not be declared",
			"name_cn": "不应声明灵活的数组成员",
			"compliance": "R",
			"desc_en": "The program should not declare flexible array members",
			"desc_cn": "程序声明了灵活数组成员",
			"abstract": "Flexible array members should not be declared",
			"explanation": "Since the assignment of a structure that contains a flexible array member to another similar type may behave unexpectedly, flexible array members should not be declared.",
			"abstract_cn": "不应声明灵活的数组成员",
			"explanation_cn": "由于将包含灵活数组成员的结构分配给另一个类似类型可能会出现意外行为，因此不应声明灵活数组成员。",
			"example_good": "///c:\n#include <stdio.h>\n\n// compliant\nstruct Books\n{\n    char    title[20];\n    char    author[10];\n    int     id[5];\n} book;",
			"example_bad": "///c:\n#include <stdio.h>\n\nstruct Books\n{\n    char    title[20];\n    char    author[10];\n    int     id[ ]; // flexible array menber\n} book;",
			"details_en": "#### Abstract\nFlexible array members should not be declared\n\n#### Explanation\nSince the assignment of a structure that contains a flexible array member to another similar type may behave unexpectedly, flexible array members should not be declared.",
			"details_cn": "#### 概要\n不应声明灵活的数组成员\n\n#### 解释\n由于将包含灵活数组成员的结构分配给另一个类似类型可能会出现意外行为，因此不应声明灵活数组成员。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// compliant\nstruct Books\n{\n    char    title[20];\n    char    author[10];\n    int     id[5];\n} book;"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nstruct Books\n{\n    char    title[20];\n    char    author[10];\n    int     id[ ]; // flexible array menber\n} book;"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1640242961884"
	},
	{
		"name": "Type should be clearly specified",
		"code": "MSR_8_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, type is not clearly specified.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 类型没有被明确指定",
			"code": "MSR_8_1",
			"override": "T",
			"master_id": "2086",
			"name": "Type should be clearly specified",
			"name_cn": "类型应该被明确指定",
			"compliance": "R",
			"desc_en": "The program should explicitly specify the types for all objects",
			"desc_cn": "程序应明确指定所有对象的类型",
			"abstract": "The program should explicitly specify the types for all objects",
			"explanation": "If an explicit type is omitted, it may lead to declaration confusion.",
			"abstract_cn": "程序应明确指定所有对象的类型",
			"explanation_cn": "如果省略显式类型，可能会导致声明混淆。",
			"example_good": "///c:\n#include <stdio.h>\n\n// Compliant function type\nextern void g (char a, const int b); // Explicit int type for b\n\n// Compliant object type\nconst int p; // Explicit int type for p",
			"example_bad": "///c:\n#include <stdio.h>\n\n// Non-compliant function type\nextern void g (char a, const b); // Implicit int type for b\n\n// Non-compliant object type\nconst   p; // Implicit int type for p",
			"details_en": "#### Abstract\nThe program should explicitly specify the types for all objects\n\n#### Explanation\nIf an explicit type is omitted, it may lead to declaration confusion.",
			"details_cn": "#### 概要\n程序应明确指定所有对象的类型\n\n#### 解释\n如果省略显式类型，可能会导致声明混淆。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// Compliant function type\nextern void g (char a, const int b); // Explicit int type for b\n\n// Compliant object type\nconst int p; // Explicit int type for p"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// Non-compliant function type\nextern void g (char a, const b); // Implicit int type for b\n\n// Non-compliant object type\nconst   p; // Implicit int type for p"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1640582313779"
	},
	{
		"name": "Conversions should not be performed between a pointer to a function and any other type",
		"code": "MSR_11_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a pointer to a function is converted into other type.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 指向函数的指针被转换为其他类型",
			"code": "MSR_11_1",
			"master_id": "2087",
			"name": "Conversions should not be performed between a pointer to a function and any other type",
			"name_cn": "转换不能在指向函数的指针和指向其他类型的指针中进行",
			"compliance": "R",
			"desc_en": "A pointer to a function should not be converted into any other type",
			"desc_cn": "指向函数的指针不应转换为任何其他类型",
			"abstract": "The program should not convert a pointer to a function into any other type",
			"explanation": " The function which uses an incompatible pointer type should not be called. Otherwise it would lead to undefined behaviour.",
			"abstract_cn": "指向函数的指针不应转换为任何其他类型",
			"explanation_cn": "程序不应调用使用不兼容指针类型的函数。 否则会导致未定义的行为。",
			"example_good": "///c:\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func ( void )\n{\n    typedef void ( *fp ) ( int x );\n    extern void f ( int y );\n    typedef fp ( *test ) ( void );\n\n    fp p = NULL; // null pointer constant into function pointer is compliant\n    fp q = f; // function into function pointer is compliant\n    test tfunc;\n    ( void ) ( *tfunc( ) ); // function pointer into void\n}",
			"example_bad": "///c: \n#include <stdio.h>\n #include <stdlib.h>\n\ntypedef char ( *f1 ) ( int );\ntypedef char ( *f2 ) ( int );\n\nvoid func ( void )\n{\n    int x = 1;\n    int *p = &x;\n    int *q[10];\n    f1 a = ( f1 ) p; // function pointer converted into different one is non-compliant\n    f2 b = ( f2 ) *q; // non-compliant\n    f1 c = ( f1 ) 1; // function pointer converted into int is non-compliant\n}",
			"details_en": "#### Abstract\nThe program should not convert a pointer to a function into any other type\n\n#### Explanation\n The function which uses an incompatible pointer type should not be called. Otherwise it would lead to undefined behaviour.",
			"details_cn": "#### 概要\n指向函数的指针不应转换为任何其他类型\n\n#### 解释\n程序不应调用使用不兼容指针类型的函数。 否则会导致未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid func ( void )\n{\n    typedef void ( *fp ) ( int x );\n    extern void f ( int y );\n    typedef fp ( *test ) ( void );\n\n    fp p = NULL; // null pointer constant into function pointer is compliant\n    fp q = f; // function into function pointer is compliant\n    test tfunc;\n    ( void ) ( *tfunc( ) ); // function pointer into void\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						" \n#include <stdio.h>\n #include <stdlib.h>\n\ntypedef char ( *f1 ) ( int );\ntypedef char ( *f2 ) ( int );\n\nvoid func ( void )\n{\n    int x = 1;\n    int *p = &x;\n    int *q[10];\n    f1 a = ( f1 ) p; // function pointer converted into different one is non-compliant\n    f2 b = ( f2 ) *q; // non-compliant\n    f1 c = ( f1 ) 1; // function pointer converted into int is non-compliant\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1640584157267"
	},
	{
		"name": "The use of a switch label",
		"code": "MSR_16_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the switch label is placed before any statement.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, switch标签放在了任意语句之前",
			"code": "MSR_16_2",
			"override": "T",
			"master_id": "2088",
			"name": "The use of a switch label",
			"name_cn": "switch标签的使用",
			"compliance": "R",
			"desc_en": "switch label should be used at the outermost level of of the compound statement",
			"desc_cn": "switch 标签应该用在复合语句的最外层",
			"abstract": "switch label should be used at the outermost level of of the compound statement",
			"explanation": "Placing the switch label before any statement in the body of a switch statement is unstructured code",
			"abstract_cn": "switch 标签应该用在复合语句的最外层",
			"explanation_cn": "将 switch 标签放在 switch 语句主体中的任何语句之前是非结构化代码",
			"example_good": "///c:\n#include <stdio.h>\n\nint main( int s )\n{\n    switch (s)\n    {\n        case 1: // Compliant\n            printf(\"%d\", 1);\n            break;\n        case 2: // Compliant\n            printf(\"%d\", 2);\n            break;\n        default:\n            break;\n    }\n\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint main()\n{\n    int s, i;\n\n    switch (s)\n    {\n        case 5: // Compliant\n            printf(\"%d\", 5);\n            for( i=0; i<3; i++ )\n            {\n        case 10: // Unstructed code\n            printf(\"%c\", \"s\");\n            }\n            break;\n        default:\n            break;\n    }\n    \n    return 0;\n}",
			"details_en": "#### Abstract\nswitch label should be used at the outermost level of of the compound statement\n\n#### Explanation\nPlacing the switch label before any statement in the body of a switch statement is unstructured code",
			"details_cn": "#### 概要\nswitch 标签应该用在复合语句的最外层\n\n#### 解释\n将 switch 标签放在 switch 语句主体中的任何语句之前是非结构化代码",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint main( int s )\n{\n    switch (s)\n    {\n        case 1: // Compliant\n            printf(\"%d\", 1);\n            break;\n        case 2: // Compliant\n            printf(\"%d\", 2);\n            break;\n        default:\n            break;\n    }\n\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint main()\n{\n    int s, i;\n\n    switch (s)\n    {\n        case 5: // Compliant\n            printf(\"%d\", 5);\n            for( i=0; i<3; i++ )\n            {\n        case 10: // Unstructed code\n            printf(\"%c\", \"s\");\n            }\n            break;\n        default:\n            break;\n    }\n    \n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1640592544247"
	},
	{
		"name": "Every switch statement should have a default label",
		"code": "MSR_16_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the switch statement does not have a default label",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, switch语句没有一个默认标签",
			"code": "MSR_16_4",
			"override": "T",
			"master_id": "2089",
			"name": "Every switch statement should have a default label",
			"name_cn": "每个 switch 语句都应该有一个default标签",
			"compliance": "R",
			"desc_en": "There should be a default label after every switch statement",
			"desc_cn": "每个 switch 语句都应该具有一个default标签",
			"abstract": "There should be a default label after every switch statement",
			"explanation": "The default label makes the programming defensive. And there should be a statement or comment after the default label.",
			"abstract_cn": "每个 switch 语句都应该具有一个default标签",
			"explanation_cn": "默认标签使编程具有防御性。 并且在默认标签之后应该有一个声明或注释。",
			"example_good": "///c:\n#include <stdio.h>\n\nint main( int s )\n{\n    switch (s)\n    {\n        case 10:\n            printf(\"%s\", \"ten\");\n            break;\n        case 20:\n            printf(\"%s\", \"twenty\");\n            break;\n        default: // Compliant\n            break;\n    }\n\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint main( int s )\n{\n    switch (s)\n    {\n        case 10:\n            printf(\"%s\", \"ten\");\n            break;\n        case 20:\n            printf(\"%s\", \"twenty\");\n            break;\n    // default label is missing\n    }\n\n    return 0;\n}",
			"details_en": "#### Abstract\nThere should be a default label after every switch statement\n\n#### Explanation\nThe default label makes the programming defensive. And there should be a statement or comment after the default label.",
			"details_cn": "#### 概要\n每个 switch 语句都应该具有一个default标签\n\n#### 解释\n默认标签使编程具有防御性。 并且在默认标签之后应该有一个声明或注释。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint main( int s )\n{\n    switch (s)\n    {\n        case 10:\n            printf(\"%s\", \"ten\");\n            break;\n        case 20:\n            printf(\"%s\", \"twenty\");\n            break;\n        default: // Compliant\n            break;\n    }\n\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint main( int s )\n{\n    switch (s)\n    {\n        case 10:\n            printf(\"%s\", \"ten\");\n            break;\n        case 20:\n            printf(\"%s\", \"twenty\");\n            break;\n    // default label is missing\n    }\n\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1640663520485"
	},
	{
		"name": "All exit paths for a non-void function should have a return statement",
		"code": "MSR_17_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the return statement does not have an expression for non-void return type function",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 非 void 返回类型函数的return语句没有表达式",
			"code": "MSR_17_4",
			"override": "T",
			"master_id": "2090",
			"name": "All exit paths for a non-void function should have a return statement",
			"name_cn": "具有非 void 返回类型的函数的所有退出路径都应具有return语句",
			"compliance": "M",
			"desc_en": "There should be a return statement expression for non-void function",
			"desc_cn": "非void返回类型函数的应该有return语句表达式",
			"abstract": "There should be a return statement expression for non-void function",
			"explanation": "It is undefined behaviour that the calling function uses the returned value while the non-void function does not return a value. ",
			"abstract_cn": "非void返回类型函数的应该有return语句表达式",
			"explanation_cn": "调用函数使用没有返回值的非空函数是未定义的行为。 ",
			"example_good": "///c:\n#include <stdio.h>\n\nint func ( void )\n{\n    printf(\"Hello\");\n    return 0; // compliant\n}\n\nint main()\n{\n    func(); // compliant\n    return 0;\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\nint func ( int x )\n{\n    for ( ; x < 5; x++){\n        printf(\"less than five\");\n        return 0;\n    }\n    // control may reach end of function without returning\n}\n\nint main()\n{\n    func(10); // undefined behaviour\n    return 0;\n}",
			"details_en": "#### Abstract\nThere should be a return statement expression for non-void function\n\n#### Explanation\nIt is undefined behaviour that the calling function uses the returned value while the non-void function does not return a value. ",
			"details_cn": "#### 概要\n非void返回类型函数的应该有return语句表达式\n\n#### 解释\n调用函数使用没有返回值的非空函数是未定义的行为。 ",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func ( void )\n{\n    printf(\"Hello\");\n    return 0; // compliant\n}\n\nint main()\n{\n    func(); // compliant\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint func ( int x )\n{\n    for ( ; x < 5; x++){\n        printf(\"less than five\");\n        return 0;\n    }\n    // control may reach end of function without returning\n}\n\nint main()\n{\n    func(10); // undefined behaviour\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1640680465159"
	},
	{
		"name": "The declaration of an array parameter should not contain the static keyword between the [ ]",
		"code": "MSR_17_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the declaration of an array parameter contain the static keyword between the [ ]",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 数组参数的声明在 [ ] 之间包含静态关键字",
			"code": "MSR_17_6",
			"override": "T",
			"master_id": "2091",
			"name": "The declaration of an array parameter should not contain the static keyword between the [ ]",
			"name_cn": "数组参数的声明不应在 [ ] 之间包含静态关键字",
			"compliance": "M",
			"desc_en": "There should not be static keyword in the declaration of an array parameter",
			"desc_cn": "数组参数声明中不应有静态关键字",
			"abstract": "There should not be static keyword in the declaration of an array parameter",
			"explanation": "If the number of elements contained by an array parameter is less than the minimum specified, it is undefined behaviour.",
			"abstract_cn": "数组参数声明中不应有静态关键字",
			"explanation_cn": "如果数组参数包含的元素数小于指定的最小值，则为未定义行为。",
			"example_good": "///c:\n#include <stdio.h>\n\n// array parameter declaration without static\nvoid func(int arr[10])\n{\n    for (int i =0; i < 10; i++)\n    {\n        arr[i]++;\n        printf(\"%d\", arr[i]);\n    }\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\n// non-compliant for use of static in array parameter declaration\nvoid func(int arr[static 5])\n{\n    int i = 0;\n    for (int i =0; i < 5; i++)\n    {\n        arr[i]++;\n    }\n}",
			"details_en": "#### Abstract\nThere should not be static keyword in the declaration of an array parameter\n\n#### Explanation\nIf the number of elements contained by an array parameter is less than the minimum specified, it is undefined behaviour.",
			"details_cn": "#### 概要\n数组参数声明中不应有静态关键字\n\n#### 解释\n如果数组参数包含的元素数小于指定的最小值，则为未定义行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// array parameter declaration without static\nvoid func(int arr[10])\n{\n    for (int i =0; i < 10; i++)\n    {\n        arr[i]++;\n        printf(\"%d\", arr[i]);\n    }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// non-compliant for use of static in array parameter declaration\nvoid func(int arr[static 5])\n{\n    int i = 0;\n    for (int i =0; i < 5; i++)\n    {\n        arr[i]++;\n    }\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1640765934414"
	},
	{
		"name": "Declarations should not contain more than two levels of pointer nesting",
		"code": "MSR_18_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the declarations contain more than two levels of pointer nesting",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 声明包含了超过两级的指针嵌套",
			"code": "MSR_18_5",
			"override": "T",
			"master_id": "2092",
			"name": "Declarations should not contain more than two levels of pointer nesting",
			"name_cn": "声明不应包含超过两级的指针嵌套",
			"compliance": "A",
			"desc_en": "There should not be more than two levels of pointer nesting",
			"desc_cn": "声明的指针嵌套不应超过两层",
			"abstract": "There should not be more than two levels of pointer nesting",
			"explanation": "If there are more than two levels of pointer nesting for declaration, it would be confusing to understand the code.",
			"abstract_cn": "声明的指针嵌套不应超过两层",
			"explanation_cn": "如果有两层以上的指针嵌套用于声明，理解代码会很混乱。",
			"example_good": "///c:\n#include <stdio.h>\n\n// compliant for no more than two pointer declarators\nint i = 0;\nint * ip1 = &i;\nint ** ip2 = &ip1;",
			"example_bad": "///c:\n#include <stdio.h>\n\nint i = 0;\nint * ip1 = &i;\nint ** ip2 = &ip1;\n// more than two levels of pointer nesting should be avoided\nint ***ip3 = &ip2;\nint ****ip4 = &ip3;\nint *****ip5 = &ip4;",
			"details_en": "#### Abstract\nThere should not be more than two levels of pointer nesting\n\n#### Explanation\nIf there are more than two levels of pointer nesting for declaration, it would be confusing to understand the code.",
			"details_cn": "#### 概要\n声明的指针嵌套不应超过两层\n\n#### 解释\n如果有两层以上的指针嵌套用于声明，理解代码会很混乱。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// compliant for no more than two pointer declarators\nint i = 0;\nint * ip1 = &i;\nint ** ip2 = &ip1;"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\nint i = 0;\nint * ip1 = &i;\nint ** ip2 = &ip1;\n// more than two levels of pointer nesting should be avoided\nint ***ip3 = &ip2;\nint ****ip4 = &ip3;\nint *****ip5 = &ip4;"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1640770805174"
	},
	{
		"name": "Functions should not be declared at block scope",
		"code": "MSR_3_1_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the functions are declared at block scope",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 函数在块范围内被声明",
			"code": "MSR_3_1_2",
			"override": "T",
			"master_id": "2093",
			"name": "Functions should not be declared at block scope",
			"name_cn": "函数不应在块范围内声明",
			"compliance": "R",
			"desc_en": "There should not be function declaration at block scope",
			"desc_cn": "块范围内不应有函数声明",
			"abstract": "There should not be function declaration at block scope",
			"explanation": "Declaration of a function at block scope would lead to a member of enclosing namespace which is confusing.",
			"abstract_cn": "块范围内不应有函数声明",
			"explanation_cn": "在块范围内声明函数会导致封闭命名空间, 令人困惑。",
			"example_good": "///cpp:\n#include <stdio.h>\n\nvoid func ( int x )\n{\n    x++;\n}\n\nvoid func_out_block(); // function declared out of block",
			"example_bad": "///cpp:\n#include <stdio.h>\n\nvoid func ( int x )\n{\n    x++;\n    void func_in_block(); // function declared in block\n}",
			"details_en": "#### Abstract\nThere should not be function declaration at block scope\n\n#### Explanation\nDeclaration of a function at block scope would lead to a member of enclosing namespace which is confusing.",
			"details_cn": "#### 概要\n块范围内不应有函数声明\n\n#### 解释\n在块范围内声明函数会导致封闭命名空间, 令人困惑。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( int x )\n{\n    x++;\n}\n\nvoid func_out_block(); // function declared out of block"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( int x )\n{\n    x++;\n    void func_in_block(); // function declared in block\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1640857321089"
	},
	{
		"name": "NULL should not be used as an integer",
		"code": "MSR_4_10_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func},  NULL is used as an integer",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, NULL 被用作整数",
			"code": "MSR_4_10_1",
			"override": "T",
			"master_id": "2094",
			"name": "NULL should not be used as an integer",
			"name_cn": "NULL不应该被用作整数",
			"compliance": "R",
			"desc_en": "NULL should not be used as integer",
			"desc_cn": "NULL 不应用作整数",
			"abstract": "NULL should not be used as integer",
			"explanation": "NULL should be considerded to be of pointer type in order to be different from 0.",
			"abstract_cn": "NULL 不应用作整数",
			"explanation_cn": "NULL 应被认为是指针类型，以便与 0 区分。",
			"example_good": "///cpp:\n#include <stdio.h>\n\nvoid func ( int *x )\n{\n    x++;\n}\n\nint main ( )\n{\n    func ( NULL ); // NULL used as an pointer\n    return 0;\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n\nvoid func ( int x )\n{\n    x++;   \n}\n\nint main ( )\n{\n    func ( NULL ); // NULL used as an integer value\n    return 0;\n}",
			"details_en": "#### Abstract\nNULL should not be used as integer\n\n#### Explanation\nNULL should be considerded to be of pointer type in order to be different from 0.",
			"details_cn": "#### 概要\nNULL 不应用作整数\n\n#### 解释\nNULL 应被认为是指针类型，以便与 0 区分。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( int *x )\n{\n    x++;\n}\n\nint main ( )\n{\n    func ( NULL ); // NULL used as an pointer\n    return 0;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( int x )\n{\n    x++;   \n}\n\nint main ( )\n{\n    func ( NULL ); // NULL used as an integer value\n    return 0;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1641882406887"
	},
	{
		"name": "0 should not be used as null-pointer-constant",
		"code": "MSR_4_10_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, 0 is used as null-pointer-constant",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 0 被用作空指针常量",
			"code": "MSR_4_10_2",
			"override": "T",
			"master_id": "2095",
			"name": "0 should not be used as null-pointer-constant",
			"name_cn": "0 不应用作空指针常量",
			"compliance": "R",
			"desc_en": "0 should not be used as null-pointer-constant",
			"desc_cn": "0 不应用作空指针常量",
			"abstract": "0 should not be used as null-pointer-constant",
			"explanation": "0 should be considered to be of integer type in order to be different from NULL",
			"abstract_cn": "0 不应用作空指针常量",
			"explanation_cn": "0 应该被认为是整数类型，以便与 NULL区分",
			"example_good": "///cpp:\n#include <stdio.h>\n\nvoid func ( int x )\n{\n    x++;\n}\n\nint main ( )\n{\n    func ( 0 ); // 0 used as an integer value\n    return 0;\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n\nvoid func ( int *x )\n{\n    x++;   \n}\n\nint main ( )\n{\n    func ( 0 ); // 0 used as an null pointer constant\n    return 0;\n}",
			"details_en": "#### Abstract\n0 should not be used as null-pointer-constant\n\n#### Explanation\n0 should be considered to be of integer type in order to be different from NULL",
			"details_cn": "#### 概要\n0 不应用作空指针常量\n\n#### 解释\n0 应该被认为是整数类型，以便与 NULL区分",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( int x )\n{\n    x++;\n}\n\nint main ( )\n{\n    func ( 0 ); // 0 used as an integer value\n    return 0;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( int *x )\n{\n    x++;   \n}\n\nint main ( )\n{\n    func ( 0 ); // 0 used as an null pointer constant\n    return 0;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1641882994977"
	},
	{
		"name": "Assignment operators should not be used in sub-expressions",
		"code": "MSR_6_2_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, assignment operators are used in sub-expressions",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 赋值运算符在子表达式中使用",
			"code": "MSR_6_2_1",
			"override": "T",
			"master_id": "2096",
			"name": "Assignment operators should not be used in sub-expressions",
			"name_cn": "赋值运算符不应在子表达式中使用",
			"compliance": "R",
			"desc_en": "Assignment should not be used in sub-expressions",
			"desc_cn": "不应在子表达式中使用赋值",
			"abstract": "Assignment should not be used in sub-expressions",
			"explanation": "The assignment used in sub-expression would add side effect to the full expression and make = and == confusing.",
			"abstract_cn": "不应在子表达式中使用赋值",
			"explanation_cn": "子表达式中使用的赋值会给整个表达式增加副作用，并使 = 和 == 混淆。",
			"example_good": "///cpp:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int a,b,c;\n    a = 5;\n    b = 10;\n    c = b; // assignment outside sub-expression\n    if ( c > a )\n    {\n        printf(\"c bigger than a\");\n    }\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int a,b,c;\n    a = 5;\n    b = 10;\n    if ( ( c = b ) > a ) // assignment inside sub-expression\n    {\n        printf(\"c bigger than a\");\n    }\n}",
			"details_en": "#### Abstract\nAssignment should not be used in sub-expressions\n\n#### Explanation\nThe assignment used in sub-expression would add side effect to the full expression and make = and == confusing.",
			"details_cn": "#### 概要\n不应在子表达式中使用赋值\n\n#### 解释\n子表达式中使用的赋值会给整个表达式增加副作用，并使 = 和 == 混淆。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int a,b,c;\n    a = 5;\n    b = 10;\n    c = b; // assignment outside sub-expression\n    if ( c > a )\n    {\n        printf(\"c bigger than a\");\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int a,b,c;\n    a = 5;\n    b = 10;\n    if ( ( c = b ) > a ) // assignment inside sub-expression\n    {\n        printf(\"c bigger than a\");\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1641886236174"
	},
	{
		"name": "The if/else construct should be followed by compound statement(s)",
		"code": "MSR_6_4_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the if construct is not followed by a compound statement",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, if 结构没有伴随着一个复合语句",
			"code": "MSR_6_4_1",
			"master_id": "2097",
			"name": "The if/else construct should be followed by compound statement(s)",
			"name_cn": "if/else 结构后面应该跟复合语句",
			"compliance": "R",
			"desc_en": "The if/else construct should be followed by compound statement(s)",
			"desc_cn": "if/else 结构后面应该跟复合语句",
			"abstract": "The if/else construct should be followed by compound statement(s)",
			"explanation": "An if construct without a compound statement would raise error if the required braces are failed to add when changing a single statement to a multi-statement.",
			"abstract_cn": "if/else 结构后面应该跟复合语句",
			"explanation_cn": "如果在将单个语句更改为多语句时未能添加所需的大括号，则没有复合语句的 if 结构将引发错误。",
			"example_good": "///cpp:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int x, y;\n    x = 5;\n    y = 10;\n    if ( x > y ) // if construct with compound statement\n    {\n        printf(\"x bigger\");\n    }\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int x, y;\n    x = 5;\n    y = 10;\n    if ( x > y ); // if construct without compound statement\n    {\n        x++;\n    }\n}",
			"details_en": "#### Abstract\nThe if/else construct should be followed by compound statement(s)\n\n#### Explanation\nAn if construct without a compound statement would raise error if the required braces are failed to add when changing a single statement to a multi-statement.",
			"details_cn": "#### 概要\nif/else 结构后面应该跟复合语句\n\n#### 解释\n如果在将单个语句更改为多语句时未能添加所需的大括号，则没有复合语句的 if 结构将引发错误。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int x, y;\n    x = 5;\n    y = 10;\n    if ( x > y ) // if construct with compound statement\n    {\n        printf(\"x bigger\");\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int x, y;\n    x = 5;\n    y = 10;\n    if ( x > y ); // if construct without compound statement\n    {\n        x++;\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1641892164972"
	},
	{
		"name": "if loop-counter is not modified by -- or ++, it should only be used as an operand to <=, <, > or >=",
		"code": "MSR_6_5_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, loop-counter is used to != when it is not modified by -- or ++",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 循环计数器被用于 != 当它不是被--或++修改",
			"code": "MSR_6_5_2",
			"master_id": "2098",
			"name": "if loop-counter is not modified by -- or ++, it should only be used as an operand to <=, <, > or >=",
			"name_cn": "如果循环计数器不是被 -- 或 ++ 修改，它只能用作 <=、<、> 或 >= 的操作数",
			"compliance": "R",
			"desc_en": "loop-counter should only be used to <=, <, > or >= when not modified by -- or ++",
			"desc_cn": "循环计数器只能用于 <=、<、> 或 >=，当它不是被 -- 或 ++ 修改时",
			"abstract": "loop-counter should only be used to <=, <, > or >= when not modified by -- or ++",
			"explanation": "If the loop-counter is modified by operator other than -- or ++, the use of == and != would result in infinite loop.",
			"abstract_cn": "循环计数器只能用于 <=、<、> 或 >=，当它不是被 -- 或 ++ 修改时",
			"explanation_cn": "如果循环计数器由 -- 或 ++ 以外的运算符修改，== 和 != 的使用会导致无限循环。",
			"example_good": "///cpp:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int i, j;\n    j = 5;\n    for ( i = 3; i < j; i += 3 ) // compliant\n    {\n        printf(\"i smaller than j\");\n    }\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int i, j;\n    j = 5;\n    for ( i = 3; i != j; i += 3 ) // non-compliant\n    {\n        printf(\"infinite loop\");\n    }\n}",
			"details_en": "#### Abstract\nloop-counter should only be used to <=, <, > or >= when not modified by -- or ++\n\n#### Explanation\nIf the loop-counter is modified by operator other than -- or ++, the use of == and != would result in infinite loop.",
			"details_cn": "#### 概要\n循环计数器只能用于 <=、<、> 或 >=，当它不是被 -- 或 ++ 修改时\n\n#### 解释\n如果循环计数器由 -- 或 ++ 以外的运算符修改，== 和 != 的使用会导致无限循环。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int i, j;\n    j = 5;\n    for ( i = 3; i < j; i += 3 ) // compliant\n    {\n        printf(\"i smaller than j\");\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int i, j;\n    j = 5;\n    for ( i = 3; i != j; i += 3 ) // non-compliant\n    {\n        printf(\"infinite loop\");\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1641957230475"
	},
	{
		"name": "The continue statement should only be used within a well-formed for loop",
		"code": "MSR_6_6_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the continue statement is overused",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, continue 语句被过度使用",
			"code": "MSR_6_6_3",
			"override": "T",
			"master_id": "2099",
			"name": "The continue statement should only be used within a well-formed for loop",
			"name_cn": "continue 语句只能在格式良好的 for 循环中使用",
			"compliance": "R",
			"desc_en": "The continue statement should not be overused",
			"desc_cn": "continue 语句不应该被过度使用",
			"abstract": "The continue statement should not be overused",
			"explanation": "The overuse of the continue statement would make the code unnecessarily complex",
			"abstract_cn": "continue 语句不应该被过度使用",
			"explanation_cn": "过度使用 continue 语句会使代码变得不必要的复杂",
			"example_good": "///cpp:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int j = 2;\n    for ( int i = 10; i < j; i-- )\n    {\n        if ( ( i % j == 0 ) )\n        {\n            printf(\"well-formed\");\n            continue; // finite loop\n        }\n    }\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int j = 3;\n    for ( int i = 5; i > j; i++ )\n    {\n        if ( ( i % j == 0 ) )\n        {\n            printf(\"not well-formed\");\n            continue; // infinite loop\n        }\n    }\n}",
			"details_en": "#### Abstract\nThe continue statement should not be overused\n\n#### Explanation\nThe overuse of the continue statement would make the code unnecessarily complex",
			"details_cn": "#### 概要\ncontinue 语句不应该被过度使用\n\n#### 解释\n过度使用 continue 语句会使代码变得不必要的复杂",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int j = 2;\n    for ( int i = 10; i < j; i-- )\n    {\n        if ( ( i % j == 0 ) )\n        {\n            printf(\"well-formed\");\n            continue; // finite loop\n        }\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    int j = 3;\n    for ( int i = 5; i > j; i++ )\n    {\n        if ( ( i % j == 0 ) )\n        {\n            printf(\"not well-formed\");\n            continue; // infinite loop\n        }\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1641959579255"
	},
	{
		"name": "Function should not return a reference or a pointer to a parameter passed by reference or const reference",
		"code": "MSR_7_5_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, function returns reference parameter as a temporary object",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 函数将引用参数作为临时对象返回 ",
			"code": "MSR_7_5_3",
			"override": "T",
			"master_id": "2100",
			"name": "Function should not return a reference or a pointer to a parameter passed by reference or const reference",
			"name_cn": "函数不应返回引用或指向通过引用或 const 引用传递的参数的指针",
			"compliance": "R",
			"desc_en": "Function should not return reference parameter as a temporary object",
			"desc_cn": "函数不应将引用参数作为临时对象返回",
			"abstract": "Function should not return reference parameter as a temporary object",
			"explanation": "The use of the reference parameter as a temporary object when the function returns is undefined behaviour.",
			"abstract_cn": "函数不应将引用参数作为临时对象返回",
			"explanation_cn": "函数返回时将引用参数用作临时对象是未定义的行为。",
			"example_good": "///cpp:\n#include <stdio.h>\n\nint t;\nint test = 1;\n\nint func( t )\n{   \n    t = test;\n    return t; // compliant\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n\nint & func ( int & test )\n{\n    int & t = test;\n    return t;\n}",
			"details_en": "#### Abstract\nFunction should not return reference parameter as a temporary object\n\n#### Explanation\nThe use of the reference parameter as a temporary object when the function returns is undefined behaviour.",
			"details_cn": "#### 概要\n函数不应将引用参数作为临时对象返回\n\n#### 解释\n函数返回时将引用参数用作临时对象是未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nint t;\nint test = 1;\n\nint func( t )\n{   \n    t = test;\n    return t; // compliant\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\nint & func ( int & test )\n{\n    int & t = test;\n    return t;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1641978050947"
	},
	{
		"name": "A function identifier should be used to call the function or preceded by &",
		"code": "MSR_8_4_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the function identifiers are not used to call the functions or preceded by &",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 函数标识符没有用于调用函数或以 & 开头",
			"code": "MSR_8_4_4",
			"override": "T",
			"master_id": "2101",
			"name": "A function identifier should be used to call the function or preceded by &",
			"name_cn": "函数标识符应用于调用函数或以 & 开头",
			"compliance": "R",
			"desc_en": "Function identifiers should be used to call the functions or preceded by &",
			"desc_cn": "函数标识符应用于调用函数或以 & 开头",
			"abstract": "Function identifiers should be used to call the functions or preceded by &",
			"explanation": "The conversion of function identifier to function pointer may make it unclear between the address of the funtion and the calling of it.",
			"abstract_cn": "函数标识符应用于调用函数或以 & 开头",
			"explanation_cn": "函数标识符到函数指针的转换可能会使函数的地址和函数的调用之间变得不清楚。",
			"example_good": "///cpp:\n#include <stdio.h>\n\nint func ( void )\n{\n    return 0;\n}\n\nint main ( void )\n{\n    if( &func == 0 ) // compliant\n    {\n        func(); // call the function\n        printf(\"the use of func is clear\");\n    }\n    return 0;\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n\nint func ( void )\n{\n    return 0;\n}\n\nint main ( void )\n{\n    if( func == 0 ) // unclear use of func\n    {\n        printf(\"the use of func is not clear\");\n    }\n    return 0;\n}",
			"details_en": "#### Abstract\nFunction identifiers should be used to call the functions or preceded by &\n\n#### Explanation\nThe conversion of function identifier to function pointer may make it unclear between the address of the funtion and the calling of it.",
			"details_cn": "#### 概要\n函数标识符应用于调用函数或以 & 开头\n\n#### 解释\n函数标识符到函数指针的转换可能会使函数的地址和函数的调用之间变得不清楚。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nint func ( void )\n{\n    return 0;\n}\n\nint main ( void )\n{\n    if( &func == 0 ) // compliant\n    {\n        func(); // call the function\n        printf(\"the use of func is clear\");\n    }\n    return 0;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\nint func ( void )\n{\n    return 0;\n}\n\nint main ( void )\n{\n    if( func == 0 ) // unclear use of func\n    {\n        printf(\"the use of func is not clear\");\n    }\n    return 0;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1641980265965"
	},
	{
		"name": "Objects or functions with external linkage should be declared in a header file",
		"code": "A3_3_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, objects or functions with external linkage are not declared in a header file",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 具有外部链接的对象或函数没有在头文件中声明",
			"code": "A3_3_1",
			"override": "T",
			"master_id": "2102",
			"name": "Objects or functions with external linkage should be declared in a header file",
			"name_cn": "具有外部链接的对象或函数应在头文件中声明",
			"compliance": "R",
			"desc_en": "Objects or functions with external linkage should be declared in a header file",
			"desc_cn": "具有外部链接的对象或函数应在头文件中声明",
			"abstract": "Objects or functions with external linkage should be declared in a header file",
			"explanation": "The object and functions without external linkage should be declared in an unnamed namespace or declared static in order to reduce visibility of them.",
			"abstract_cn": "具有外部链接的对象或函数应在头文件中声明",
			"explanation_cn": "没有外部链接的对象和函数应在未命名的命名空间中声明或声明为静态，以降低它们的可见性。",
			"example_good": "///cpp:\n#include <stdio.h>\n#include \"header.h\"\n\nint x = 5;\nstatic int y = 10; // compliant\nvoid func ( void ) // compliant\n{\n    x = 10;\n    y = 5;\n}\n\nstatic int test ( void ) // compliant\n{\n    x = 10;\n    y = 5;\n    return 0;\n}\n",
			"example_bad": "///cpp:\n#include <stdio.h>\n#include \"header.h\"\n\nint x = 5;\nint y = 10; // non-compliant\nint test ( void ) // non-compliant\n{\n    x = 10;\n    y = 5;\n    return 0;\n}",
			"details_en": "#### Abstract\nObjects or functions with external linkage should be declared in a header file\n\n#### Explanation\nThe object and functions without external linkage should be declared in an unnamed namespace or declared static in order to reduce visibility of them.",
			"details_cn": "#### 概要\n具有外部链接的对象或函数应在头文件中声明\n\n#### 解释\n没有外部链接的对象和函数应在未命名的命名空间中声明或声明为静态，以降低它们的可见性。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n#include \"header.h\"\n\nint x = 5;\nstatic int y = 10; // compliant\nvoid func ( void ) // compliant\n{\n    x = 10;\n    y = 5;\n}\n\nstatic int test ( void ) // compliant\n{\n    x = 10;\n    y = 5;\n    return 0;\n}\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n#include \"header.h\"\n\nint x = 5;\nint y = 10; // non-compliant\nint test ( void ) // non-compliant\n{\n    x = 10;\n    y = 5;\n    return 0;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1642059456508"
	},
	{
		"name": "Fixed width integer types should be used in place of the basic numerical types",
		"code": "A3_9_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the basic numerical types are used instead of fixed width integer types",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 使用基本数值类型而不是固定宽度的整数类型",
			"code": "A3_9_1",
			"override": "T",
			"master_id": "2103",
			"name": "Fixed width integer types should be used in place of the basic numerical types",
			"name_cn": "应使用固定宽度整数类型代替基本数值类型",
			"compliance": "R",
			"desc_en": "Fixed width integer types should replace the basic numerical types",
			"desc_cn": "固定宽度整数类型应该替换基本的数值类型",
			"abstract": "Fixed width integer types should replace the basic numerical types",
			"explanation": "Specific length types from <cstdint> should be used to replace basic numerical types of char, int, short, long",
			"abstract_cn": "固定宽度整数类型应该替换基本的数值类型",
			"explanation_cn": "<cstdint> 中的特定长度类型应用于替换 char、int、short、long 的基本数字类型",
			"example_good": "///cpp:\n#include <stdio.h>\n#include <stdint.h>\n\nvoid func ( void )\n{\n    int8_t a = 1; // fixed width integer types\n    int16_t b = 5;\n    int32_t c = 10;\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n#include <stdint.h>\n\nvoid func ( void )\n{\n    int a = 1; // basic numerical types\n    int b = 5;\n    int c = 10;\n}",
			"details_en": "#### Abstract\nFixed width integer types should replace the basic numerical types\n\n#### Explanation\nSpecific length types from <cstdint> should be used to replace basic numerical types of char, int, short, long",
			"details_cn": "#### 概要\n固定宽度整数类型应该替换基本的数值类型\n\n#### 解释\n<cstdint> 中的特定长度类型应用于替换 char、int、short、long 的基本数字类型",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n#include <stdint.h>\n\nvoid func ( void )\n{\n    int8_t a = 1; // fixed width integer types\n    int16_t b = 5;\n    int32_t c = 10;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n#include <stdint.h>\n\nvoid func ( void )\n{\n    int a = 1; // basic numerical types\n    int b = 5;\n    int c = 10;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1642069104490"
	},
	{
		"name": "Identifier with static storage duration should not be reused",
		"code": "A2_11_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, identifiers with static storage duration are reused",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 重复使用具有静态存储持续时间的标识符",
			"code": "A2_11_5",
			"override": "T",
			"master_id": "2104",
			"name": "Identifier with static storage duration should not be reused",
			"name_cn": "不应重复使用具有静态存储持续时间的标识符",
			"compliance": "A",
			"desc_en": "Identifier with static storage duration should not be reused",
			"desc_cn": "不应重复使用具有静态存储持续时间的标识符",
			"abstract": "Identifier with static storage duration should not be reused",
			"explanation": "The reuse of identifier with static storage duration would possibly make unrelated variables incorrectly associted with the same name.",
			"abstract_cn": "不应重复使用具有静态存储持续时间的标识符",
			"explanation_cn": "重复使用具有静态存储持续时间的标识符可能会使不相关的变量错误地与同名相关联。",
			"example_good": "///cpp:\n#include <stdio.h>\n#include <stdint.h>\n\nnamespace TEST1\n{\n    static int a = 1;\n}\n\nnamespace TEST2\n{\n    void func ( void )\n    {\n        int b; // not reused identifier b\n        b++;\n    }\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n#include <stdint.h>\n\nnamespace TEST1\n{\n    static int a = 1;\n}\n\nnamespace TEST2\n{\n    void func ( void )\n    {\n        int a; // reused identifier a\n        a++;\n    }\n}",
			"details_en": "#### Abstract\nIdentifier with static storage duration should not be reused\n\n#### Explanation\nThe reuse of identifier with static storage duration would possibly make unrelated variables incorrectly associted with the same name.",
			"details_cn": "#### 概要\n不应重复使用具有静态存储持续时间的标识符\n\n#### 解释\n重复使用具有静态存储持续时间的标识符可能会使不相关的变量错误地与同名相关联。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n#include <stdint.h>\n\nnamespace TEST1\n{\n    static int a = 1;\n}\n\nnamespace TEST2\n{\n    void func ( void )\n    {\n        int b; // not reused identifier b\n        b++;\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n#include <stdint.h>\n\nnamespace TEST1\n{\n    static int a = 1;\n}\n\nnamespace TEST2\n{\n    void func ( void )\n    {\n        int a; // reused identifier a\n        a++;\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1642136860476"
	},
	{
		"name": "Enumerations should not be used in arthmetic conditions",
		"code": "A4_5_1",
		"rules": {
			"category": "枚举不应用于算术",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, enumerations are used in arthmetic conditions",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 枚举被应用于算术",
			"code": "A4_5_1",
			"override": "T",
			"master_id": "2105",
			"name": "Enumerations should not be used in arthmetic conditions",
			"name_cn": "枚举不应用于算术",
			"compliance": "R",
			"desc_en": "Enumerations should not be used in arthmetic conditions",
			"desc_cn": "枚举不应用于算术",
			"abstract": "Enumerations should not be used in arthmetic conditions",
			"explanation": "Enumerations have implementation-defined representations. Eums can be used as operands only to operators including [ ], =, ==, !=, <, <=, >, >=. ",
			"abstract_cn": "枚举不应用于算术",
			"explanation_cn": "枚举具有实现定义的表示。 Eums 只能用作部分运算符的操作数，包括 [ ]、=、==、!=、<、<=、>、>=。",
			"example_good": "///cpp:\n#include <stdio.h>\n#include <stdint.h>\n\nenum {a, b, c} test;\n\nvoid func ( void )\n{\n    if ( a != b )  // compliant\n    {\n        printf(\"test_1\");\n    }\n    else if ( b <= c ) // compliant\n    {\n        printf(\"test_2\");\n    }\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n#include <stdint.h>\n\nextern void extern_func(char *);\n\nenum {a, b, c} test;\n\nvoid func ( void )\n{\n    if ( ( a + b ) == test ) // non-compliant\n    {\n        extern_func(\"test_1\");\n    }\n    else if ( ( a - c  ) != b ) // non-compliant\n    {\n        extern_func(\"test_2\");\n    }\n}",
			"details_en": "#### Abstract\nEnumerations should not be used in arthmetic conditions\n\n#### Explanation\nEnumerations have implementation-defined representations. Eums can be used as operands only to operators including [ ], =, ==, !=, <, <=, >, >=. ",
			"details_cn": "#### 概要\n枚举不应用于算术\n\n#### 解释\n枚举具有实现定义的表示。 Eums 只能用作部分运算符的操作数，包括 [ ]、=、==、!=、<、<=、>、>=。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n#include <stdint.h>\n\nenum {a, b, c} test;\n\nvoid func ( void )\n{\n    if ( a != b )  // compliant\n    {\n        printf(\"test_1\");\n    }\n    else if ( b <= c ) // compliant\n    {\n        printf(\"test_2\");\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n#include <stdint.h>\n\nextern void extern_func(char *);\n\nenum {a, b, c} test;\n\nvoid func ( void )\n{\n    if ( ( a + b ) == test ) // non-compliant\n    {\n        extern_func(\"test_1\");\n    }\n    else if ( ( a - c  ) != b ) // non-compliant\n    {\n        extern_func(\"test_2\");\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1642139522908"
	},
	{
		"name": "Literal values should not be used apart from type initialization",
		"code": "A5_1_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, literal values are used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 使用了文字值",
			"code": "A5_1_1",
			"override": "T",
			"master_id": "2106",
			"name": "Literal values should not be used apart from type initialization",
			"name_cn": "除了类型初始化之外，不应使用文字值",
			"compliance": "R",
			"desc_en": "Literal values should not be used apart from type initialization",
			"desc_cn": "除了类型初始化之外，不应使用文字值",
			"abstract": "Literal values should not be used apart from type initialization",
			"explanation": "The use of literal value has bad effect on readability and maintainability of the code.",
			"abstract_cn": "除了类型初始化之外，不应使用文字值",
			"explanation_cn": "文字值的使用对代码的可读性和可维护性有不良影响。",
			"example_good": "///cpp:\n#include <stdio.h>\n#include <stdint.h>\n\n#include <stdio.h>\n#include <stdint.h>\n\nvoid function( void )\n{\n    const int max_length = 100;\n    for (int i = 0; i < max_length; i++)\n    {\n        printf(\"avoid magic numbers\"); // compliant\n    }\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n#include <stdint.h>\n#include <iostream>\n\nvoid function( void )\n{\n  for (int32_t i = 0; i < 100; i++)  // non-compliant\n    {\n      printf(\"magic number for 100\"); // compliant by exception\n      std::cout << \"magic number\" << i << '\\n'; // compliant by exception\n    }\n}",
			"details_en": "#### Abstract\nLiteral values should not be used apart from type initialization\n\n#### Explanation\nThe use of literal value has bad effect on readability and maintainability of the code.",
			"details_cn": "#### 概要\n除了类型初始化之外，不应使用文字值\n\n#### 解释\n文字值的使用对代码的可读性和可维护性有不良影响。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n#include <stdint.h>\n\n#include <stdio.h>\n#include <stdint.h>\n\nvoid function( void )\n{\n    const int max_length = 100;\n    for (int i = 0; i < max_length; i++)\n    {\n        printf(\"avoid magic numbers\"); // compliant\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n#include <stdint.h>\n#include <iostream>\n\nvoid function( void )\n{\n  for (int32_t i = 0; i < 100; i++)  // non-compliant\n    {\n      printf(\"magic number for 100\"); // compliant by exception\n      std::cout << \"magic number\" << i << '\\n'; // compliant by exception\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1642396759699"
	},
	{
		"name": "Trigraphs should not be used",
		"code": "MSR_4_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, trigraph is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 三元组被使用了",
			"code": "MSR_4_2",
			"override": "T",
			"master_id": "2107",
			"name": "Trigraphs should not be used",
			"name_cn": "不应该使用三元组",
			"compliance": "A",
			"desc_en": "Trigraphs should not be used",
			"desc_cn": "不应该使用三元组",
			"abstract": "Trigraphs should not be used",
			"explanation": "The use of trigraphs can cause accidental confusion with other two question marks.",
			"abstract_cn": "不应该使用三元组",
			"explanation_cn": "三元组的使用可能会导致与其他两个问号的意外混淆。",
			"example_good": "///c:\n#include <stdio.h>\n\n#define NON_TRG_STR \"NON-Trigraph string\"\n\nint foo()\n{\n  printf(\"This example uses %s\", NON_TRG_STR); // trigraph is not used\n  return 0;\n}",
			"example_bad": "///c:\nextern void prints(char *, char *);\n\n// trigraph is used\nchar TRG_STR[] = \"[??)\"; // \"??)\" represents \"]\"\n\nint foo()\n{\n  prints(\"This example uses %s\", TRG_STR);\n  return 0;\n}",
			"details_en": "#### Abstract\nTrigraphs should not be used\n\n#### Explanation\nThe use of trigraphs can cause accidental confusion with other two question marks.",
			"details_cn": "#### 概要\n不应该使用三元组\n\n#### 解释\n三元组的使用可能会导致与其他两个问号的意外混淆。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n#define NON_TRG_STR \"NON-Trigraph string\"\n\nint foo()\n{\n  printf(\"This example uses %s\", NON_TRG_STR); // trigraph is not used\n  return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nextern void prints(char *, char *);\n\n// trigraph is used\nchar TRG_STR[] = \"[??)\"; // \"??)\" represents \"]\"\n\nint foo()\n{\n  prints(\"This example uses %s\", TRG_STR);\n  return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1643967281788"
	},
	{
		"name": "Macro identifiers should be unique",
		"code": "MSR_5_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, macro identifiers are not unique",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 宏标识符不是唯一的",
			"code": "MSR_5_4",
			"override": "T",
			"master_id": "2108",
			"name": "Macro identifiers should be unique",
			"name_cn": "宏标识符应该是唯一的",
			"compliance": "R",
			"desc_en": "Macro identifiers should be unique",
			"desc_cn": "宏标识符应该是唯一的",
			"abstract": "Macro identifiers should be unique",
			"explanation": "It is undefined behavior that macro identifiers are different only in non-significant characters.",
			"abstract_cn": "宏标识符应该是唯一的",
			"explanation_cn": "宏标识符仅在非有效字符中不同是未定义的行为。",
			"example_good": "///c:\n#include <stdio.h>\n\n#define VERY_VERY_LONG_NAME_FST 10\n\n#define VERY_VERY_LONG_NAME_SEC 20 // compliant\n\nint main()\n{\n  int i;\n  if (VERY_VERY_LONG_NAME_FST == VERY_VERY_LONG_NAME_SEC) {\n    i = 0;\n  }\n  else {\n    i = 1;\n  }\n  printf(\"i = %d\\n\", i);\n}",
			"example_bad": "///c:\n#include <stdio.h>\n\n/*\n this example does not guarantee the same result for\n different compilers with std C90 or before\n*/\n\n#define VERY_VERY_LONG_NAME2123456789312   10\n\n#define VERY_VERY_LONG_NAME21234567893123  20\n\nint main()\n{\n  int i;\n  if (VERY_VERY_LONG_NAME2123456789312 == VERY_VERY_LONG_NAME21234567893123) {\n    i = 0;\n  }\n  else {\n    i = 1;\n  }\n  printf(\"i = %d\\n\", i);\n}",
			"details_en": "#### Abstract\nMacro identifiers should be unique\n\n#### Explanation\nIt is undefined behavior that macro identifiers are different only in non-significant characters.",
			"details_cn": "#### 概要\n宏标识符应该是唯一的\n\n#### 解释\n宏标识符仅在非有效字符中不同是未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n#define VERY_VERY_LONG_NAME_FST 10\n\n#define VERY_VERY_LONG_NAME_SEC 20 // compliant\n\nint main()\n{\n  int i;\n  if (VERY_VERY_LONG_NAME_FST == VERY_VERY_LONG_NAME_SEC) {\n    i = 0;\n  }\n  else {\n    i = 1;\n  }\n  printf(\"i = %d\\n\", i);\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n/*\n this example does not guarantee the same result for\n different compilers with std C90 or before\n*/\n\n#define VERY_VERY_LONG_NAME2123456789312   10\n\n#define VERY_VERY_LONG_NAME21234567893123  20\n\nint main()\n{\n  int i;\n  if (VERY_VERY_LONG_NAME2123456789312 == VERY_VERY_LONG_NAME21234567893123) {\n    i = 0;\n  }\n  else {\n    i = 1;\n  }\n  printf(\"i = %d\\n\", i);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1643969876985"
	},
	{
		"name": "identifiers should be different from macro names",
		"code": "MSR_5_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, macro names are the same as identifiers",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 宏名称与标识符相同",
			"code": "MSR_5_5",
			"override": "T",
			"master_id": "2109",
			"name": "identifiers should be different from macro names",
			"name_cn": "标识符应该不同于宏名称",
			"compliance": "R",
			"desc_en": "Macro names should not be the same as identifiers in a program",
			"desc_cn": "宏名称不应与程序中的标识符相同",
			"abstract": "Macro names should not be the same as identifiers in a program",
			"explanation": "If the macro names are the same as identifiers, it would raise confusion.",
			"abstract_cn": "宏名称不应与程序中的标识符相同",
			"explanation_cn": "如果宏名称与标识符相同，则会引起混淆。",
			"example_good": "///c:\n#include <stdio.h>\n\n/*\n this example does not guarantee the same result for\n different compilers with std C90 or before\n*/\n\n#define VERY_VERY_LONG_NAME   10\n\nint     VERY_VERY_LONG_NAME_test;  // compliant",
			"example_bad": "///c:\n#include <string.h>\n\nextern int Both_Macro_and_Var_name(int, int);\n \n// this example will get compilation error\n#define Both_Macro_and_Var_name(a, b) ((a) * (b))\n\nint foo(int j) {\n  int i = 5;\n  i = Both_Macro_and_Var_name(i, j);\n  return i;\n}",
			"details_en": "#### Abstract\nMacro names should not be the same as identifiers in a program\n\n#### Explanation\nIf the macro names are the same as identifiers, it would raise confusion.",
			"details_cn": "#### 概要\n宏名称不应与程序中的标识符相同\n\n#### 解释\n如果宏名称与标识符相同，则会引起混淆。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n/*\n this example does not guarantee the same result for\n different compilers with std C90 or before\n*/\n\n#define VERY_VERY_LONG_NAME   10\n\nint     VERY_VERY_LONG_NAME_test;  // compliant"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <string.h>\n\nextern int Both_Macro_and_Var_name(int, int);\n \n// this example will get compilation error\n#define Both_Macro_and_Var_name(a, b) ((a) * (b))\n\nint foo(int j) {\n  int i = 5;\n  i = Both_Macro_and_Var_name(i, j);\n  return i;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1644225723110"
	},
	{
		"name": "Function types should be in prototype form with named parameters",
		"code": "MSR_8_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, function types are not in prototype form with named parameters",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 函数类型不是带有命名参数的原型形式",
			"code": "MSR_8_2",
			"override": "T",
			"master_id": "2110",
			"name": "Function types should be in prototype form with named parameters",
			"name_cn": "函数类型应该是带有命名参数的原型形式",
			"compliance": "R",
			"desc_en": "Function declaration should be in prototype form and parameters in prototype should be named",
			"desc_cn": "函数声明应为原型形式，原型中的参数应命名",
			"abstract": "Function declaration should be in prototype form and parameters in prototype should be named",
			"explanation": "The specification of parameter types and function types help avoid undefined behaviors.",
			"abstract_cn": "函数声明应为原型形式，原型中的参数应命名",
			"explanation_cn": "参数类型和函数类型的规范有助于避免未定义的行为。",
			"example_good": "///c:\n\nextern int functionX(int, char *);  /* parameters without name */\n\nint foo(int a1, char *c2)\n{\n  int i = functionX(a1, c2);\n  if (i != 0)\n    return i;\n  return -1;\n}\n\n\nint bar(int b1, char *b2)    /* declaration in prototype form */\n{\n  int i = functionX(b1, b2);\n  if (i != 0)\n    return i;\n  else\n    return -1;\n}\n",
			"example_bad": "///c:\n\nextern int functionX(int, char *);  /* parameters without name */\n\nint foo(int a1, char *c2)\n{\n  int i = functionX(a1, c2);\n  if (i != 0)\n    return i;\n  return -1;\n}\n\n\nint bar(b1, b2)\nint b1;\nchar *b2;\n{\n  int i = functionX(b1, b2);\n  if (i != 0)\n    return i;\n  else\n    return -1;\n}\n",
			"details_en": "#### Abstract\nFunction declaration should be in prototype form and parameters in prototype should be named\n\n#### Explanation\nThe specification of parameter types and function types help avoid undefined behaviors.",
			"details_cn": "#### 概要\n函数声明应为原型形式，原型中的参数应命名\n\n#### 解释\n参数类型和函数类型的规范有助于避免未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n\nextern int functionX(int, char *);  /* parameters without name */\n\nint foo(int a1, char *c2)\n{\n  int i = functionX(a1, c2);\n  if (i != 0)\n    return i;\n  return -1;\n}\n\n\nint bar(int b1, char *b2)    /* declaration in prototype form */\n{\n  int i = functionX(b1, b2);\n  if (i != 0)\n    return i;\n  else\n    return -1;\n}\n"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n\nextern int functionX(int, char *);  /* parameters without name */\n\nint foo(int a1, char *c2)\n{\n  int i = functionX(a1, c2);\n  if (i != 0)\n    return i;\n  return -1;\n}\n\n\nint bar(b1, b2)\nint b1;\nchar *b2;\n{\n  int i = functionX(b1, b2);\n  if (i != 0)\n    return i;\n  else\n    return -1;\n}\n"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1644232308998"
	},
	{
		"name": "The body of iteration or selection statements should be compound-statements",
		"code": "MSR_15_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the body of iterative or selection statements are not compound-statements",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 迭代或选择语句的主体不是复合语句",
			"code": "MSR_15_6",
			"override": "T",
			"master_id": "2111",
			"name": "The body of iteration or selection statements should be compound-statements",
			"name_cn": "迭代或选择语句的主体应该是复合语句",
			"compliance": "R",
			"desc_en": "The body of iterative or selection statements should be inside a compound statement",
			"desc_cn": "迭代或选择语句的主体应该在复合语句中",
			"abstract": "The body of iterative or selection statements should be inside a compound statement",
			"explanation": "The use of compound-statement could clearify which statements form the body of iterative or selection statements.",
			"abstract_cn": "迭代或选择语句的主体应该在复合语句中",
			"explanation_cn": "复合语句的使用可以明确哪些语句构成了迭代或选择语句的主体。",
			"example_good": "///c:\nint foo(int i)\n{\n  int ret = i;\n  \n  if (i == 0) {\n    return i++;\n  }\n  else if (i < 0) {\n    return -i;\n  }\n  else {\n    ; // empty else\n  }\n\n  // loop with compound statement\n  while (ret < 0) {\n    ret++;\n  }\n  return ret;\n}",
			"example_bad": "///c:\nint foo(int i)\n{\n  int ret = i;\n  \n  if (i == 0)  // conditional with non-compound statement\n    return i++;\n  else if (i < 0) \n    return -i;\n  else \n    ; // empty else\n\n\n  // loop with one non compound statement in body\n  while (i != 0) \n    ret--;\n  \n  return ret;\n}",
			"details_en": "#### Abstract\nThe body of iterative or selection statements should be inside a compound statement\n\n#### Explanation\nThe use of compound-statement could clearify which statements form the body of iterative or selection statements.",
			"details_cn": "#### 概要\n迭代或选择语句的主体应该在复合语句中\n\n#### 解释\n复合语句的使用可以明确哪些语句构成了迭代或选择语句的主体。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nint foo(int i)\n{\n  int ret = i;\n  \n  if (i == 0) {\n    return i++;\n  }\n  else if (i < 0) {\n    return -i;\n  }\n  else {\n    ; // empty else\n  }\n\n  // loop with compound statement\n  while (ret < 0) {\n    ret++;\n  }\n  return ret;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nint foo(int i)\n{\n  int ret = i;\n  \n  if (i == 0)  // conditional with non-compound statement\n    return i++;\n  else if (i < 0) \n    return -i;\n  else \n    ; // empty else\n\n\n  // loop with one non compound statement in body\n  while (i != 0) \n    ret--;\n  \n  return ret;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1644232626852"
	},
	{
		"name": "All switch statement should have a terminating break statement",
		"code": "MSR_16_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, switch statements do not have terminating break statements",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, switch 语句没有终止的break 语句",
			"code": "MSR_16_3",
			"override": "T",
			"master_id": "2112",
			"name": "All switch statement should have a terminating break statement",
			"name_cn": "所有 switch 语句都应该有一个终止 break 语句",
			"compliance": "R",
			"desc_en": "All switch statement should have a terminating break statement",
			"desc_cn": "所有 switch 语句都应该有一个终止 break 语句",
			"abstract": "All switch statement should have a terminating break statement",
			"explanation": "The switch-clause without a break statement may fall into switch-clause which are added later.",
			"abstract_cn": "所有 switch 语句都应该有一个终止 break 语句",
			"explanation_cn": "没有 break 语句的 switch 子句可能会归属于随后添加的 switch 子句。",
			"example_good": "///c:\nint loop_cnt(int count, int input)\n{\n  int idx = count;\n  int ret = 0;\n  \n  switch (input) {\n  case 0:\n    idx--;\n    ret++;\n    break;\n    \n  case 1:\n    idx++;\n    ret++;\n    break;\n    \n  default:   // default with a break statement\n    break;\n  }\n  \n  // ...\n  return ret;\n}",
			"example_bad": "///c:\nint loop_cnt_ex2(int count, int input)\n{\n  int idx = count;\n  int ret = 0;\n  \n  switch (input) {\n    \n  default:   // default at beginning of switch\n    \n  case 0:\n    idx--;\n    break;\n    \n  case 1:    // this case at end of switch has no break\n    idx++;\n\n  }\n  \n  // ...\n  return ret;\n}",
			"details_en": "#### Abstract\nAll switch statement should have a terminating break statement\n\n#### Explanation\nThe switch-clause without a break statement may fall into switch-clause which are added later.",
			"details_cn": "#### 概要\n所有 switch 语句都应该有一个终止 break 语句\n\n#### 解释\n没有 break 语句的 switch 子句可能会归属于随后添加的 switch 子句。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nint loop_cnt(int count, int input)\n{\n  int idx = count;\n  int ret = 0;\n  \n  switch (input) {\n  case 0:\n    idx--;\n    ret++;\n    break;\n    \n  case 1:\n    idx++;\n    ret++;\n    break;\n    \n  default:   // default with a break statement\n    break;\n  }\n  \n  // ...\n  return ret;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nint loop_cnt_ex2(int count, int input)\n{\n  int idx = count;\n  int ret = 0;\n  \n  switch (input) {\n    \n  default:   // default at beginning of switch\n    \n  case 0:\n    idx--;\n    break;\n    \n  case 1:    // this case at end of switch has no break\n    idx++;\n\n  }\n  \n  // ...\n  return ret;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1644234460940"
	},
	{
		"name": "There should not be exception object of pointer type",
		"code": "MSR_15_0_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a exception object has pointer type",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 一个异常对象具有指针类型",
			"code": "MSR_15_0_2",
			"override": "T",
			"master_id": "2113",
			"name": "There should not be exception object of pointer type",
			"name_cn": "不应有指针类型的异常对象",
			"compliance": "A",
			"desc_en": "There should not be exception object of pointer type",
			"desc_cn": "不应有指针类型的异常对象",
			"abstract": "There should not be exception object of pointer type",
			"explanation": "It is unclear which function should destroy the exception object if it has pointer type and refers to a dynamically created object.",
			"abstract_cn": "不应有指针类型的异常对象",
			"explanation_cn": "如果异常对象具有指针类型并引用动态创建的对象，则不清楚哪个函数应该销毁异常对象。",
			"example_good": "///cpp:\nclass A {\npublic:\n  A(void) {}\n  A(const A &b) {\n    // ...\n  }\n  A(int) {}\n\n  int Priv_int() const { return priv_int; }\nprivate:\n  static int priv_int;\n};\n\nvoid foo(int i)\n{\n  A varA;\n  // local is dynamically created with local scope\n  A *local = new A;\n  \n  if (varA.Priv_int() == 0) {\n    throw(varA);    // varA is not address\n  }\n  else {\n    int l = local->Priv_int();\n    delete local;\n    throw(l); // return value copy of local's content, no heap address exposed\n  }\n}",
			"example_bad": "///cpp:\n\nclass A {\npublic:\n  A(void) {}\n  A(const A &b) {\n    // ...\n  }\n  A(int) {}\n\n  int Priv_int() const { return priv_int; }\nprivate:\n  static int priv_int;\n};\n\nvoid foo(int i)\n{\n  A varA;\n  // local is dynamically created with local scope\n  A *local = new A;\n  \n  if (varA.Priv_int() < 0) {\n    throw(&varA);  // addr of local exposed (stack address)\n  }\n  else {\n    throw(local);  // this could cause a heap object not properly deleted\n  }\n}\n",
			"details_en": "#### Abstract\nThere should not be exception object of pointer type\n\n#### Explanation\nIt is unclear which function should destroy the exception object if it has pointer type and refers to a dynamically created object.",
			"details_cn": "#### 概要\n不应有指针类型的异常对象\n\n#### 解释\n如果异常对象具有指针类型并引用动态创建的对象，则不清楚哪个函数应该销毁异常对象。",
			"examples": {
				"good": {
					"cpp": [
						"\nclass A {\npublic:\n  A(void) {}\n  A(const A &b) {\n    // ...\n  }\n  A(int) {}\n\n  int Priv_int() const { return priv_int; }\nprivate:\n  static int priv_int;\n};\n\nvoid foo(int i)\n{\n  A varA;\n  // local is dynamically created with local scope\n  A *local = new A;\n  \n  if (varA.Priv_int() == 0) {\n    throw(varA);    // varA is not address\n  }\n  else {\n    int l = local->Priv_int();\n    delete local;\n    throw(l); // return value copy of local's content, no heap address exposed\n  }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n\nclass A {\npublic:\n  A(void) {}\n  A(const A &b) {\n    // ...\n  }\n  A(int) {}\n\n  int Priv_int() const { return priv_int; }\nprivate:\n  static int priv_int;\n};\n\nvoid foo(int i)\n{\n  A varA;\n  // local is dynamically created with local scope\n  A *local = new A;\n  \n  if (varA.Priv_int() < 0) {\n    throw(&varA);  // addr of local exposed (stack address)\n  }\n  else {\n    throw(local);  // this could cause a heap object not properly deleted\n  }\n}\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1644290497905"
	},
	{
		"name": "When constructing an exception object, an exception should not be thrown",
		"code": "MSR_15_1_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, an exception is thrown when constructing an exception object",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 构造异常对象时抛出了一个异常",
			"code": "MSR_15_1_1",
			"override": "T",
			"master_id": "2114",
			"name": "When constructing an exception object, an exception should not be thrown",
			"name_cn": "构造异常对象时，不应抛出异常",
			"compliance": "R",
			"desc_en": "When constructing an exception object, an exception should not be thrown",
			"desc_cn": "构造异常对象时，不应抛出异常",
			"abstract": "When constructing an exception object, an exception should not be thrown",
			"explanation": "If an exception is thrown during the construction of an exception object, it propagates in preference to the one about to be thrown, which may be out of expectation.",
			"abstract_cn": "构造异常对象时，不应抛出异常",
			"explanation_cn": "如果在构造异常对象的过程中抛出了异常，则该异常会优先于将要抛出的异常传播，这可能是出乎意料的。",
			"example_good": "///cpp:\n#include <iostream>\n\nusing namespace std;\n\nclass MyException\n{\n  public:\n    MyException ()\n    {\n      cout << \"constructor does not cause exception\" << endl; // compliant\n    }\n};\n\nvoid func ( int n ) throw (int, MyException)\n{\n  if ( n == 1 )\n  {\n    throw 1;\n  }\n  else\n  {\n    throw MyException();\n  }\n}\n\nint main( void )\n{\n  try\n  {\n    func(2);\n  }\n\n  catch ( int n )\n  {\n    cout << \"catch int ...\" << endl;\n  }\n  catch (MyException)\n  {\n    cout << \"catch MyException ...\" << endl;\n  }\n}",
			"example_bad": "///cpp:\n#include <iostream>\n \nusing namespace std;\n\nclass MyException\n{\n  public:\n    MyException ()\n    {\n      throw \"Exception thrown when constructing an exception object\"; // non-compliant\n    }\n};\n\nvoid func ( int n ) throw (int, MyException)\n{\n  if ( n == 1 )\n  {\n    throw 1;\n  }\n  else\n  {\n    throw MyException();\n  }\n}\n\nint main( void )\n{\n  try\n  {\n    func(2);\n  }\n\n  catch ( int n )\n  {\n    cout << \"catch int ...\" << endl;\n  }\n  catch (MyException)\n  {\n    cout << \"catch MyException ...\" << endl;\n  }\n}",
			"details_en": "#### Abstract\nWhen constructing an exception object, an exception should not be thrown\n\n#### Explanation\nIf an exception is thrown during the construction of an exception object, it propagates in preference to the one about to be thrown, which may be out of expectation.",
			"details_cn": "#### 概要\n构造异常对象时，不应抛出异常\n\n#### 解释\n如果在构造异常对象的过程中抛出了异常，则该异常会优先于将要抛出的异常传播，这可能是出乎意料的。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <iostream>\n\nusing namespace std;\n\nclass MyException\n{\n  public:\n    MyException ()\n    {\n      cout << \"constructor does not cause exception\" << endl; // compliant\n    }\n};\n\nvoid func ( int n ) throw (int, MyException)\n{\n  if ( n == 1 )\n  {\n    throw 1;\n  }\n  else\n  {\n    throw MyException();\n  }\n}\n\nint main( void )\n{\n  try\n  {\n    func(2);\n  }\n\n  catch ( int n )\n  {\n    cout << \"catch int ...\" << endl;\n  }\n  catch (MyException)\n  {\n    cout << \"catch MyException ...\" << endl;\n  }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <iostream>\n \nusing namespace std;\n\nclass MyException\n{\n  public:\n    MyException ()\n    {\n      throw \"Exception thrown when constructing an exception object\"; // non-compliant\n    }\n};\n\nvoid func ( int n ) throw (int, MyException)\n{\n  if ( n == 1 )\n  {\n    throw 1;\n  }\n  else\n  {\n    throw MyException();\n  }\n}\n\nint main( void )\n{\n  try\n  {\n    func(2);\n  }\n\n  catch ( int n )\n  {\n    cout << \"catch int ...\" << endl;\n  }\n  catch (MyException)\n  {\n    cout << \"catch MyException ...\" << endl;\n  }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1644290721403"
	},
	{
		"name": "NULL should not be thrown explicitly",
		"code": "MSR_15_1_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, NULL is thrown explicitly ",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, NULL被显式抛出",
			"code": "MSR_15_1_2",
			"override": "T",
			"master_id": "2115",
			"name": "NULL should not be thrown explicitly",
			"name_cn": "不应显式抛出NULL",
			"compliance": "R",
			"desc_en": "Throwing a NULL will be caught by an integer handler, this may be unexpected behavior",
			"desc_cn": "抛出 NULL 将被整数处理程序捕获，这可能是意外行为",
			"abstract": "Throwing a NULL will be caught by an integer handler, this may be unexpected behavior",
			"explanation": "Throw NULL would be caught by an integer handler, which may not match developer expectations.",
			"abstract_cn": "抛出 NULL 将被整数处理程序捕获，这可能是意外行为",
			"explanation_cn": "抛出 NULL 将被整数处理程序捕获，这可能与开发人员的期望不符。",
			"example_good": "///cpp:\n#include <iostream>\n \nusing namespace std;\n\nclass Str {\npublic:\n  int Report()    const { cout << \"Str error \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }  \n  \npublic:\n  Str() {} \n  void setLength( double len );\n  int  Length( void ) {\n    if (length <= 0)\n      throw Report();\n    else\n      return length;\n  }\n \nprivate:\n  int length;\n};\n\n\nint main(class Str *p)\n{\n  // ...\n  \n  try {\n    p->Length();  // Legth() fully handle throw\n    // ...\n  }\n  catch (int m) {\n    if (m == 0)\n      p->NullReport();\n    // ...\n  }\n  catch (...) {\n    // ...\n  }\n\n  // ..\n}\n",
			"example_bad": "///cpp:\n#include <iostream>\n \nusing namespace std;\n\nclass Str {\npublic:\n  int Report()  const { cout << \"Str error \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }\n  \npublic:\n  Str() {} \n  void setLength( double len );\n  int  Length( void ) {\n    if (length == 0)\n      throw Report();\n    else\n      return length;\n  }\n \nprivate:\n  int length;\n};\n\n\nvoid foo(class Str *p)\n{\n  // ...\n  \n  try {\n    if (p->Length() < 0) {\n      throw (NULL);    // throw NULL\n    }\n    // ...\n  }\n  catch (int m) {\n    if (m == 0) {\n      p->NullReport();\n    }\n    // ...\n  }\n\n  // ..\n}\n",
			"details_en": "#### Abstract\nThrowing a NULL will be caught by an integer handler, this may be unexpected behavior\n\n#### Explanation\nThrow NULL would be caught by an integer handler, which may not match developer expectations.",
			"details_cn": "#### 概要\n抛出 NULL 将被整数处理程序捕获，这可能是意外行为\n\n#### 解释\n抛出 NULL 将被整数处理程序捕获，这可能与开发人员的期望不符。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <iostream>\n \nusing namespace std;\n\nclass Str {\npublic:\n  int Report()    const { cout << \"Str error \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }  \n  \npublic:\n  Str() {} \n  void setLength( double len );\n  int  Length( void ) {\n    if (length <= 0)\n      throw Report();\n    else\n      return length;\n  }\n \nprivate:\n  int length;\n};\n\n\nint main(class Str *p)\n{\n  // ...\n  \n  try {\n    p->Length();  // Legth() fully handle throw\n    // ...\n  }\n  catch (int m) {\n    if (m == 0)\n      p->NullReport();\n    // ...\n  }\n  catch (...) {\n    // ...\n  }\n\n  // ..\n}\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <iostream>\n \nusing namespace std;\n\nclass Str {\npublic:\n  int Report()  const { cout << \"Str error \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }\n  \npublic:\n  Str() {} \n  void setLength( double len );\n  int  Length( void ) {\n    if (length == 0)\n      throw Report();\n    else\n      return length;\n  }\n \nprivate:\n  int length;\n};\n\n\nvoid foo(class Str *p)\n{\n  // ...\n  \n  try {\n    if (p->Length() < 0) {\n      throw (NULL);    // throw NULL\n    }\n    // ...\n  }\n  catch (int m) {\n    if (m == 0) {\n      p->NullReport();\n    }\n    // ...\n  }\n\n  // ..\n}\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1644290836375"
	},
	{
		"name": "An empty throw should only be used in a catch handler",
		"code": "MSR_15_1_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, an empty throw is used outside a catch handler",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 在catch 处理程序之外使用了空的throw",
			"code": "MSR_15_1_3",
			"override": "T",
			"master_id": "2116",
			"name": "An empty throw should only be used in a catch handler",
			"name_cn": "一个空的 throw 应该只在 catch 处理程序中使用",
			"compliance": "R",
			"desc_en": "An empty throw shall not be used outside a catch handler",
			"desc_cn": "不应在 catch 处理程序之外使用空的throw",
			"abstract": "An empty throw shall not be used outside a catch handler",
			"explanation": "Use of empty throw outside a catch handler would terminate the program since there is no exception object to re-thrown. The behavior is implementation defined.",
			"abstract_cn": "不应在 catch 处理程序之外使用空的throw",
			"explanation_cn": "在 catch 处理程序之外使用空抛出将终止程序，因为没有要重新抛出的异常对象。 行为是实现定义的。",
			"example_good": "///cpp:\n#include <iostream>\n \nusing namespace std;\n\nclass Str {\npublic:\n  int Report()    const { cout << \"Str error \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }  \n  \npublic:\n  Str() {} \n  void setLength( double len );\n  int  Length( void ) {\n    if (length <= 0)\n      throw Report();\n    else\n      return length;\n  }\n \nprivate:\n  int length;\n};\n\n\nvoid foo(class Str *p)\n{\n  // ...\n  \n  try {\n    p->Length();\n    // ...\n  }\n  catch (int m) {\n    if (m == 0)\n      p->NullReport();\n    else {\n      throw;  // re-throw - allowed\n    }\n    // ...\n  }\n\n  // ..\n}\n",
			"example_bad": "///cpp:\n#include <iostream>\n \nusing namespace std;\n\nclass Str {\npublic:\n  int Report()  const { cout << \"Str error \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }\n  \npublic:\n  Str() {} \n  void setLength( double len );\n  int  Length( void ) {\n    if (length == 0)\n      throw Report();\n    else\n      return length;\n  }\n \nprivate:\n  int length;\n};\n\n\nvoid foo(class Str *p)\n{\n  // ...\n  \n  try {\n    if (p->Length() < 0) {\n      throw;    // empty throw\n    }\n    // ...\n  }\n  catch (int m) {\n    if (m == 0)\n      p->NullReport();\n    else {\n      throw;\n    }\n    // ...\n  }\n\n  // ..\n}\n",
			"details_en": "#### Abstract\nAn empty throw shall not be used outside a catch handler\n\n#### Explanation\nUse of empty throw outside a catch handler would terminate the program since there is no exception object to re-thrown. The behavior is implementation defined.",
			"details_cn": "#### 概要\n不应在 catch 处理程序之外使用空的throw\n\n#### 解释\n在 catch 处理程序之外使用空抛出将终止程序，因为没有要重新抛出的异常对象。 行为是实现定义的。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <iostream>\n \nusing namespace std;\n\nclass Str {\npublic:\n  int Report()    const { cout << \"Str error \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }  \n  \npublic:\n  Str() {} \n  void setLength( double len );\n  int  Length( void ) {\n    if (length <= 0)\n      throw Report();\n    else\n      return length;\n  }\n \nprivate:\n  int length;\n};\n\n\nvoid foo(class Str *p)\n{\n  // ...\n  \n  try {\n    p->Length();\n    // ...\n  }\n  catch (int m) {\n    if (m == 0)\n      p->NullReport();\n    else {\n      throw;  // re-throw - allowed\n    }\n    // ...\n  }\n\n  // ..\n}\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <iostream>\n \nusing namespace std;\n\nclass Str {\npublic:\n  int Report()  const { cout << \"Str error \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }\n  \npublic:\n  Str() {} \n  void setLength( double len );\n  int  Length( void ) {\n    if (length == 0)\n      throw Report();\n    else\n      return length;\n  }\n \nprivate:\n  int length;\n};\n\n\nvoid foo(class Str *p)\n{\n  // ...\n  \n  try {\n    if (p->Length() < 0) {\n      throw;    // empty throw\n    }\n    // ...\n  }\n  catch (int m) {\n    if (m == 0)\n      p->NullReport();\n    else {\n      throw;\n    }\n    // ...\n  }\n\n  // ..\n}\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1644290908587"
	},
	{
		"name": "An exception handler to catch all otherwise unhandled exceptions should be provided",
		"code": "MSR_15_3_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, an exception handler to catch all otherwise unhandled exceptions is not provided",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 没有提供一个异常处理程序来捕获所有未处理的异常",
			"code": "MSR_15_3_2",
			"override": "T",
			"master_id": "2117",
			"name": "An exception handler to catch all otherwise unhandled exceptions should be provided",
			"name_cn": "应提供一个异常处理程序来捕获所有未处理的异常",
			"compliance": "A",
			"desc_en": "An exception handler to catch all otherwise unhandled exceptions should be provided",
			"desc_cn": "应提供一个异常处理程序来捕获所有未处理的异常",
			"abstract": "An exception handler to catch all otherwise unhandled exceptions should be provided",
			"explanation": "An exception handler to catch all otherwise unhandled exceptions ensures that unexpected exceptions can also be caught.",
			"abstract_cn": "应提供一个异常处理程序来捕获所有未处理的异常",
			"explanation_cn": "一个用于捕获所有未处理异常的异常处理程序可确保也可以捕获意料之外的异常。",
			"example_good": "///cpp:\n\n#include <stdlib.h>\n\nclass X {\n  \npublic:\n  X() { }  // constructor that does not throw\n  void setLen( double len );\n  int check_and_handle_error(int) {\n    if (len < 0)\n      throw 0;\n    return len;\n  }  \nprivate:\n  int  len;\n};\n\nvoid f()\n{\n  X local_x;\n  int i;\n  \n  // code\n  // ...\n\n  // where check_and_error() resides inside main\n  // such that all exceptions are caught\n  i = local_x.check_and_handle_error(0);\n  // ...\n}\n\n\nint main(int argc, char *argv[])\n{\n  try {\n    \n    // code can call f() which may throw exception\n    // ...\n   \n  }\n  catch (int m) {    \n    // handle any uncaught exception\n  }\n  \n  return 0;\n}\n",
			"example_bad": "///cpp:\n\n#include <stdlib.h>\n\nvoid f()\n{\n\n  // code\n  // ...\n  \n  exit(0);\n}\n\n\nint main(int argc, char *argv[])\n{\n  try {\n    \n    // code with no call to f()\n\n  }\n  catch (int m) {    \n    // handle any uncaught exception\n  }\n  \n  return 0;\n}\n",
			"details_en": "#### Abstract\nAn exception handler to catch all otherwise unhandled exceptions should be provided\n\n#### Explanation\nAn exception handler to catch all otherwise unhandled exceptions ensures that unexpected exceptions can also be caught.",
			"details_cn": "#### 概要\n应提供一个异常处理程序来捕获所有未处理的异常\n\n#### 解释\n一个用于捕获所有未处理异常的异常处理程序可确保也可以捕获意料之外的异常。",
			"examples": {
				"good": {
					"cpp": [
						"\n\n#include <stdlib.h>\n\nclass X {\n  \npublic:\n  X() { }  // constructor that does not throw\n  void setLen( double len );\n  int check_and_handle_error(int) {\n    if (len < 0)\n      throw 0;\n    return len;\n  }  \nprivate:\n  int  len;\n};\n\nvoid f()\n{\n  X local_x;\n  int i;\n  \n  // code\n  // ...\n\n  // where check_and_error() resides inside main\n  // such that all exceptions are caught\n  i = local_x.check_and_handle_error(0);\n  // ...\n}\n\n\nint main(int argc, char *argv[])\n{\n  try {\n    \n    // code can call f() which may throw exception\n    // ...\n   \n  }\n  catch (int m) {    \n    // handle any uncaught exception\n  }\n  \n  return 0;\n}\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n\n#include <stdlib.h>\n\nvoid f()\n{\n\n  // code\n  // ...\n  \n  exit(0);\n}\n\n\nint main(int argc, char *argv[])\n{\n  try {\n    \n    // code with no call to f()\n\n  }\n  catch (int m) {    \n    // handle any uncaught exception\n  }\n  \n  return 0;\n}\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1644296136940"
	},
	{
		"name": "handlers of a function-try-block should not reference non-static members from this class or its bases",
		"code": "MSR_15_3_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, handlers of a function-try-block reference non-static members from this class or its bases",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 函数try模块的处理程序引用了此类或其基类的非静态成员",
			"code": "MSR_15_3_3",
			"override": "T",
			"master_id": "2118",
			"name": "handlers of a function-try-block should not reference non-static members from this class or its bases",
			"name_cn": "function-try-block 的处理程序不应引用此类或其基类的非静态成员",
			"compliance": "R",
			"desc_en": "In ctor/dtor, handlers of a function-try-block should not reference non-static members from this class or its bases",
			"desc_cn": "在 ctor/dtor 中，函数try模块的处理程序不应引用此类或其基类的非静态成员",
			"abstract": "In ctor/dtor, handler of a function-try-block should not reference non-static members from this class or its bases",
			"explanation": "It is undefined behavior to access a non-static member of a class or a base class in the handler of a function-try-block.",
			"abstract_cn": "在 ctor/dtor 中，函数try模块的处理程序不应引用此类或其基类的非静态成员",
			"explanation_cn": "在 function-try-block 的处理程序中访问类或基类的非静态成员是未定义的行为。",
			"example_good": "///cpp:\n#include <iostream>\n \nusing namespace std;\n\nclass Count {\npublic:\n  int Report()  const { cout << \"argument C \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }\n  \npublic:\n  static int static_x;  // static scope variable\n  Count( void ) {\n    try {\n      // ...\n    }\n    catch (int m) {\n      // static var will have deterministic state\n      if (static_x == 0) throw Report();  \n    }\n  }\n  void setCount( int c );\n\n};\n\nCount ct; \n\nint main(int argc, char *argv[])\n{\n\n  // ...\n  // main code\n\n  return 0;\n}\n",
			"example_bad": "///cpp:\n#include <iostream>\n \nusing namespace std;\n\nclass Count {\npublic:\n  int Report()  const { cout << \"argument C \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }\n  \npublic:\n  int local_x;\n  Count( void ) {\n    try {\n      // ...\n    }\n    catch (int m) {\n      // reference local that may be in unknown state\n      if (local_x == 0) throw Report();  \n    }\n  }\n  ~Count( void ) {\n    try {\n      // ...\n    }\n    catch (int m) {\n      // reference local who",
			"details_en": "#### Abstract\nIn ctor/dtor, handler of a function-try-block should not reference non-static members from this class or its bases\n\n#### Explanation\nIt is undefined behavior to access a non-static member of a class or a base class in the handler of a function-try-block.",
			"details_cn": "#### 概要\n在 ctor/dtor 中，函数try模块的处理程序不应引用此类或其基类的非静态成员\n\n#### 解释\n在 function-try-block 的处理程序中访问类或基类的非静态成员是未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <iostream>\n \nusing namespace std;\n\nclass Count {\npublic:\n  int Report()  const { cout << \"argument C \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }\n  \npublic:\n  static int static_x;  // static scope variable\n  Count( void ) {\n    try {\n      // ...\n    }\n    catch (int m) {\n      // static var will have deterministic state\n      if (static_x == 0) throw Report();  \n    }\n  }\n  void setCount( int c );\n\n};\n\nCount ct; \n\nint main(int argc, char *argv[])\n{\n\n  // ...\n  // main code\n\n  return 0;\n}\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <iostream>\n \nusing namespace std;\n\nclass Count {\npublic:\n  int Report()  const { cout << \"argument C \"; return 0; }\n  void NullReport(void) { cout << \"Null pointer\"; }\n  \npublic:\n  int local_x;\n  Count( void ) {\n    try {\n      // ...\n    }\n    catch (int m) {\n      // reference local that may be in unknown state\n      if (local_x == 0) throw Report();  \n    }\n  }\n  ~Count( void ) {\n    try {\n      // ...\n    }\n    catch (int m) {\n      // reference local who"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1644296197388"
	},
	{
		"name": "A class type exception object should be caught by reference only",
		"code": "MSR_15_3_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a class type exception object is caught not by reference",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 类类型异常对象未被引用捕获",
			"code": "MSR_15_3_5",
			"override": "T",
			"master_id": "2119",
			"name": "A class type exception object should be caught by reference only",
			"name_cn": "一个类类型异常对象应仅通过引用捕获",
			"compliance": "R",
			"desc_en": "A class type exception object should be caught by reference only",
			"desc_cn": "一个类类型异常对象应仅通过引用捕获",
			"abstract": "A class type exception object should be caught by reference only",
			"explanation": "If the class type exception object is caught not by reference, additional member data in derived class cannot be accessed.",
			"abstract_cn": "一个类类型异常对象应仅通过引用捕获",
			"explanation_cn": "如果类类型异常对象不是通过引用捕获的，则无法访问派生类中的其他成员数据。",
			"example_good": "///cpp:\nclass Base {\npublic:\n  Base(void) {}\n  Base(const Base &b) {}\n  virtual const char* test() {\n    return \"Base\";\n  };\n\nprivate:\n  static int priv_int;\n};\n\n\nclass Derived : public virtual Base {\npublic:\n  Derived() {}\n  //  Derived1(int) : Base(0) {}\n  virtual const char* test() {\n    return \"Derived\";\n  };\n  \n  \n  void foo()\n  {\n    Derived D1;\n    \n    try {\n      // ...\n      throw Derived();\n      throw Base();\n    }\n    catch (Base &b) {\n      b.test();\n      throw b;\n    }\n    catch (Derived &d) {\n      d.test();\n      throw d;\n    }\n  }\n};\n",
			"example_bad": "///cpp:\nclass Base {\npublic:\n  Base(void) {}\n  Base(const Base &b) {}\n  virtual const char* test() {\n    return \"Base\";\n  }; \nprivate:\n  static int priv_int;\n};\n\n\nclass Derived : public virtual Base {\npublic:\n  Derived() {}\n  virtual const char* test() {\n    return \"Derived\";\n  };\nprivate:\n  int d;\n  \n  void foo()\n  {    \n    try {\n      // ...\n      throw Derived();\n      throw Base();\n    }\n    catch (Base b) {\n      b.test();\n      throw b;\n    }\n  }\n};\n",
			"details_en": "#### Abstract\nA class type exception object should be caught by reference only\n\n#### Explanation\nIf the class type exception object is caught not by reference, additional member data in derived class cannot be accessed.",
			"details_cn": "#### 概要\n一个类类型异常对象应仅通过引用捕获\n\n#### 解释\n如果类类型异常对象不是通过引用捕获的，则无法访问派生类中的其他成员数据。",
			"examples": {
				"good": {
					"cpp": [
						"\nclass Base {\npublic:\n  Base(void) {}\n  Base(const Base &b) {}\n  virtual const char* test() {\n    return \"Base\";\n  };\n\nprivate:\n  static int priv_int;\n};\n\n\nclass Derived : public virtual Base {\npublic:\n  Derived() {}\n  //  Derived1(int) : Base(0) {}\n  virtual const char* test() {\n    return \"Derived\";\n  };\n  \n  \n  void foo()\n  {\n    Derived D1;\n    \n    try {\n      // ...\n      throw Derived();\n      throw Base();\n    }\n    catch (Base &b) {\n      b.test();\n      throw b;\n    }\n    catch (Derived &d) {\n      d.test();\n      throw d;\n    }\n  }\n};\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\nclass Base {\npublic:\n  Base(void) {}\n  Base(const Base &b) {}\n  virtual const char* test() {\n    return \"Base\";\n  }; \nprivate:\n  static int priv_int;\n};\n\n\nclass Derived : public virtual Base {\npublic:\n  Derived() {}\n  virtual const char* test() {\n    return \"Derived\";\n  };\nprivate:\n  int d;\n  \n  void foo()\n  {    \n    try {\n      // ...\n      throw Derived();\n      throw Base();\n    }\n    catch (Base b) {\n      b.test();\n      throw b;\n    }\n  }\n};\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1644297901363"
	},
	{
		"name": "sizeof operator should not be used to function parameters declared as \"array of type\"",
		"code": "MSR_12_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, sizeof operator is used to function parameters declared as \"array of type\"",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, sizeof 运算符被应用于声明为“类型数组”的函数参数",
			"code": "MSR_12_5",
			"override": "T",
			"master_id": "2120",
			"name": "sizeof operator should not be used to function parameters declared as \"array of type\"",
			"name_cn": "sizeof 运算符不应用于声明为“类型数组”的函数参数",
			"compliance": "M",
			"desc_en": "function parameter declared as \"array of type\" should not be used as operator for sizeof",
			"desc_cn": "声明为“类型数组”的函数参数不应用作 sizeof 的运算符",
			"abstract": "function parameter declared as \"array of type\" should not be used as operator for sizeof",
			"explanation": "Since the function parameters declared as arrays would degenerate to pointer to type, the use of size of cannot return the size of the array.",
			"abstract_cn": "声明为“类型数组”的函数参数不应用作 sizeof 的运算符",
			"explanation_cn": "由于声明为数组的函数参数会退化为指向类型的指针，因此使用 sizeof 不能返回数组的大小。",
			"example_good": "///c:\n#include <stdint.h>\n\nint arr1[] = {1, 2, 3};\nint arr2[] = {1, 2};\n\nvoid func( void )\n{\n    int a = sizeof( arr1 ) - sizeof (arr2);\n    /*\n        compliant;\n        sizeof arr1, arr2 return the size of arrays\n    */\n    printf( a );\n}",
			"example_bad": "///c:\n#include <stdint.h>\n\nvoid func( int arr1[ 5 ], int arr2[ 3 ] )\n{\n    int a = sizeof( arr1 ) - sizeof (arr2);\n    /*\n        non-compliant;\n        arr1, arr2 have type int *;\n        sizeof arr1, arr2 do not return the size of array\n    */\n    printf( a );\n}",
			"details_en": "#### Abstract\nfunction parameter declared as \"array of type\" should not be used as operator for sizeof\n\n#### Explanation\nSince the function parameters declared as arrays would degenerate to pointer to type, the use of size of cannot return the size of the array.",
			"details_cn": "#### 概要\n声明为“类型数组”的函数参数不应用作 sizeof 的运算符\n\n#### 解释\n由于声明为数组的函数参数会退化为指向类型的指针，因此使用 sizeof 不能返回数组的大小。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdint.h>\n\nint arr1[] = {1, 2, 3};\nint arr2[] = {1, 2};\n\nvoid func( void )\n{\n    int a = sizeof( arr1 ) - sizeof (arr2);\n    /*\n        compliant;\n        sizeof arr1, arr2 return the size of arrays\n    */\n    printf( a );\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdint.h>\n\nvoid func( int arr1[ 5 ], int arr2[ 3 ] )\n{\n    int a = sizeof( arr1 ) - sizeof (arr2);\n    /*\n        non-compliant;\n        arr1, arr2 have type int *;\n        sizeof arr1, arr2 do not return the size of array\n    */\n    printf( a );\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1644563443487"
	},
	{
		"name": "An identifier declared in an inner scope should not hide an outer one",
		"code": "A2_10_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, An identifier declared in an inner scope  hides an outer one",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 在内部范围内声明的标识符隐藏了外部标识符",
			"code": "A2_10_1",
			"override": "T",
			"master_id": "2121",
			"name": "An identifier declared in an inner scope should not hide an outer one",
			"name_cn": "在内部范围内声明的标识符不应隐藏外部标识符",
			"compliance": "R",
			"desc_en": "An identifier declared in an inner scope should not be the same as an outer one",
			"desc_cn": "在内部范围中声明的标识符不应与外部范围中的相同",
			"abstract": "An identifier declared in an inner scope should not be the same as an outer one",
			"explanation": "If an identifier declared in an inner scope uses the same name as an identifier in an out er scope, it would raise confusion for developer.",
			"abstract_cn": "在内部范围中声明的标识符不应与外部范围中的相同",
			"explanation_cn": "如果在内部作用域中声明的标识符使用与在外部作用域中的标识符相同的名称，则会引起开发人员的混淆。",
			"example_good": "///cpp:\n#include <stdio.h>\n\nint i;\n\nint func1 ( int j ) // compliant\n{\n    j ++;\n    return 0;\n}\n\nnamespace test1\n{\n    int t;\n    namespace test2\n    {\n        int t; // compliant by exception\n    }\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n\nint i, j;\n\nint func ( int i, int j ) // non-compliant\n{\n    i = 1;\n    j = 2;\n    if ( i - j < 0 )\n    {\n        return 0;\n    }\n}",
			"details_en": "#### Abstract\nAn identifier declared in an inner scope should not be the same as an outer one\n\n#### Explanation\nIf an identifier declared in an inner scope uses the same name as an identifier in an out er scope, it would raise confusion for developer.",
			"details_cn": "#### 概要\n在内部范围中声明的标识符不应与外部范围中的相同\n\n#### 解释\n如果在内部作用域中声明的标识符使用与在外部作用域中的标识符相同的名称，则会引起开发人员的混淆。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nint i;\n\nint func1 ( int j ) // compliant\n{\n    j ++;\n    return 0;\n}\n\nnamespace test1\n{\n    int t;\n    namespace test2\n    {\n        int t; // compliant by exception\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\nint i, j;\n\nint func ( int i, int j ) // non-compliant\n{\n    i = 1;\n    j = 2;\n    if ( i - j < 0 )\n    {\n        return 0;\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1645761353009"
	},
	{
		"name": "Volatile keyword should not be used",
		"code": "A2_11_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, volatile keyword is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, volatile关键字被使用了",
			"code": "A2_11_1",
			"override": "T",
			"master_id": "2122",
			"name": "Volatile keyword should not be used",
			"name_cn": "不应该使用volatile关键字",
			"compliance": "R",
			"desc_en": "Volatile keyword should not be used",
			"desc_cn": "不应该使用volatile关键字",
			"abstract": "Volatile keyword should not be used",
			"explanation": "Volatile keyword is error-prone and is often misused by developers.",
			"abstract_cn": "不应该使用volatile关键字",
			"explanation_cn": "Volatile 关键字容易出错，并且经常被开发人员误用。",
			"example_good": "///cpp:\n#include <stdio.h>\n\nint func ( void )\n{\n    int i = 10; // compliant\n    int a;\n    a = i;\n    return a;\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n\nint func ( void )\n{\n    volatile int i = 10; // non-compliant\n    int a, b;\n    a = i;\n    /*\n    ...\n    do something\n    */\n    b = i;\n    return 0;\n}",
			"details_en": "#### Abstract\nVolatile keyword should not be used\n\n#### Explanation\nVolatile keyword is error-prone and is often misused by developers.",
			"details_cn": "#### 概要\n不应该使用volatile关键字\n\n#### 解释\nVolatile 关键字容易出错，并且经常被开发人员误用。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nint func ( void )\n{\n    int i = 10; // compliant\n    int a;\n    a = i;\n    return a;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\nint func ( void )\n{\n    volatile int i = 10; // non-compliant\n    int a, b;\n    a = i;\n    /*\n    ...\n    do something\n    */\n    b = i;\n    return 0;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1645772054749"
	},
	{
		"name": "Hexadecimal constants should be upper case",
		"code": "A2_13_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, hexadecimal constants is not upper case",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 十六进制常量不是大写",
			"code": "A2_13_5",
			"override": "T",
			"master_id": "2123",
			"name": "Hexadecimal constants should be upper case",
			"name_cn": "十六进制常量应为大写",
			"compliance": "A",
			"desc_en": "Hexadecimal constants should be upper case",
			"desc_cn": "十六进制常量应为大写",
			"abstract": "Hexadecimal constants should be upper case",
			"explanation": "Use of upper case for hexadecimal constants makes source code consistent and reduces developer confusion.",
			"abstract_cn": "十六进制常量应为大写",
			"explanation_cn": "对十六进制常量使用大写字母可使源代码保持一致并减少开发人员的困惑。",
			"example_good": "///cpp:\nint i = 0xA;    // compliant\nint j = 0x4B;   // compliant\nint k = 0x0F5C; // compliant",
			"example_bad": "///cpp:\nint   i = 0xa;    // non-compliant\nshort j = 0x4b;   // non-compliant\nshort k = 0x0f5c; // non-compliant\n\n\nint foo(int i, short s1, short s2)\n{\n  return i + (int)j + (int)k;\n}",
			"details_en": "#### Abstract\nHexadecimal constants should be upper case\n\n#### Explanation\nUse of upper case for hexadecimal constants makes source code consistent and reduces developer confusion.",
			"details_cn": "#### 概要\n十六进制常量应为大写\n\n#### 解释\n对十六进制常量使用大写字母可使源代码保持一致并减少开发人员的困惑。",
			"examples": {
				"good": {
					"cpp": [
						"\nint i = 0xA;    // compliant\nint j = 0x4B;   // compliant\nint k = 0x0F5C; // compliant"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\nint   i = 0xa;    // non-compliant\nshort j = 0x4b;   // non-compliant\nshort k = 0x0f5c; // non-compliant\n\n\nint foo(int i, short s1, short s2)\n{\n  return i + (int)j + (int)k;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1645773126183"
	},
	{
		"name": "String literals should not be assigned to non-constant pointers",
		"code": "A2_13_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, string literals are assigned to non-constant pointers",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 字符串文字被分配给非常量指针",
			"code": "A2_13_4",
			"override": "T",
			"master_id": "2124",
			"name": "String literals should not be assigned to non-constant pointers",
			"name_cn": "不应将字符串文字分配给非常量指针",
			"compliance": "R",
			"desc_en": "String literals should not be assigned to non-constant pointers",
			"desc_cn": "不应将字符串文字分配给非常量指针",
			"abstract": "String literals should not be assigned to non-constant pointers",
			"explanation": "String literals should be changed to constant pointers in order to prevent from calling an inappropriate function which might modify its argument.",
			"abstract_cn": "不应将字符串文字分配给非常量指针",
			"explanation_cn": "字符串文字应更改为常量指针，以防止调用可能修改其参数的不适当函数。",
			"example_good": "///cpp:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    const char a1[] = \"str_literal\";    // compliant\n    const char* a2 = \"str_literal\";     // compliant\n    const char a3[12] = \"str_literal\";  // compliant\n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n\nvoid func ( void )\n{\n    char non_const1[] = \"str_literal\";      // non-compliant\n    char* non_const2 = \"str_literal\";       // non-compliant\n    char non_const3[ 12 ] = \"str_literal\";  // non-compliant\n}",
			"details_en": "#### Abstract\nString literals should not be assigned to non-constant pointers\n\n#### Explanation\nString literals should be changed to constant pointers in order to prevent from calling an inappropriate function which might modify its argument.",
			"details_cn": "#### 概要\n不应将字符串文字分配给非常量指针\n\n#### 解释\n字符串文字应更改为常量指针，以防止调用可能修改其参数的不适当函数。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    const char a1[] = \"str_literal\";    // compliant\n    const char* a2 = \"str_literal\";     // compliant\n    const char a3[12] = \"str_literal\";  // compliant\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\nvoid func ( void )\n{\n    char non_const1[] = \"str_literal\";      // non-compliant\n    char* non_const2 = \"str_literal\";       // non-compliant\n    char non_const3[ 12 ] = \"str_literal\";  // non-compliant\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1645773939795"
	},
	{
		"name": "An identifier should not refer to a type and an object in the same scope",
		"code": "MSR_2_10_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, an identifier refer to a type and an object in the same scope",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 标识符引用同一范围内的类型和对象",
			"code": "MSR_2_10_6",
			"override": "T",
			"master_id": "2125",
			"name": "An identifier should not refer to a type and an object in the same scope",
			"name_cn": "标识符不应引用同一范围内的类型和对象",
			"compliance": "R",
			"desc_en": "An identifier should not refer to a type and an object in the same scope",
			"desc_cn": "标识符不应引用同一范围内的类型和对象",
			"abstract": "An identifier should not refer to a type and an object in the same scope",
			"explanation": "An identifier which refers to both a type and object or a type and function can lead to confusion.",
			"abstract_cn": "标识符不应引用同一范围内的类型和对象",
			"explanation_cn": "同时引用类型和对象或类型和函数的标识符可能会导致混淆。",
			"example_good": "///cpp:\n#include <stdio.h>\n\n// different names refer to a type and an object\ntypedef struct test1 { int x; int y; } test2;",
			"example_bad": "///cpp:\n#include <stdio.h>\n\n// a name refer to both a type and an object\ntypedef struct test1 { int x; int y; } test1;\n\n/* \na name refer to both a type and a function,\nthis example will get compilation error\n*/\ntypedef struct test2 { int a; int b; } test2;\n\nint test2( void )\n{\n    return 1;\n}",
			"details_en": "#### Abstract\nAn identifier should not refer to a type and an object in the same scope\n\n#### Explanation\nAn identifier which refers to both a type and object or a type and function can lead to confusion.",
			"details_cn": "#### 概要\n标识符不应引用同一范围内的类型和对象\n\n#### 解释\n同时引用类型和对象或类型和函数的标识符可能会导致混淆。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\n// different names refer to a type and an object\ntypedef struct test1 { int x; int y; } test2;"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\n// a name refer to both a type and an object\ntypedef struct test1 { int x; int y; } test1;\n\n/* \na name refer to both a type and a function,\nthis example will get compilation error\n*/\ntypedef struct test2 { int a; int b; } test2;\n\nint test2( void )\n{\n    return 1;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1648194453079"
	},
	{
		"name": "Bool expression should not be used as operands to built-in operators other than =, &&, ||, !, ==, !=, &, ?:",
		"code": "MSR_4_5_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, bool expression is used as operands to built-in operators other than =, &&, ||, !, ==, !=, &, ?:.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, bool 类型的表达式被应用作除 =, &&, ||, !, ==, !=, &, ?:的内置运算符的操作数",
			"code": "MSR_4_5_1",
			"override": "T",
			"master_id": "2126",
			"name": "Bool expression should not be used as operands to built-in operators other than =, &&, ||, !, ==, !=, &, ?:",
			"name_cn": "bool 类型的表达式不应用作除 =, &&, ||, !, ==, !=, &, ?:的内置运算符的操作数",
			"compliance": "R",
			"desc_en": "Bool expression should not be used as operands to built-in operators other than =, &&, ||, !, ==, !=, &, ?:",
			"desc_cn": "bool 类型的表达式不应用作除 =, &&, ||, !, ==, !=, &, ?:的内置运算符的操作数",
			"abstract": "Bool expression should not be used as operands to built-in operators other than =, &&, ||, !, ==, !=, &, ?:",
			"explanation": "The use of bool operands with other operators is unmeaningful.",
			"abstract_cn": "bool 类型的表达式不应用作除 =, &&, ||, !, ==, !=, &, ?:的内置运算符的操作数",
			"explanation_cn": "将 bool 操作数与其他运算符一起使用是没有意义的。",
			"example_good": "///cpp:\n#include <stdio.h>\n\nbool a = true;\nbool b = false;\n\nint func( void )\n{\n    if ( a && b )           // the use of bool and && is meaningful\n    {\n        printf(\"compliant\");\n    }\n    else if ( a != b )      // the use of bool and != is meaningful\n    {\n        printf(\"compliant\");\n    }\n    return 0;   \n}",
			"example_bad": "///cpp:\n#include <stdio.h>\n\nbool a = true;\nbool b = false;\n\nvoid func( void )\n{\n    if ( a < b ) // the use of bool and < is unmeaningful\n    {\n        printf(\"non-compliant\");\n    }\n}",
			"details_en": "#### Abstract\nBool expression should not be used as operands to built-in operators other than =, &&, ||, !, ==, !=, &, ?:\n\n#### Explanation\nThe use of bool operands with other operators is unmeaningful.",
			"details_cn": "#### 概要\nbool 类型的表达式不应用作除 =, &&, ||, !, ==, !=, &, ?:的内置运算符的操作数\n\n#### 解释\n将 bool 操作数与其他运算符一起使用是没有意义的。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nbool a = true;\nbool b = false;\n\nint func( void )\n{\n    if ( a && b )           // the use of bool and && is meaningful\n    {\n        printf(\"compliant\");\n    }\n    else if ( a != b )      // the use of bool and != is meaningful\n    {\n        printf(\"compliant\");\n    }\n    return 0;   \n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\nbool a = true;\nbool b = false;\n\nvoid func( void )\n{\n    if ( a < b ) // the use of bool and < is unmeaningful\n    {\n        printf(\"non-compliant\");\n    }\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1648439740851"
	},
	{
		"name": "Enumeration underlying base type should be explicitly defined",
		"code": "A7_2_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, enumeration underlying base type is not explicitly defined.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 枚举基础类型没有被明确定义。",
			"code": "A7_2_2",
			"override": "T",
			"master_id": "2127",
			"name": "Enumeration underlying base type should be explicitly defined",
			"name_cn": "枚举基础类型应明确定义",
			"compliance": "R",
			"desc_en": "Enumeration underlying base type should be explicitly defined",
			"desc_cn": "枚举基础类型应明确定义",
			"abstract": "Enumeration underlying base type should be explicitly defined",
			"explanation": "The enumeration underlying type must be able to represent the enumeration values.",
			"abstract_cn": "枚举基础类型应明确定义",
			"explanation_cn": "枚举基础类型必须能够表示枚举值。",
			"example_good": "///cpp:\nenum test : int // compliant\n{   \n    t1,\n    t2,\n    t3\n};",
			"example_bad": "///cpp:\nenum test // non-compliant\n{   \n    t1,\n    t2,\n    t3\n};",
			"details_en": "#### Abstract\nEnumeration underlying base type should be explicitly defined\n\n#### Explanation\nThe enumeration underlying type must be able to represent the enumeration values.",
			"details_cn": "#### 概要\n枚举基础类型应明确定义\n\n#### 解释\n枚举基础类型必须能够表示枚举值。",
			"examples": {
				"good": {
					"cpp": [
						"\nenum test : int // compliant\n{   \n    t1,\n    t2,\n    t3\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\nenum test // non-compliant\n{   \n    t1,\n    t2,\n    t3\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1648708863460"
	},
	{
		"name": "The ternary conditional operators should not be used as sub-expressions",
		"code": "A5_16_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the ternary conditional operators are used as sub-expressions",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 三元条件运算符被用作子表达式",
			"code": "A5_16_1",
			"override": "T",
			"master_id": "2128",
			"name": "The ternary conditional operators should not be used as sub-expressions",
			"name_cn": "三元条件运算符不应用作子表达式",
			"compliance": "R",
			"desc_en": "The ternary conditional operators should not be used as sub-expressions",
			"desc_cn": "三元条件运算符不应用作子表达式",
			"abstract": "The ternary conditional operators should not be used as sub-expressions",
			"explanation": "The use of ternary conditional operators as sub-expressions would make code less readable.",
			"abstract_cn": "三元条件运算符不应用作子表达式",
			"explanation_cn": "使用三元条件运算符作为子表达式会降低代码的可读性。",
			"example_good": "///cpp:\n#include <stdio.h>\n\nint func ( int x, int y )\n{\n    int z = x > y ? 10 : x; // compliant\n    return z;\n}\n",
			"example_bad": "///cpp:\n#include <stdio.h>\n\nint func ( int x, int y )\n{\n    // ternary conditional operator used as sub-expression\n    int z = y - (x > y ? 10 : ( y > 5 ? 2 : ( x + y )));\n    return z;\n}",
			"details_en": "#### Abstract\nThe ternary conditional operators should not be used as sub-expressions\n\n#### Explanation\nThe use of ternary conditional operators as sub-expressions would make code less readable.",
			"details_cn": "#### 概要\n三元条件运算符不应用作子表达式\n\n#### 解释\n使用三元条件运算符作为子表达式会降低代码的可读性。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdio.h>\n\nint func ( int x, int y )\n{\n    int z = x > y ? 10 : x; // compliant\n    return z;\n}\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdio.h>\n\nint func ( int x, int y )\n{\n    // ternary conditional operator used as sub-expression\n    int z = y - (x > y ? 10 : ( y > 5 ? 2 : ( x + y )));\n    return z;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1648717912033"
	},
	{
		"name": "typedef specifier should not be used for defining alias",
		"code": "A7_1_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, typedef specifier is used.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, typedef 说明符被使用了。",
			"code": "A7_1_6",
			"override": "T",
			"master_id": "2129",
			"name": "typedef specifier should not be used for defining alias",
			"name_cn": "typedef 说明符不应用于定义别名",
			"compliance": "R",
			"desc_en": "typedef specifier should not be used for defining alias",
			"desc_cn": "typedef 说明符不应用于定义别名",
			"abstract": "typedef specifier should not be used for defining alias",
			"explanation": "The using syntax should be used to replace typedef since typedef makes code less readable.",
			"abstract_cn": "typedef 说明符不应用于定义别名",
			"explanation_cn": "应该使用 using 语法来替换 typedef，因为 typedef 会使代码的可读性降低。",
			"example_good": "///cpp:\n// defining aliases with using\nusing uint_t = unsigned int;\n\ntemplate <typename Test>\nusing func_t = void (*)(Test, Test);",
			"example_bad": "///cpp:\n#include<string>\n\n// defining aliases with typedef\ntypedef unsigned int uint_t;\ntypedef int *p;\ntypedef int f( void );\n\n// template <typename Test>\n// typedef func_t: void (*)(Test, Test); // this example would raise compilation error",
			"details_en": "#### Abstract\ntypedef specifier should not be used for defining alias\n\n#### Explanation\nThe using syntax should be used to replace typedef since typedef makes code less readable.",
			"details_cn": "#### 概要\ntypedef 说明符不应用于定义别名\n\n#### 解释\n应该使用 using 语法来替换 typedef，因为 typedef 会使代码的可读性降低。",
			"examples": {
				"good": {
					"cpp": [
						"\n// defining aliases with using\nusing uint_t = unsigned int;\n\ntemplate <typename Test>\nusing func_t = void (*)(Test, Test);"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include<string>\n\n// defining aliases with typedef\ntypedef unsigned int uint_t;\ntypedef int *p;\ntypedef int f( void );\n\n// template <typename Test>\n// typedef func_t: void (*)(Test, Test); // this example would raise compilation error"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1649386036697"
	},
	{
		"name": "Enumerations should be declared as scoped enum classes",
		"code": "A7_2_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, enumerations are not declared as scoped enum classes",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 枚举没有被声明为有范围的枚举类",
			"code": "A7_2_3",
			"override": "T",
			"master_id": "2130",
			"name": "Enumerations should be declared as scoped enum classes",
			"name_cn": "枚举应声明为有范围的枚举类",
			"compliance": "R",
			"desc_en": "Enumerations should be declared as scoped enum classes",
			"desc_cn": "枚举应声明为有范围的枚举类",
			"abstract": "Enumerations should be declared as scoped enum classes",
			"explanation": "The declaration of unscoped enumeration enum in global scope may be confusing, so  enum-class should be used as enumeration.",
			"abstract_cn": "枚举应声明为有范围的枚举类",
			"explanation_cn": "在全局范围内声明无范围的 enum 可能会造成混淆，因此应该使用 enum-class 作为枚举。",
			"example_good": "///cpp:\n// Using enum-class as enumeration is compliant\nenum class test : int\n{   \n    t1,\n    t2,\n    t3\n};",
			"example_bad": "///cpp:\n// unscoped enumeration enum is declared in a global scope\nenum test : int\n{   \n    t1,\n    t2,\n    t3\n};",
			"details_en": "#### Abstract\nEnumerations should be declared as scoped enum classes\n\n#### Explanation\nThe declaration of unscoped enumeration enum in global scope may be confusing, so  enum-class should be used as enumeration.",
			"details_cn": "#### 概要\n枚举应声明为有范围的枚举类\n\n#### 解释\n在全局范围内声明无范围的 enum 可能会造成混淆，因此应该使用 enum-class 作为枚举。",
			"examples": {
				"good": {
					"cpp": [
						"\n// Using enum-class as enumeration is compliant\nenum class test : int\n{   \n    t1,\n    t2,\n    t3\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n// unscoped enumeration enum is declared in a global scope\nenum test : int\n{   \n    t1,\n    t2,\n    t3\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1649390952382"
	},
	{
		"name": "In enumeration, either none, the first or all enumerators should be initialized.",
		"code": "A7_2_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, only partial enumerators in enumeration are initialized.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 仅部分枚举数被初始化。",
			"code": "A7_2_4",
			"override": "T",
			"master_id": "2131",
			"name": "In enumeration, either none, the first or all enumerators should be initialized.",
			"name_cn": "在枚举中，应该或是全部无初始化，或是初始化第一个或所有枚举数。",
			"compliance": "R",
			"desc_en": "In enumeration, either none, the first or all enumerators should be initialized.",
			"desc_cn": "在枚举中，应该或是全部无初始化，或是初始化第一个或所有枚举数。",
			"abstract": "In enumeration, either none, the first or all enumerators should be initialized.",
			"explanation": "Initialization of only some enumerators in enumeration is confusing.",
			"abstract_cn": "在枚举中，应该或是全部无初始化，或是初始化第一个或所有枚举数。",
			"explanation_cn": "在枚举中仅初始化部分枚举数是令人困惑的。",
			"example_good": "///cpp:\nenum class test1 : int // compliant\n{   \n    t1,\n    t2,\n    t3\n};\n\nenum class test2 : int // compliant\n{   \n    t4 = 1,\n    t5,\n    t6\n};\n\nenum class test3 : int // compliant\n{   \n    t7 = 1,\n    t8 = 2,\n    t9 = 3\n};\n",
			"example_bad": "///cpp:\nenum class test1 : int // non-compliant\n{   \n    t1,\n    t2 = 10,\n    t3\n};\n\nenum class test2 : int // non-compliant\n{   \n    t4,\n    t5 = 10,\n    t6 = 11\n};",
			"details_en": "#### Abstract\nIn enumeration, either none, the first or all enumerators should be initialized.\n\n#### Explanation\nInitialization of only some enumerators in enumeration is confusing.",
			"details_cn": "#### 概要\n在枚举中，应该或是全部无初始化，或是初始化第一个或所有枚举数。\n\n#### 解释\n在枚举中仅初始化部分枚举数是令人困惑的。",
			"examples": {
				"good": {
					"cpp": [
						"\nenum class test1 : int // compliant\n{   \n    t1,\n    t2,\n    t3\n};\n\nenum class test2 : int // compliant\n{   \n    t4 = 1,\n    t5,\n    t6\n};\n\nenum class test3 : int // compliant\n{   \n    t7 = 1,\n    t8 = 2,\n    t9 = 3\n};\n"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\nenum class test1 : int // non-compliant\n{   \n    t1,\n    t2 = 10,\n    t3\n};\n\nenum class test2 : int // non-compliant\n{   \n    t4,\n    t5 = 10,\n    t6 = 11\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1649403748909"
	},
	{
		"name": "Using-directives should not be used",
		"code": "MSR_7_3_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, using-directives is used.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 使用了 using-directives",
			"code": "MSR_7_3_4",
			"override": "T",
			"master_id": "2132",
			"name": "Using-directives should not be used",
			"name_cn": "不应使用 using-directives",
			"compliance": "R",
			"desc_en": "Using-directives should not be used",
			"desc_cn": "不应使用 using-directives",
			"abstract": "Using-directives should not be used",
			"explanation": "Using-directives increases the possibility that the identifier found by the compiler creates confusion while using-declarations is a safer choice.",
			"abstract_cn": "不应使用 using-directives",
			"explanation_cn": "using-directives 增加了编译器找到的标识符造成混淆的可能性，而 using-declarations 是更安全的选择。",
			"example_good": "///cpp:\n#include <iostream>\n\nnamespace T1\n{\n\tint t{ 5 };\n}\n\nnamespace T2\n{\n\tint t{ 1 };\n}\n\nint func( void )\n{   \n    using T2::t; // using declaration is compliant\n    std::cout << t;\n    return 0;\n}",
			"example_bad": "///cpp:\n#include <iostream>\n\nnamespace T1\n{\n\tint t{ 5 };\n}\n\nnamespace T2\n{\n\tint t{ 1 };\n}\n\n/* This example may cause compilation error;\nusing directives raises confusion for \n\"std::cout << t\" of which t to refer to*/\nint func( void )\n{   \n    using namespace T1; \n    using namespace T2;\n    std::cout << t;\n    return 0;\n}",
			"details_en": "#### Abstract\nUsing-directives should not be used\n\n#### Explanation\nUsing-directives increases the possibility that the identifier found by the compiler creates confusion while using-declarations is a safer choice.",
			"details_cn": "#### 概要\n不应使用 using-directives\n\n#### 解释\nusing-directives 增加了编译器找到的标识符造成混淆的可能性，而 using-declarations 是更安全的选择。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <iostream>\n\nnamespace T1\n{\n\tint t{ 5 };\n}\n\nnamespace T2\n{\n\tint t{ 1 };\n}\n\nint func( void )\n{   \n    using T2::t; // using declaration is compliant\n    std::cout << t;\n    return 0;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <iostream>\n\nnamespace T1\n{\n\tint t{ 5 };\n}\n\nnamespace T2\n{\n\tint t{ 1 };\n}\n\n/* This example may cause compilation error;\nusing directives raises confusion for \n\"std::cout << t\" of which t to refer to*/\nint func( void )\n{   \n    using namespace T1; \n    using namespace T2;\n    std::cout << t;\n    return 0;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1649663909637"
	},
	{
		"name": "Class should not be derived from more than one non-interface base class ",
		"code": "A10_1_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, class is derived from more than one non-interface base class ",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 类从多个非接口基类派生",
			"code": "A10_1_1",
			"override": "T",
			"master_id": "2133",
			"name": "Class should not be derived from more than one non-interface base class ",
			"name_cn": "类不应从多个非接口基类派生",
			"compliance": "R",
			"desc_en": "Class should not be derived from more than one non-interface base class ",
			"desc_cn": "类不应从多个非接口基类派生",
			"abstract": "Class should not be derived from more than one non-interface base class ",
			"explanation": "Classes derived from more than one non-interface base class would make the code more difficult to maintain.",
			"abstract_cn": "类不应从多个非接口基类派生",
			"explanation_cn": "从多个非接口基类派生的类将使代码更难维护。",
			"example_good": "///cpp:\nclass Base1 \n{\n    public:\n        virtual void func1() = 0;\n        virtual void func2() = 0;\n};\n\nclass Base2\n{\n    public:\n        void func3(){}\n        void func4(){}\n};\n\nclass Base3\n{\n    public:\n        virtual void func5() = 0;\n        virtual void func6() = 0;\n};\n\n\n// compliant\n// Only Base2 is not interface class\nclass Derived1 : public Base1,\n                 public Base2\n{};\n\n// compliant\n// Both Base1 and Base3 are interface classes\nclass Derived2 : public Base1,\n                 public Base3\n{};",
			"example_bad": "///cpp:\nclass Base1\n{\n    public:\n        void func1(){}\n};\n\nclass Base2\n{\n    public:\n        void func2(){}\n};\n\n// Non-compliant\n// Base1 and Base2 are both not interface classes\nclass Derived : public Base1,\n                public Base2\n{};",
			"details_en": "#### Abstract\nClass should not be derived from more than one non-interface base class \n\n#### Explanation\nClasses derived from more than one non-interface base class would make the code more difficult to maintain.",
			"details_cn": "#### 概要\n类不应从多个非接口基类派生\n\n#### 解释\n从多个非接口基类派生的类将使代码更难维护。",
			"examples": {
				"good": {
					"cpp": [
						"\nclass Base1 \n{\n    public:\n        virtual void func1() = 0;\n        virtual void func2() = 0;\n};\n\nclass Base2\n{\n    public:\n        void func3(){}\n        void func4(){}\n};\n\nclass Base3\n{\n    public:\n        virtual void func5() = 0;\n        virtual void func6() = 0;\n};\n\n\n// compliant\n// Only Base2 is not interface class\nclass Derived1 : public Base1,\n                 public Base2\n{};\n\n// compliant\n// Both Base1 and Base3 are interface classes\nclass Derived2 : public Base1,\n                 public Base3\n{};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\nclass Base1\n{\n    public:\n        void func1(){}\n};\n\nclass Base2\n{\n    public:\n        void func2(){}\n};\n\n// Non-compliant\n// Base1 and Base2 are both not interface classes\nclass Derived : public Base1,\n                public Base2\n{};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1649752319140"
	},
	{
		"name": "Non-POD type should be defined as class",
		"code": "A11_0_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, non-POD type is not defined as class",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 非 POD 类型没有被定义为类",
			"code": "A11_0_1",
			"override": "T",
			"master_id": "2134",
			"name": "Non-POD type should be defined as class",
			"name_cn": "非 POD 类型应定义为类",
			"compliance": "A",
			"desc_en": "Non-POD type should be defined as class",
			"desc_cn": "非 POD 类型应定义为类",
			"abstract": "Non-POD type should be defined as class",
			"explanation": "The class specifier forces the non-POD type to provide private access control for all its members by default, which is consistent with developer expectations.",
			"abstract_cn": "非 POD 类型应定义为类",
			"explanation_cn": "类说明符强制 non-POD 类型在默认情况下为其所有成员提供专用访问控制，这与开发人员的期望一致。",
			"example_good": "///cpp:\n#include <stdint.h>\n\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Xlass_With_non_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nstruct Struct_with_POD // declared as struct\n{\n  char*   pc;\n};\n\n\nclass Class_with_POD // declared as class\n{\npublic:              // POD declared as public, not conformed to M11-0-1\n  int8_t   c;        \n  char*   pc;\nprivate:\n  int32_t  x;        // data member is private\n};",
			"example_bad": "///cpp:\n#include <stdint.h>\n\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nstruct Struct_With_non_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};",
			"details_en": "#### Abstract\nNon-POD type should be defined as class\n\n#### Explanation\nThe class specifier forces the non-POD type to provide private access control for all its members by default, which is consistent with developer expectations.",
			"details_cn": "#### 概要\n非 POD 类型应定义为类\n\n#### 解释\n类说明符强制 non-POD 类型在默认情况下为其所有成员提供专用访问控制，这与开发人员的期望一致。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <stdint.h>\n\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nclass Xlass_With_non_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};\n\nstruct Struct_with_POD // declared as struct\n{\n  char*   pc;\n};\n\n\nclass Class_with_POD // declared as class\n{\npublic:              // POD declared as public, not conformed to M11-0-1\n  int8_t   c;        \n  char*   pc;\nprivate:\n  int32_t  x;        // data member is private\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <stdint.h>\n\ntypedef char    Letter;  \ntypedef Letter* pLetter;\n  \nstruct Struct_With_non_POD    \n{\npublic:\n  Letter  c;  \n  pLetter p;\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1649760561450"
	},
	{
		"name": "Use inheriting constructors when derived classes do not need further initialization",
		"code": "A12_1_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, when derived classes do not need further initialization, it does not use inheriting constructors.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 当派生类不需要进一步初始化时，没有使用继承构造函数。",
			"code": "A12_1_6",
			"override": "T",
			"master_id": "2135",
			"name": "Use inheriting constructors when derived classes do not need further initialization",
			"name_cn": "当派生类不需要进一步初始化时，请使用继承构造函数",
			"compliance": "R",
			"desc_en": "Use inheriting constructors when derived classes do not need further initialization",
			"desc_cn": "当派生类不需要进一步初始化时，请使用继承构造函数",
			"abstract": "Use inheriting constructors when derived classes do not need further initialization",
			"explanation": "Reimplementation of constructors which do not need further initialization may lead to using wrong base class constructor.",
			"abstract_cn": "当派生类不需要进一步初始化时，请使用继承构造函数",
			"explanation_cn": "重新实现不需要进一步初始化的构造函数可能会导致使用错误的基类构造函数。",
			"example_good": "///cpp:\n#include <iostream>\n\nclass Base {\n  \npublic:\n  // destructor non-virtual\n  ~Base(void) { std::cout << \"Base dtor called\\n\"; }\n};\n\nclass Derived : public Base {\n  \npublic:\n    using Base::Base;\n}; \n\n\nint main()\n{\n    Base* b = new Derived;\n    delete b;\n}",
			"example_bad": "///cpp:\n#include <cstdint>\n#include <iostream>\n\nclass Base {\n  \npublic:\n  // destructor non-virtual\n  ~Base(void) { std::cout << \"Base dtor called\\n\"; }\n  explicit Base(std::int32_t x) : Base(x+1) {}\n};\n\nclass Derived : public Base {\n  \npublic:\n\n  ~Derived(void)  { std::cout<< \"Derived dtor called\\n\"; }\n  explicit Derived(std::int32_t) : Base(x-1) {}\n}; \n\n\nint main()\n{\n    Base* b = new Derived;\n    delete b;\n}\n\n// bad example from document\nclass A  \n{\n    public: \n        A(std::int32_t x, std::int32_t y) : x(x + 8), y(y) {}\n        explicit A(std::int32_t x) : A(x, 0) {}\n\n        private:\n            std::int32_t x;\n            std::int32_t y;\n};\n\n\nclass B : public A\n{\n    public:\n        B(std::int32_t x, std::int32_t y) : A(x, y) {}\n        explicit B(std::int32_t x) : A(x) {}\n}",
			"details_en": "#### Abstract\nUse inheriting constructors when derived classes do not need further initialization\n\n#### Explanation\nReimplementation of constructors which do not need further initialization may lead to using wrong base class constructor.",
			"details_cn": "#### 概要\n当派生类不需要进一步初始化时，请使用继承构造函数\n\n#### 解释\n重新实现不需要进一步初始化的构造函数可能会导致使用错误的基类构造函数。",
			"examples": {
				"good": {
					"cpp": [
						"\n#include <iostream>\n\nclass Base {\n  \npublic:\n  // destructor non-virtual\n  ~Base(void) { std::cout << \"Base dtor called\\n\"; }\n};\n\nclass Derived : public Base {\n  \npublic:\n    using Base::Base;\n}; \n\n\nint main()\n{\n    Base* b = new Derived;\n    delete b;\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n#include <cstdint>\n#include <iostream>\n\nclass Base {\n  \npublic:\n  // destructor non-virtual\n  ~Base(void) { std::cout << \"Base dtor called\\n\"; }\n  explicit Base(std::int32_t x) : Base(x+1) {}\n};\n\nclass Derived : public Base {\n  \npublic:\n\n  ~Derived(void)  { std::cout<< \"Derived dtor called\\n\"; }\n  explicit Derived(std::int32_t) : Base(x-1) {}\n}; \n\n\nint main()\n{\n    Base* b = new Derived;\n    delete b;\n}\n\n// bad example from document\nclass A  \n{\n    public: \n        A(std::int32_t x, std::int32_t y) : x(x + 8), y(y) {}\n        explicit A(std::int32_t x) : A(x, 0) {}\n\n        private:\n            std::int32_t x;\n            std::int32_t y;\n};\n\n\nclass B : public A\n{\n    public:\n        B(std::int32_t x, std::int32_t y) : A(x, y) {}\n        explicit B(std::int32_t x) : A(x) {}\n}"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1649760622183"
	},
	{
		"name": "Operator[] should not be overloaded with only a non-const version",
		"code": "A13_5_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, operator[] is overloaded with only a non-const version",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 下标运算符只定义了非常量版本",
			"code": "A13_5_1",
			"override": "T",
			"master_id": "2136",
			"name": "Operator[] should not be overloaded with only a non-const version",
			"name_cn": "下标运算符不应该只定义非常量版本",
			"compliance": "R",
			"desc_en": "Operator[] should not be overloaded with only a non-const version",
			"desc_cn": "下标运算符不应该只定义非常量版本",
			"abstract": "Operator[] should not be overloaded with only a non-const version",
			"explanation": "If non-const version of operator[] is implemented, it only allows the object to be modified. But it does not allow reading from const object without a const version overload.",
			"abstract_cn": "下标运算符不应该只定义非常量版本",
			"explanation_cn": "如果实现了运算符[]的非常量版本，则只允许修改对象。但在没有常量版本重载的情况下，无法读取常量对象。",
			"example_good": "///cpp:\n// Only non-const version of operator[] is implemented\nclass Test{\n    public:\n        int& operator[](int n) {\n            return elements[n];\n        }\n    private:\n        int* elements;\n};",
			"example_bad": "///cpp:\n// Both const and non-const version of operator[] are implemented\nclass Test{\n    public:\n        int& operator[](int n) {\n            return elements[n];\n        }\n        const int& operator[](int n) const {\n            return elements[n];\n        }\n    private:\n        int* elements;\n};",
			"details_en": "#### Abstract\nOperator[] should not be overloaded with only a non-const version\n\n#### Explanation\nIf non-const version of operator[] is implemented, it only allows the object to be modified. But it does not allow reading from const object without a const version overload.",
			"details_cn": "#### 概要\n下标运算符不应该只定义非常量版本\n\n#### 解释\n如果实现了运算符[]的非常量版本，则只允许修改对象。但在没有常量版本重载的情况下，无法读取常量对象。",
			"examples": {
				"good": {
					"cpp": [
						"\n// Only non-const version of operator[] is implemented\nclass Test{\n    public:\n        int& operator[](int n) {\n            return elements[n];\n        }\n    private:\n        int* elements;\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						"\n// Both const and non-const version of operator[] are implemented\nclass Test{\n    public:\n        int& operator[](int n) {\n            return elements[n];\n        }\n        const int& operator[](int n) const {\n            return elements[n];\n        }\n    private:\n        int* elements;\n};"
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1649760661714"
	},
	{
		"name": "Each identifier declaration should be on a separate line",
		"code": "A7_1_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c++",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, expression statement and identifier declaration are placed on the same line",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 表达式语句和标识符声明放在同一行",
			"code": "A7_1_7",
			"override": "T",
			"master_id": "2137",
			"name": "Each identifier declaration should be on a separate line",
			"name_cn": "每个标识符声明应该在单独的行上",
			"compliance": "R",
			"desc_en": "Each identifier declaration should be on a separate line",
			"desc_cn": "每个标识符声明应该在单独的行上",
			"abstract": "Each identifier declaration should be on a separate line",
			"explanation": "Placing expression statement and identifier declaration on the same line may be confusing.",
			"abstract_cn": "每个标识符声明应该在单独的行上",
			"explanation_cn": "将表达式语句和标识符声明放在同一行可能会造成混淆。",
			"example_good": "///cpp:",
			"example_bad": "///cpp:",
			"details_en": "#### Abstract\nEach identifier declaration should be on a separate line\n\n#### Explanation\nPlacing expression statement and identifier declaration on the same line may be confusing.",
			"details_cn": "#### 概要\n每个标识符声明应该在单独的行上\n\n#### 解释\n将表达式语句和标识符声明放在同一行可能会造成混淆。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1650778245918"
	},
	{
		"name": "Octal and hexadecimal escape sequences should not be followed by other characters",
		"code": "MSR_4_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, octal and hexadecimal escape sequences are not terminated",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 八进制和十六进制转义序列没有被终止",
			"code": "MSR_4_1",
			"override": "T",
			"master_id": "2138",
			"name": "Octal and hexadecimal escape sequences should not be followed by other characters",
			"name_cn": "八进制和十六进制转义序列不应后跟其他字符",
			"compliance": "R",
			"desc_en": "Octal and hexadecimal escape sequences should not be followed by other characters",
			"desc_cn": "八进制和十六进制转义序列不应后跟其他字符",
			"abstract": "Octal and hexadecimal escape sequences should not be followed by other characters",
			"explanation": "Octal and hexadecimal escape sequences should be followed by end of literal or another escape sequence in order to reduce confusion.",
			"abstract_cn": "八进制和十六进制转义序列不应后跟其他字符",
			"explanation_cn": "为了减少混淆，八进制和十六进制转义序列应该跟在文字结尾或另一个转义序列之后。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nOctal and hexadecimal escape sequences should not be followed by other characters\n\n#### Explanation\nOctal and hexadecimal escape sequences should be followed by end of literal or another escape sequence in order to reduce confusion.",
			"details_cn": "#### 概要\n八进制和十六进制转义序列不应后跟其他字符\n\n#### 解释\n为了减少混淆，八进制和十六进制转义序列应该跟在文字结尾或另一个转义序列之后。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1652407573811"
	},
	{
		"name": "Do not use octal constants",
		"code": "MSR_7_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, octal constants are used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 八进制常量被使用了",
			"code": "MSR_7_1",
			"override": "T",
			"master_id": "2139",
			"name": "Do not use octal constants",
			"name_cn": "不应使用八进制常量",
			"compliance": "R",
			"desc_en": "Do not use octal constants",
			"desc_cn": "不应使用八进制常量",
			"abstract": "Do not use octal constants",
			"explanation": "Constants with a leading zero might be interpreted as decimal constants and may cause confusion.",
			"abstract_cn": "不应使用八进制常量",
			"explanation_cn": "零开头的常量可能会被解释为十进制常量，这会引起混淆。",
			"example_good": "///c:\nint a1 = 1;   // compliant\nint a2 = 2;   // compliant\nint a3 = 3;   // compliant",
			"example_bad": "///c:\nint a1 = 01;   // non-compliant\nint a2 = 02;   // non-compliant\nint a3 = 03;   // non-compliant",
			"details_en": "#### Abstract\nDo not use octal constants\n\n#### Explanation\nConstants with a leading zero might be interpreted as decimal constants and may cause confusion.",
			"details_cn": "#### 概要\n不应使用八进制常量\n\n#### 解释\n零开头的常量可能会被解释为十进制常量，这会引起混淆。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nint a1 = 1;   // compliant\nint a2 = 2;   // compliant\nint a3 = 3;   // compliant"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nint a1 = 01;   // non-compliant\nint a2 = 02;   // non-compliant\nint a3 = 03;   // non-compliant"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1652411857654"
	},
	{
		"name": "All unsigned integer constansts should have suffice \"u\" or \"U\"",
		"code": "MSR_7_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a “u” or “U” suffix are not applied to integer constants represented in unsigned type",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, “u”或“U”后缀没有被用于以无符号类型表示的整数常量",
			"code": "MSR_7_2",
			"override": "T",
			"master_id": "2140",
			"name": "All unsigned integer constansts should have suffice \"u\" or \"U\"",
			"name_cn": "应将“u”或“U”后缀应用于以无符号类型表示的所有整数常量",
			"compliance": "R",
			"desc_en": "All unsigned integer constansts should have suffice \"u\" or \"U\"",
			"desc_cn": "应将“u”或“U”后缀应用于以无符号类型表示的所有整数常量",
			"abstract": "All unsigned integer constansts should have suffice \"u\" or \"U\"",
			"explanation": "Applying a \"u\" or \"U\" suffix can help clarify the unsigned constant.",
			"abstract_cn": "应将“u”或“U”后缀应用于以无符号类型表示的所有整数常量",
			"explanation_cn": "应用“u”或“U”后缀可以让程序员清楚地知道该常量是无符号的。",
			"example_good": "///c:\n#include <stdint.h>\n\nuint16_t a = 0x8000u;   // compliant\nunsigned int b = 0xffu; // compliant",
			"example_bad": "///c:\nunsigned int a = 3;     // non-compliant\nunsigned int b = 0xff;  // non-compliant",
			"details_en": "#### Abstract\nAll unsigned integer constansts should have suffice \"u\" or \"U\"\n\n#### Explanation\nApplying a \"u\" or \"U\" suffix can help clarify the unsigned constant.",
			"details_cn": "#### 概要\n应将“u”或“U”后缀应用于以无符号类型表示的所有整数常量\n\n#### 解释\n应用“u”或“U”后缀可以让程序员清楚地知道该常量是无符号的。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdint.h>\n\nuint16_t a = 0x8000u;   // compliant\nunsigned int b = 0xffu; // compliant"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nunsigned int a = 3;     // non-compliant\nunsigned int b = 0xff;  // non-compliant"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1652418092480"
	},
	{
		"name": "Do not use lowercase “l” in literal declaration ",
		"code": "MSR_7_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the lowercase character “l” is used in a literal suffix",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 小写字母“l”被用于文字后缀",
			"code": "MSR_7_3",
			"override": "T",
			"master_id": "2141",
			"name": "Do not use lowercase “l” in literal declaration ",
			"name_cn": "不要在文字声明中使用小写“l”",
			"compliance": "R",
			"desc_en": "Do not use lowercase “l” in literal declaration ",
			"desc_cn": "不要在文字声明中使用小写“l”",
			"abstract": "Do not use lowercase “l” in literal declaration ",
			"explanation": "The lowercase “l” might be confused with digit 1 when declaring literals.",
			"abstract_cn": "不要在文字声明中使用小写“l”",
			"explanation_cn": "在声明文字时，小写的“l”可能会与数字 1 混淆。",
			"example_good": "///c:\n#include <stdio.h>\n\n// using uppercase \"L\" to replace lowercase \"l\"\nint a = 1L;\nfloat b = 1.1L;\n",
			"example_bad": "///c:\n#include <stdio.h>\n\n// potential ambiguity betweem digit 1 and \"l\"\nint a = 1l;\nfloat b = 1.1l;",
			"details_en": "#### Abstract\nDo not use lowercase “l” in literal declaration \n\n#### Explanation\nThe lowercase “l” might be confused with digit 1 when declaring literals.",
			"details_cn": "#### 概要\n不要在文字声明中使用小写“l”\n\n#### 解释\n在声明文字时，小写的“l”可能会与数字 1 混淆。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// using uppercase \"L\" to replace lowercase \"l\"\nint a = 1L;\nfloat b = 1.1L;\n"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n\n// potential ambiguity betweem digit 1 and \"l\"\nint a = 1l;\nfloat b = 1.1l;"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1652421737697"
	},
	{
		"name": "Use braces to enclose initialization of an aggregate or union",
		"code": "MSR_9_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the initializer for an aggregate or union is not enclosed in braces",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func},  没有使用大括号以指示和匹配数组和结构的非零初始化构造",
			"code": "MSR_9_2",
			"override": "T",
			"master_id": "2142",
			"name": "Use braces to enclose initialization of an aggregate or union",
			"name_cn": "使用大括号括起聚合或联合的初始化",
			"compliance": "R",
			"desc_en": "Use braces to enclose initialization of an aggregate or union",
			"desc_cn": "使用大括号括起聚合或联合的初始化",
			"abstract": "Use braces to enclose initialization of an aggregate or union",
			"explanation": "Using braces for initialization of subobjects makes it easier for programmers to understand multi-dimensional arrays",
			"abstract_cn": "使用大括号括起聚合或联合的初始化",
			"explanation_cn": "使用大括号初始化子对象能够让程序员更容易理解多维数组",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nUse braces to enclose initialization of an aggregate or union\n\n#### Explanation\nUsing braces for initialization of subobjects makes it easier for programmers to understand multi-dimensional arrays",
			"details_cn": "#### 概要\n使用大括号括起聚合或联合的初始化\n\n#### 解释\n使用大括号初始化子对象能够让程序员更容易理解多维数组",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1652751763322"
	},
	{
		"name": "Do not use inappropriate essential type operands in an expression",
		"code": "MSR_10_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, inappropriate essential type operands in an expression are used.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 表达式中使用了不适当的基本类型操作数",
			"code": "MSR_10_1",
			"override": "T",
			"master_id": "2143",
			"name": "Do not use inappropriate essential type operands in an expression",
			"name_cn": "不要在表达式中使用不适当的基本类型操作数",
			"compliance": "R",
			"desc_en": "Do not use inappropriate essential type operands in an expression",
			"desc_cn": "不要在表达式中使用不适当的基本类型操作数",
			"abstract": "Do not use inappropriate essential type operands in an expression",
			"explanation": "Expressions with inappropriate essential types may cause unexpected behavior. For complete description of essential type, please refer to the table from official MISRA document: 8.10.2.",
			"abstract_cn": "不要在表达式中使用不适当的基本类型操作数",
			"explanation_cn": "具有不适当基本类型的表达式可能会导致意外行为。 有关基本类型的完整描述，请参阅官方 MISRA 文档中的表格：8.10.2。",
			"example_good": "///c:\nextern char rcha, cha, chb; \nextern unsigned char ru8a, u8a;\n\nvoid func() \n{\n  ru8a = u8a & 2U;       // compliant\t\n  ru8a = u8a << 2U;      // compliant\n}",
			"example_bad": "///c:\nextern char rcha, cha, chb; \nextern unsigned char ru8a, u8a;\n\nvoid func() \n{\n  rcha = cha & chb;      // non-compliant; char type used as a numeric value */\n  rcha = cha << 1;       // non-compliant; char type used as a numeric value */\n}",
			"details_en": "#### Abstract\nDo not use inappropriate essential type operands in an expression\n\n#### Explanation\nExpressions with inappropriate essential types may cause unexpected behavior. For complete description of essential type, please refer to the table from official MISRA document: 8.10.2.",
			"details_cn": "#### 概要\n不要在表达式中使用不适当的基本类型操作数\n\n#### 解释\n具有不适当基本类型的表达式可能会导致意外行为。 有关基本类型的完整描述，请参阅官方 MISRA 文档中的表格：8.10.2。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nextern char rcha, cha, chb; \nextern unsigned char ru8a, u8a;\n\nvoid func() \n{\n  ru8a = u8a & 2U;       // compliant\t\n  ru8a = u8a << 2U;      // compliant\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nextern char rcha, cha, chb; \nextern unsigned char ru8a, u8a;\n\nvoid func() \n{\n  rcha = cha & chb;      // non-compliant; char type used as a numeric value */\n  rcha = cha << 1;       // non-compliant; char type used as a numeric value */\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1652763140312"
	},
	{
		"name": "The precedence of operators must be clear and unambiguous",
		"code": "MSR_12_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, the precedence of operators within expressions is not clear and unambiguous",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 表达式中运算符的优先级不清晰明确",
			"code": "MSR_12_1",
			"override": "T",
			"master_id": "2144",
			"name": "The precedence of operators must be clear and unambiguous",
			"name_cn": "运算符的优先级必须清晰明确",
			"compliance": "A",
			"desc_en": "The precedence of operators must be clear and unambiguous",
			"desc_cn": "运算符的优先级必须清晰明确",
			"abstract": "The precedence of operators must be clear and unambiguous",
			"explanation": "The use of parentheses within expressions improves the readability of the code and also avoids any misunderstanding",
			"abstract_cn": "运算符的优先级必须清晰明确",
			"explanation_cn": "在表达式中使用括号提高了代码的可读性，也避免了任何误解",
			"example_good": "///c:",
			"example_bad": "///c:",
			"details_en": "#### Abstract\nThe precedence of operators must be clear and unambiguous\n\n#### Explanation\nThe use of parentheses within expressions improves the readability of the code and also avoids any misunderstanding",
			"details_cn": "#### 概要\n运算符的优先级必须清晰明确\n\n#### 解释\n在表达式中使用括号提高了代码的可读性，也避免了任何误解",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1652764962801"
	},
	{
		"name": "Switch statements should be well-formed",
		"code": "MSR_16_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, switch statements are not well-formed",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, switch 语句格式不正确",
			"code": "MSR_16_1",
			"override": "T",
			"master_id": "2145",
			"name": "Switch statements should be well-formed",
			"name_cn": "所有 switch 语句都应格式正确",
			"compliance": "R",
			"desc_en": "Use well-formed switch statements",
			"desc_cn": "所有 switch 语句都应格式正确",
			"abstract": "All switch statements should be well-formed",
			"explanation": "Well-formed switch statements improve readability of the code. For complete description of well-formed switch statements, please refer to MISRA C:2012, 8.16.",
			"abstract_cn": "所有 switch 语句都应格式正确",
			"explanation_cn": "格式良好的 switch 语句提高了代码的可读性。有关格式良好的 switch 语句的完整描述，请参阅 MISRA C:2012, 8.16。",
			"example_good": "///c:",
			"example_bad": "///c:",
			"details_en": "#### Abstract\nAll switch statements should be well-formed\n\n#### Explanation\nWell-formed switch statements improve readability of the code. For complete description of well-formed switch statements, please refer to MISRA C:2012, 8.16.",
			"details_cn": "#### 概要\n所有 switch 语句都应格式正确\n\n#### 解释\n格式良好的 switch 语句提高了代码的可读性。有关格式良好的 switch 语句的完整描述，请参阅 MISRA C:2012, 8.16。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1652797905917"
	},
	{
		"name": "Function declaration should be clear and unambiguous",
		"code": "MSR_17_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a function is declared implicitly",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 存在隐式声明函数",
			"code": "MSR_17_3",
			"override": "T",
			"master_id": "2146",
			"name": "Function declaration should be clear and unambiguous",
			"name_cn": "函数声明应该清晰明确",
			"compliance": "M",
			"desc_en": "Function declaration should be clear and unambiguous",
			"desc_cn": "函数声明应该清晰明确",
			"abstract": "Function declaration should be clear and unambiguous",
			"explanation": "Compilers for C90 assumes that the function which is declared implicitly has return type of int, which may lead to undefined behaviour.",
			"abstract_cn": "函数声明应该清晰明确",
			"explanation_cn": "C90 编译器假定隐式声明的函数具有 int 的返回类型，这可能导致未定义的行为。",
			"example_good": "///c:\nint some_function();\n\nint main(int argc, char** argv)\n{\n    double x = some_function(); // compliant\n    return 0;\n}",
			"example_bad": "///c:\nint main(int argc, char** argv)\n{\n    double x = some_function(); // non-compliant\n    return 0;\n}",
			"details_en": "#### Abstract\nFunction declaration should be clear and unambiguous\n\n#### Explanation\nCompilers for C90 assumes that the function which is declared implicitly has return type of int, which may lead to undefined behaviour.",
			"details_cn": "#### 概要\n函数声明应该清晰明确\n\n#### 解释\nC90 编译器假定隐式声明的函数具有 int 的返回类型，这可能导致未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nint some_function();\n\nint main(int argc, char** argv)\n{\n    double x = some_function(); // compliant\n    return 0;\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nint main(int argc, char** argv)\n{\n    double x = some_function(); // non-compliant\n    return 0;\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1652882997601"
	},
	{
		"name": "Place #include directives before variable & function declaration and program statements",
		"code": "MSR_20_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, #include directives are placed after variable & function declaration and program statements",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, #include 指令放在变量和函数声明和程序语句之后",
			"code": "MSR_20_1",
			"override": "T",
			"master_id": "2147",
			"name": "Place #include directives before variable & function declaration and program statements",
			"name_cn": "将#include 指令放在变量和函数声明和程序语句之前",
			"compliance": "A",
			"desc_en": "Place #include directives before variable & function declaration and program statements",
			"desc_cn": "将#include 指令放在变量和函数声明和程序语句之前",
			"abstract": "Place #include directives before variable & function declaration and program statements",
			"explanation": "#include directives should be grouped near the top of the file in order to improve code readability.",
			"abstract_cn": "将#include 指令放在变量和函数声明和程序语句之前",
			"explanation_cn": "#include 指令应在文件顶部附近以提高代码可读性。",
			"example_good": "///c:\n#include <stdio.h> // compliant\n\nvoid func();\n",
			"example_bad": "///c:\nvoid func();\n\n// non-compliant\n// #include directives should be at the top of the file\n#include <stdio.h>",
			"details_en": "#### Abstract\nPlace #include directives before variable & function declaration and program statements\n\n#### Explanation\n#include directives should be grouped near the top of the file in order to improve code readability.",
			"details_cn": "#### 概要\n将#include 指令放在变量和函数声明和程序语句之前\n\n#### 解释\n#include 指令应在文件顶部附近以提高代码可读性。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h> // compliant\n\nvoid func();\n"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\nvoid func();\n\n// non-compliant\n// #include directives should be at the top of the file\n#include <stdio.h>"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1652887528298"
	},
	{
		"name": "Pointer arguments for memcpy, memmove and memcpy should be of compatible types, qualified or unqualified",
		"code": "MSR_21_15",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, pointer arguments for memcpy, memmove and memcpy are not of compatible types, qualified or unqualified",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, memcpy、memmove 和 memcpy 的指针参数不是兼容的类型、合格的或不合格的",
			"code": "MSR_21_15",
			"override": "T",
			"master_id": "2148",
			"name": "Pointer arguments for memcpy, memmove and memcpy should be of compatible types, qualified or unqualified",
			"name_cn": "memcpy、memmove 和 memcpy 的指针参数应该是兼容的类型，合格或不合格",
			"compliance": "R",
			"desc_en": "Pointer arguments for memcpy, memmove and memcpy should be of compatible types, qualified or unqualified",
			"desc_cn": "memcpy、memmove 和 memcpy 的指针参数应该是兼容的类型，合格或不合格",
			"abstract": "Pointer arguments for memcpy, memmove and memcpy should be of compatible types, qualified or unqualified",
			"explanation": "Calling functions: memcpy, memmove or memcmp with arguments of  different types (regardless of qualified or unqualified) can result in unexpected behavior.",
			"abstract_cn": "memcpy、memmove 和 memcpy 的指针参数应该是兼容的类型，合格或不合格",
			"explanation_cn": "调用函数：memcpy、memmove 或 memcmp 带有不同类型的参数（无论合格或不合格）可能会导致意外行为。",
			"example_good": "///c:\n#include <stdio.h>\n#include <string.h>\n\nint main ()\n{\n   char str1[5];\n   char str2[5];\n   int ret;\n\n   memcpy(str1, \"abcd\", 4); // compliant\n   memcpy(str2, \"ABCD\", 4); // compliant\n\n   ret = memcmp(str1, str2, 5); // compliant\n\n   if(ret > 0)\n   {\n      printf(\"str2 smaller than str1\");\n   }\n   else if(ret < 0)\n   {\n      printf(\"str1 smaller than str2\");\n   }\n   else\n   {\n      printf(\"str1 equals str2\");\n   }\n}",
			"example_bad": "///c:\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\nint main ()\n{\n   int8_t a[5];\n   int16_t b[5];\n   int32_t c[5];\n\n   // non-compliant\n   // call memcpy with arguments of different types\n   memcpy(a, b, 5);\n   memcpy(b, c, 5);\n}",
			"details_en": "#### Abstract\nPointer arguments for memcpy, memmove and memcpy should be of compatible types, qualified or unqualified\n\n#### Explanation\nCalling functions: memcpy, memmove or memcmp with arguments of  different types (regardless of qualified or unqualified) can result in unexpected behavior.",
			"details_cn": "#### 概要\nmemcpy、memmove 和 memcpy 的指针参数应该是兼容的类型，合格或不合格\n\n#### 解释\n调用函数：memcpy、memmove 或 memcmp 带有不同类型的参数（无论合格或不合格）可能会导致意外行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <string.h>\n\nint main ()\n{\n   char str1[5];\n   char str2[5];\n   int ret;\n\n   memcpy(str1, \"abcd\", 4); // compliant\n   memcpy(str2, \"ABCD\", 4); // compliant\n\n   ret = memcmp(str1, str2, 5); // compliant\n\n   if(ret > 0)\n   {\n      printf(\"str2 smaller than str1\");\n   }\n   else if(ret < 0)\n   {\n      printf(\"str1 smaller than str2\");\n   }\n   else\n   {\n      printf(\"str1 equals str2\");\n   }\n}"
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						"\n#include <stdio.h>\n#include <string.h>\n#include <stdint.h>\n\nint main ()\n{\n   int8_t a[5];\n   int16_t b[5];\n   int32_t c[5];\n\n   // non-compliant\n   // call memcpy with arguments of different types\n   memcpy(a, b, 5);\n   memcpy(b, c, 5);\n}"
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1652956573431"
	},
	{
		"name": "Pointer arguments to memcmp should be a pointer type or essential type of following: signed, unsigned, boolean, enum",
		"code": "MSR_21_16",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, pointer arguments to memcmp are not a pointer type or essential type of following: signed, unsigned, boolean, enum",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, memcmp 的指针参数不是指针类型或以下基本类型：有符号、无符号、布尔值、枚举",
			"code": "MSR_21_16",
			"override": "T",
			"master_id": "2149",
			"name": "Pointer arguments to memcmp should be a pointer type or essential type of following: signed, unsigned, boolean, enum",
			"name_cn": "memcmp 的指针参数应该是指针类型或以下基本类型：有符号、无符号、布尔值、枚举",
			"compliance": "R",
			"desc_en": "Pointer arguments to memcmp should be a pointer type or essential type of following: signed, unsigned, boolean, enum",
			"desc_cn": "memcmp 的指针参数应该是指针类型或以下基本类型：有符号、无符号、布尔值、枚举",
			"abstract": "Pointer arguments to memcmp should be a pointer type or essential type of following: signed, unsigned, boolean, enum",
			"explanation": "Structures and unions may contain padding with an indeterminate value, which would be added complication in memcmp and be reported incorrectly.",
			"abstract_cn": "memcmp 的指针参数应该是指针类型或以下基本类型：有符号、无符号、布尔值、枚举",
			"explanation_cn": "结构和联合可能包含具有不确定值的填充，这将在 memcmp 中增加复杂性并被错误地报告。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nPointer arguments to memcmp should be a pointer type or essential type of following: signed, unsigned, boolean, enum\n\n#### Explanation\nStructures and unions may contain padding with an indeterminate value, which would be added complication in memcmp and be reported incorrectly.",
			"details_cn": "#### 概要\nmemcmp 的指针参数应该是指针类型或以下基本类型：有符号、无符号、布尔值、枚举\n\n#### 解释\n结构和联合可能包含具有不确定值的填充，这将在 memcmp 中增加复杂性并被错误地报告。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1652956863422"
	},
	{
		"name": "Do not dereference a FILE pointer",
		"code": "MSR_22_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a pointer to a FILE object is dereferenced",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 指向 FILE 对象的指针被逆向引用",
			"code": "MSR_22_5",
			"override": "T",
			"master_id": "2150",
			"name": "Do not dereference a FILE pointer",
			"name_cn": "不应逆向引用指向 FILE 对象的指针",
			"compliance": "M",
			"desc_en": "Do not dereference a FILE pointer",
			"desc_cn": "不应逆向引用指向 FILE 对象的指针",
			"abstract": "Do not dereference a FILE pointer",
			"explanation": "The FILE object should not be manipulated directly. Otherwise, it might be inconsistent  with its use as a stream designator.",
			"abstract_cn": "不应逆向引用指向 FILE 对象的指针",
			"explanation_cn": "不应直接操作 FILE 对象。 否则，它可能与它作为流指示符的用途不一致。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nDo not dereference a FILE pointer\n\n#### Explanation\nThe FILE object should not be manipulated directly. Otherwise, it might be inconsistent  with its use as a stream designator.",
			"details_cn": "#### 概要\n不应逆向引用指向 FILE 对象的指针\n\n#### 解释\n不应直接操作 FILE 对象。 否则，它可能与它作为流指示符的用途不一致。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1652971179972"
	},
	{
		"name": "External linkage objects or functions should not have the same identifier",
		"code": "MSR_5_8",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, external linkage objects or functions  have the same identifier",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 外部链接对象或函数具有相同的标识符",
			"code": "MSR_5_8",
			"master_id": "2151",
			"name": "External linkage objects or functions should not have the same identifier",
			"name_cn": "外部链接对象或函数不应具有相同的标识符",
			"compliance": "R",
			"desc_en": "External linkage objects or functions should not have the same identifier",
			"desc_cn": "外部链接对象或函数不应具有相同的标识符",
			"abstract": "External linkage objects or functions should not have the same identifier",
			"explanation": "Using the same identifier to define objects or functions with external linkage is confusing.",
			"abstract_cn": "外部链接对象或函数不应具有相同的标识符",
			"explanation_cn": "使用相同的标识符来定义具有外部链接的对象或函数是令人困惑的。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nExternal linkage objects or functions should not have the same identifier\n\n#### Explanation\nUsing the same identifier to define objects or functions with external linkage is confusing.",
			"details_cn": "#### 概要\n外部链接对象或函数不应具有相同的标识符\n\n#### 解释\n使用相同的标识符来定义具有外部链接的对象或函数是令人困惑的。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1655359955614"
	},
	{
		"name": "Internal linkage objects or functions should not have the same identifier",
		"code": "MSR_5_9",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, internal linkage objects or functions  have the same identifier",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 内部链接对象或函数具有相同的标识符",
			"code": "MSR_5_9",
			"override": "T",
			"master_id": "2152",
			"name": "Internal linkage objects or functions should not have the same identifier",
			"name_cn": "内部链接对象或函数不应具有相同的标识符",
			"compliance": "A",
			"desc_en": "Internal linkage objects or functions should not have the same identifier",
			"desc_cn": "内部链接对象或函数不应具有相同的标识符",
			"abstract": "Internal linkage objects or functions should not have the same identifier",
			"explanation": "Using the same identifier to define objects or functions with internal linkage is confusing.",
			"abstract_cn": "内部链接对象或函数不应具有相同的标识符",
			"explanation_cn": "使用相同的标识符来定义具有内部链接的对象或函数是令人困惑的。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nInternal linkage objects or functions should not have the same identifier\n\n#### Explanation\nUsing the same identifier to define objects or functions with internal linkage is confusing.",
			"details_cn": "#### 概要\n内部链接对象或函数不应具有相同的标识符\n\n#### 解释\n使用相同的标识符来定义具有内部链接的对象或函数是令人困惑的。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1655361905202"
	},
	{
		"name": "Do not use more than one return statement in a function",
		"code": "MSR_15_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, more than one return statement is used in a function",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 在一个函数中使用了多个 return 语句",
			"code": "MSR_15_5",
			"override": "T",
			"master_id": "2153",
			"name": "Do not use more than one return statement in a function",
			"name_cn": "不要在一个函数中使用多个 return 语句",
			"compliance": "A",
			"desc_en": "Do not use more than one return statement in a function",
			"desc_cn": "不要在一个函数中使用多个 return 语句",
			"abstract": "Do not use more than one return statement in a function",
			"explanation": "If a return statement is used before the end of function, it may unintentionally miss portion of the function termination code.",
			"abstract_cn": "不要在一个函数中使用多个 return 语句",
			"explanation_cn": "如果在函数结束之前使用 return 语句，它可能会无意中错过部分函数终止代码。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nDo not use more than one return statement in a function\n\n#### Explanation\nIf a return statement is used before the end of function, it may unintentionally miss portion of the function termination code.",
			"details_cn": "#### 概要\n不要在一个函数中使用多个 return 语句\n\n#### 解释\n如果在函数结束之前使用 return 语句，它可能会无意中错过部分函数终止代码。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1655712458683"
	},
	{
		"name": "Relational operators should not be applied to pointers to different objects types",
		"code": "MSR_18_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, relational operators are applied to pointers to different objects types",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 关系运算符被应用于指向不同对象类型的指针",
			"code": "MSR_18_3",
			"override": "T",
			"master_id": "2154",
			"name": "Relational operators should not be applied to pointers to different objects types",
			"name_cn": "关系运算符不应用于指向不同对象类型的指针",
			"compliance": "R",
			"desc_en": "Relational operators should not be applied to pointers to different objects types",
			"desc_cn": "关系运算符不应用于指向不同对象类型的指针",
			"abstract": "Relational operators should not be applied to pointers to different objects types",
			"explanation": "Comparisons between pointers which point to different objects would lead to undefined behaviour.",
			"abstract_cn": "关系运算符不应用于指向不同对象类型的指针",
			"explanation_cn": "指向不同对象的指针之间的比较会导致未定义的行为。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nRelational operators should not be applied to pointers to different objects types\n\n#### Explanation\nComparisons between pointers which point to different objects would lead to undefined behaviour.",
			"details_cn": "#### 概要\n关系运算符不应用于指向不同对象类型的指针\n\n#### 解释\n指向不同对象的指针之间的比较会导致未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1655716909567"
	},
	{
		"name": "Do not copy or assigned an object to another with overlapped memory address",
		"code": "MSR_19_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, an object is assigned or copied to another with overlapped memory address",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 一个对象被分配或复制到另一个具有内存重叠的对象",
			"code": "MSR_19_1",
			"override": "T",
			"master_id": "2155",
			"name": "Do not copy or assigned an object to another with overlapped memory address",
			"name_cn": "不要将对象分配或复制到另一个具有内存重叠的对象",
			"compliance": "M",
			"desc_en": "Do not copy or assigned an object to another with overlapped memory address",
			"desc_cn": "不要将对象分配或复制到另一个具有内存重叠的对象",
			"abstract": "Do not copy or assigned an object to another with overlapped memory address",
			"explanation": "If two objects have overlap in memory, assignment and copying between them is undefined behavior.",
			"abstract_cn": "不要将对象分配或复制到另一个具有内存重叠的对象",
			"explanation_cn": "如果两个对象在内存中有重叠，则它们之间的赋值和复制是未定义的行为。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nDo not copy or assigned an object to another with overlapped memory address\n\n#### Explanation\nIf two objects have overlap in memory, assignment and copying between them is undefined behavior.",
			"details_cn": "#### 概要\n不要将对象分配或复制到另一个具有内存重叠的对象\n\n#### 解释\n如果两个对象在内存中有重叠，则它们之间的赋值和复制是未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1655798528832"
	},
	{
		"name": "Pass unsigned char or EOF only to any function in ctype.h",
		"code": "MSR_21_13",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, value other than char or EOF is passed to functions in ctype.h",
			"msg_templ_cn": "In file ${so.filename}, line ${so.line}, ${so.func}, 将 char 或 EOF 以外的值传递给 ctype.h 中的函数",
			"code": "MSR_21_13",
			"override": "T",
			"master_id": "2156",
			"name": "Pass unsigned char or EOF only to any function in ctype.h",
			"name_cn": "仅将 unsigned char 或 EOF 传递给 ctype.h 中的任何函数",
			"compliance": "M",
			"desc_en": "Pass unsigned char or EOF only to any function in ctype.h",
			"desc_cn": "仅将 unsigned char 或 EOF 传递给 ctype.h 中的任何函数",
			"abstract": "Pass unsigned char or EOF only to any function in ctype.h",
			"explanation": "Passing any value other than an unsigned char or EOF to a function in <ctype.h> is undefined behavior.",
			"abstract_cn": "仅将 unsigned char 或 EOF 传递给 ctype.h 中的任何函数",
			"explanation_cn": "将除无符号char或EOF之外的任何值传递给 <ctype.h> 中的函数是未定义的行为。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nPass unsigned char or EOF only to any function in ctype.h\n\n#### Explanation\nPassing any value other than an unsigned char or EOF to a function in <ctype.h> is undefined behavior.",
			"details_cn": "#### 概要\n仅将 unsigned char 或 EOF 传递给 ctype.h 中的任何函数\n\n#### 解释\n将除无符号char或EOF之外的任何值传递给 <ctype.h> 中的函数是未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1655802346468"
	},
	{
		"name": "Do not use string handling functions with accesses beyond the bounds of parameter",
		"code": "MSR_21_17",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, string handling functions are used with accesses beyond the bounds of parameter",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 字符串处理函数被用于超出参数范围的访问",
			"code": "MSR_21_17",
			"override": "T",
			"master_id": "2157",
			"name": "Do not use string handling functions with accesses beyond the bounds of parameter",
			"name_cn": "不要将字符串处理函数用于超出参数范围的访问",
			"compliance": "M",
			"desc_en": "Do not use string handling functions with accesses beyond the bounds of parameter",
			"desc_cn": "不要将字符串处理函数用于超出参数范围的访问",
			"abstract": "Do not use string handling functions with accesses beyond the bounds of parameter",
			"explanation": "The use of string handling functions with accesses beyond the bounds of parameter would lead to undefined behavior.",
			"abstract_cn": "不要将字符串处理函数用于超出参数范围的访问",
			"explanation_cn": "通过字符串处理函数进行超出参数范围的访问将导致未定义的行为。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nDo not use string handling functions with accesses beyond the bounds of parameter\n\n#### Explanation\nThe use of string handling functions with accesses beyond the bounds of parameter would lead to undefined behavior.",
			"details_cn": "#### 概要\n不要将字符串处理函数用于超出参数范围的访问\n\n#### 解释\n通过字符串处理函数进行超出参数范围的访问将导致未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1655879980044"
	},
	{
		"name": "Functions in <string.h> should have size_t argument with appropriate value",
		"code": "MSR_21_18",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, functions in <string.h> do not have size_t argument with appropriate value",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, <string.h>中函数的size_t参数没有取合适的值",
			"code": "MSR_21_18",
			"override": "T",
			"master_id": "2158",
			"name": "Functions in <string.h> should have size_t argument with appropriate value",
			"name_cn": "<string.h>中函数的size_t参数应该具有合适的值",
			"compliance": "M",
			"desc_en": "Functions in <string.h> should have size_t argument with appropriate value",
			"desc_cn": "<string.h>中函数的size_t参数应该具有合适的值",
			"abstract": "Functions in <string.h> should have size_t argument with appropriate value",
			"explanation": "Inappropriate value of size_t argument for functions in <string.h> would lead to undefined behaviors.",
			"abstract_cn": "<string.h>中函数的size_t参数应该具有合适的值",
			"explanation_cn": "<string.h>中函数的size_t参数取值不适当会导致未定义的行为。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nFunctions in <string.h> should have size_t argument with appropriate value\n\n#### Explanation\nInappropriate value of size_t argument for functions in <string.h> would lead to undefined behaviors.",
			"details_cn": "#### 概要\n<string.h>中函数的size_t参数应该具有合适的值\n\n#### 解释\n<string.h>中函数的size_t参数取值不适当会导致未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1655882663028"
	},
	{
		"name": "localeconv, getenv, setlocale and strerror should have return type of pointer to const-qulified",
		"code": "MSR_21_19",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, localeconv, getenv, setlocale and strerror do not have return type of pointer to const-qulified",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, localeconv、getenv、setlocale和strerror的返回类型不是指向const qulified的指针",
			"code": "MSR_21_19",
			"override": "T",
			"master_id": "2159",
			"name": "localeconv, getenv, setlocale and strerror should have return type of pointer to const-qulified",
			"name_cn": "localeconv、getenv、setlocale和strerror的返回类型应该是指向const qulified的指针",
			"compliance": "M",
			"desc_en": "localeconv, getenv, setlocale and strerror should have return type of pointer to const-qulified",
			"desc_cn": "localeconv、getenv、setlocale和strerror的返回类型应该是指向const qulified的指针",
			"abstract": "localeconv, getenv, setlocale and strerror should have return type of pointer to const-qulified",
			"explanation": "Modifying the return pointers by localeconv、getenv、setlocale and strerror would lead to undefined behaviors.",
			"abstract_cn": "localeconv、getenv、setlocale和strerror的返回类型应该是指向const qulified的指针",
			"explanation_cn": "修改localeconv、getenv、setlocale和strerror的返回指针将导致未定义的行为。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nlocaleconv, getenv, setlocale and strerror should have return type of pointer to const-qulified\n\n#### Explanation\nModifying the return pointers by localeconv、getenv、setlocale and strerror would lead to undefined behaviors.",
			"details_cn": "#### 概要\nlocaleconv、getenv、setlocale和strerror的返回类型应该是指向const qulified的指针\n\n#### 解释\n修改localeconv、getenv、setlocale和strerror的返回指针将导致未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1655884551998"
	},
	{
		"name": "Do not use returned pointer of asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or sterror following a subsequent call to the same function",
		"code": "MSR_21_20",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, returned pointer of asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or sterror is used following a subsequent call to the same function",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 在后续调用同一函数后使用了asctime、ctime、gmtime、localtime、localeconv、getenv、setlocale 或 sterror 的返回指针",
			"code": "MSR_21_20",
			"override": "T",
			"master_id": "2160",
			"name": "Do not use returned pointer of asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or sterror following a subsequent call to the same function",
			"name_cn": "不要在后续调用同一函数后使用 asctime、ctime、gmtime、localtime、localeconv、getenv、setlocale 或 sterror 的返回指针",
			"compliance": "M",
			"desc_en": "Do not use returned pointer of asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or sterror following a subsequent call to the same function",
			"desc_cn": "不要在后续调用同一函数后使用 asctime、ctime、gmtime、localtime、localeconv、getenv、setlocale 或 sterror 的返回指针",
			"abstract": "Do not use returned pointer of asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or sterror following a subsequent call to the same function",
			"explanation": "The use of returned pointer of asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or sterror following a subsequent call to the same function would lead to undefined behaviors.",
			"abstract_cn": "不要在后续调用同一函数后使用 asctime、ctime、gmtime、localtime、localeconv、getenv、setlocale 或 sterror 的返回指针",
			"explanation_cn": "在随后调用同一函数后使用 asctime、ctime、gmtime、localtime、localeconv、getenv、setlocale 或 sterror返回的指针将导致未定义的行为。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nDo not use returned pointer of asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or sterror following a subsequent call to the same function\n\n#### Explanation\nThe use of returned pointer of asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or sterror following a subsequent call to the same function would lead to undefined behaviors.",
			"details_cn": "#### 概要\n不要在后续调用同一函数后使用 asctime、ctime、gmtime、localtime、localeconv、getenv、setlocale 或 sterror 的返回指针\n\n#### 解释\n在随后调用同一函数后使用 asctime、ctime、gmtime、localtime、localeconv、getenv、setlocale 或 sterror返回的指针将导致未定义的行为。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1655884576834"
	},
	{
		"name": "Do not use a pointer to FILE after a closure on stream",
		"code": "MSR_22_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, a pointer to FILE after a closure on stream is used",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 在流关闭后使用了指向 FILE 的指针",
			"code": "MSR_22_6",
			"override": "T",
			"master_id": "2161",
			"name": "Do not use a pointer to FILE after a closure on stream",
			"name_cn": "在流关闭后不要使用指向 FILE 的指针",
			"compliance": "M",
			"desc_en": "Do not use a pointer to FILE after a closure on stream",
			"desc_cn": "在流关闭后不要使用指向 FILE 的指针",
			"abstract": "Do not use a pointer to FILE after a closure on stream",
			"explanation": "Using a pointer to FILE after the associated stream has been closed may lead to errors because that object will be having an undefined state.",
			"abstract_cn": "在流关闭后不要使用指向 FILE 的指针",
			"explanation_cn": "在关联流关闭后使用指向 FILE 的指针可能会导致错误，因为该对象将具有未定义的状态。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nDo not use a pointer to FILE after a closure on stream\n\n#### Explanation\nUsing a pointer to FILE after the associated stream has been closed may lead to errors because that object will be having an undefined state.",
			"details_cn": "#### 概要\n在流关闭后不要使用指向 FILE 的指针\n\n#### 解释\n在关联流关闭后使用指向 FILE 的指针可能会导致错误，因为该对象将具有未定义的状态。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1656312338885"
	},
	{
		"name": "Do not use unreachable code",
		"code": "MSR_2_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, there is unreachable code",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 存在无法访问的代码",
			"code": "MSR_2_1",
			"override": "T",
			"master_id": "2162",
			"name": "Do not use unreachable code",
			"name_cn": "不要使用无法访问的代码",
			"compliance": "R",
			"desc_en": "Do not use unreachable code",
			"desc_cn": "不要使用无法访问的代码",
			"abstract": "Do not use unreachable code",
			"explanation": "The compiler may remove unreachable code for optimization. The unreachable code that not removed by compiler can waste resources.",
			"abstract_cn": "不要使用无法访问的代码",
			"explanation_cn": "编译器可能会删除无法访问的代码以进行优化。 没有被编译器删除的不可达代码会浪费资源。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nDo not use unreachable code\n\n#### Explanation\nThe compiler may remove unreachable code for optimization. The unreachable code that not removed by compiler can waste resources.",
			"details_cn": "#### 概要\n不要使用无法访问的代码\n\n#### 解释\n编译器可能会删除无法访问的代码以进行优化。 没有被编译器删除的不可达代码会浪费资源。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1656390412331"
	},
	{
		"name": "Do not contain dead code",
		"code": "MSR_2_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, there is dead code",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 存在了无效代码",
			"code": "MSR_2_2",
			"override": "T",
			"master_id": "2163",
			"name": "Do not contain dead code",
			"name_cn": "不要包含无效代码",
			"compliance": "R",
			"desc_en": "Do not contain dead code",
			"desc_cn": "不要包含无效代码",
			"abstract": "Do not contain dead code",
			"explanation": "The presence of dead code is confusing since it may be removed by compiler.",
			"abstract_cn": "不要包含无效代码",
			"explanation_cn": "无效代码的存在令人困惑，因为它可能会被编译器删除。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nDo not contain dead code\n\n#### Explanation\nThe presence of dead code is confusing since it may be removed by compiler.",
			"details_cn": "#### 概要\n不要包含无效代码\n\n#### 解释\n无效代码的存在令人困惑，因为它可能会被编译器删除。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1656404100682"
	},
	{
		"name": "Do not declare unused tag in project",
		"code": "MSR_2_4",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, unused tag is declared in project",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 在项目中声明了未使用的标签",
			"code": "MSR_2_4",
			"override": "T",
			"master_id": "2164",
			"name": "Do not declare unused tag in project",
			"name_cn": "不要在项目中声明未使用的标签",
			"compliance": "A",
			"desc_en": "Do not declare unused tag in project",
			"desc_cn": "不要在项目中声明未使用的标签",
			"abstract": "Do not declare unused tag in project",
			"explanation": "The presence of an unused tag can be confusing.",
			"abstract_cn": "不要在项目中声明未使用的标签",
			"explanation_cn": "未使用的标签的存在可能会造成混淆。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nDo not declare unused tag in project\n\n#### Explanation\nThe presence of an unused tag can be confusing.",
			"details_cn": "#### 概要\n不要在项目中声明未使用的标签\n\n#### 解释\n未使用的标签的存在可能会造成混淆。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1656404138540"
	},
	{
		"name": "Do not declare unused macro in project",
		"code": "MSR_2_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, unused macro is declared in project",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 在项目中声明了未使用的宏",
			"code": "MSR_2_5",
			"override": "T",
			"master_id": "2165",
			"name": "Do not declare unused macro in project",
			"name_cn": "不要在项目中声明未使用的宏",
			"compliance": "A",
			"desc_en": "Do not declare unused macro in project",
			"desc_cn": "不要在项目中声明未使用的宏",
			"abstract": "Do not declare unused macro in project",
			"explanation": "The declaration of an unused macro can be confusing.",
			"abstract_cn": "不要在项目中声明未使用的宏",
			"explanation_cn": "未使用的宏的声明可能会造成混淆。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nDo not declare unused macro in project\n\n#### Explanation\nThe declaration of an unused macro can be confusing.",
			"details_cn": "#### 概要\n不要在项目中声明未使用的宏\n\n#### 解释\n未使用的宏的声明可能会造成混淆。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1656482647587"
	},
	{
		"name": "Do not contain unused parameters in functions",
		"code": "MSR_2_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "In file ${so.filename}, line ${so.line}, ${so.func}, there are unused parameters.",
			"msg_templ_cn": "在${so.filename}，第${so.line}行，函数${so.func}, 存在未使用的参数。",
			"code": "MSR_2_7",
			"override": "T",
			"master_id": "2166",
			"name": "Do not contain unused parameters in functions",
			"name_cn": "函数中不要包含未使用的参数",
			"compliance": "A",
			"desc_en": "Do not contain unused parameters in functions",
			"desc_cn": "函数中不要包含未使用的参数",
			"abstract": "Do not contain unused parameters in functions",
			"explanation": "There may be mismatch between the implementation and specification of the function if it contains unused parameters.",
			"abstract_cn": "函数中不要包含未使用的参数",
			"explanation_cn": "如果函数包含未使用的参数，则该函数的实现和规范之间可能出现不匹配。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nDo not contain unused parameters in functions\n\n#### Explanation\nThere may be mismatch between the implementation and specification of the function if it contains unused parameters.",
			"details_cn": "#### 概要\n函数中不要包含未使用的参数\n\n#### 解释\n如果函数包含未使用的参数，则该函数的实现和规范之间可能出现不匹配。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1656482697484"
	},
	{
		"name": "Do not contain character sequences in a comment",
		"code": "MSR_3_1",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "",
			"msg_templ_cn": "",
			"code": "MSR_3_1",
			"override": "T",
			"master_id": "2167",
			"name": "Do not contain character sequences in a comment",
			"name_cn": "不要嵌套注释",
			"compliance": "R",
			"desc_en": "Do not contain character sequences in a comment",
			"desc_cn": "不要嵌套注释",
			"abstract": "Do not contain character sequences in a comment",
			"explanation": "Using character sequences in a comment may cause some crucial code to become inside comments.",
			"abstract_cn": "不要嵌套注释可能会导致一些关键代码成为内部注释。",
			"explanation_cn": "嵌套注释",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nDo not contain character sequences in a comment\n\n#### Explanation\nUsing character sequences in a comment may cause some crucial code to become inside comments.",
			"details_cn": "#### 概要\n不要嵌套注释可能会导致一些关键代码成为内部注释。\n\n#### 解释\n嵌套注释",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1656903075718"
	},
	{
		"name": "Do not use line-splicing in // comment",
		"code": "MSR_3_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "",
			"msg_templ_cn": "",
			"code": "MSR_3_2",
			"override": "T",
			"master_id": "2168",
			"name": "Do not use line-splicing in // comment",
			"name_cn": "不要在 // 注释中使用行拼接",
			"compliance": "R",
			"desc_en": "Do not use line-splicing in // comment",
			"desc_cn": "不要在 // 注释中使用行拼接",
			"abstract": "Do not use line-splicing in // comment",
			"explanation": "Using line-splicing in // comment would make the next line become comment and cause confusion.",
			"abstract_cn": "不要在 // 注释中使用行拼接",
			"explanation_cn": "在 // 注释中使用行拼接会使下一行变成注释并引起混淆。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nDo not use line-splicing in // comment\n\n#### Explanation\nUsing line-splicing in // comment would make the next line become comment and cause confusion.",
			"details_cn": "#### 概要\n不要在 // 注释中使用行拼接\n\n#### 解释\n在 // 注释中使用行拼接会使下一行变成注释并引起混淆。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1656903150663"
	},
	{
		"name": "The name and type of the declarations of an object or function should be the same",
		"code": "MSR_8_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "",
			"msg_templ_cn": "",
			"code": "MSR_8_3",
			"override": "T",
			"master_id": "2169",
			"name": "The name and type of the declarations of an object or function should be the same",
			"name_cn": "对象或函数声明的名称和类型应该相同",
			"compliance": "R",
			"desc_en": "The name and type of the declarations of an object or function should be the same",
			"desc_cn": "对象或函数声明的名称和类型应该相同",
			"abstract": "The name and type of the declarations of an object or function should be the same",
			"explanation": "Making the name and type of the declarations of an object or function the same improves the code consistency.",
			"abstract_cn": "对象或函数声明的名称和类型应该相同",
			"explanation_cn": "使对象或函数的声明的名称和类型相同可以提高代码的一致性。",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\nThe name and type of the declarations of an object or function should be the same\n\n#### Explanation\nMaking the name and type of the declarations of an object or function the same improves the code consistency.",
			"details_cn": "#### 概要\n对象或函数声明的名称和类型应该相同\n\n#### 解释\n使对象或函数的声明的名称和类型相同可以提高代码的一致性。",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1656903357683"
	},
	{
		"name": "?",
		"code": "MSR_8_5",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "",
			"msg_templ_cn": "",
			"code": "MSR_8_5",
			"override": "T",
			"master_id": "2170",
			"name": "?",
			"name_cn": "",
			"desc_en": "",
			"desc_cn": "",
			"abstract": "",
			"explanation": "",
			"abstract_cn": "",
			"explanation_cn": "",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\n\n\n#### Explanation\n",
			"details_cn": "#### 概要\n\n\n#### 解释\n",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": 1656906359103
	},
	{
		"name": "?",
		"code": "MSR_8_6",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "",
			"msg_templ_en": "",
			"msg_templ_cn": "",
			"code": "MSR_8_6",
			"override": "T",
			"master_id": "2171",
			"name": "?",
			"name_cn": "",
			"desc_en": "",
			"desc_cn": "",
			"abstract": "",
			"explanation": "",
			"abstract_cn": "",
			"explanation_cn": "",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\n\n\n#### Explanation\n",
			"details_cn": "#### 概要\n\n\n#### 解释\n",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": 1656906783769
	},
	{
		"name": "?",
		"code": "MSR_8_7",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "",
			"msg_templ_en": "",
			"msg_templ_cn": "",
			"code": "MSR_8_7",
			"override": "T",
			"master_id": "2172",
			"name": "?",
			"name_cn": "",
			"desc_en": "",
			"desc_cn": "",
			"abstract": "",
			"explanation": "",
			"abstract_cn": "",
			"explanation_cn": "",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\n\n\n#### Explanation\n",
			"details_cn": "#### 概要\n\n\n#### 解释\n",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": 1656906852040
	},
	{
		"name": "?",
		"code": "MSR_20_2",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "",
			"msg_templ_cn": "",
			"code": "MSR_20_2",
			"override": "T",
			"master_id": "2173",
			"name": "?",
			"name_cn": "",
			"desc_en": "",
			"desc_cn": "",
			"abstract": "",
			"explanation": "",
			"abstract_cn": "",
			"explanation_cn": "",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\n\n\n#### Explanation\n",
			"details_cn": "#### 概要\n\n\n#### 解释\n",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": "1656908276157"
	},
	{
		"name": "?",
		"code": "MSR_20_3",
		"rules": {
			"category": "",
			"mapping": "",
			"AutoSAR": "",
			"misra_c": "",
			"misra_cpp": "",
			"GJB5369": "",
			"GJB8114": "",
			"language": "c",
			"msg_templ_en": "",
			"msg_templ_cn": "",
			"code": "MSR_20_3",
			"override": "T",
			"master_id": "2174",
			"name": "?",
			"name_cn": "",
			"desc_en": "",
			"desc_cn": "",
			"abstract": "",
			"explanation": "",
			"abstract_cn": "",
			"explanation_cn": "",
			"example_good": "",
			"example_bad": "",
			"details_en": "#### Abstract\n\n\n#### Explanation\n",
			"details_cn": "#### 概要\n\n\n#### 解释\n",
			"examples": {
				"good": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				},
				"bad": {
					"cpp": [
						""
					],
					"java": [
						""
					],
					"c": [
						""
					],
					"general": [
						""
					]
				}
			}
		},
		"id": 1657854328553
	}
]